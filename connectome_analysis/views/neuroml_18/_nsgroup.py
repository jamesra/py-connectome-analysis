# .\neuroml\_nsgroup.py
# -*- coding: utf-8 -*-
# PyXB bindings for NGM:38f6b4a17cef677a41e02589f8782bfe714fd0a1
# Generated 2013-10-11 13:58:41.927000 by PyXB version 1.2.3
# Group contents:
# Namespace http://morphml.org/biophysics/schema [xmlns:bio]
# Namespace http://morphml.org/channelml/schema [xmlns:cml]
# Namespace http://morphml.org/metadata/schema [xmlns:meta]
# Namespace http://morphml.org/morphml/schema [xmlns:mml]
# Namespace http://morphml.org/networkml/schema [xmlns:net]
# Namespace http://morphml.org/neuroml/schema


import pyxb
import pyxb.binding
import pyxb.utils.utility

# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:869d53cf-32af-11e3-8e1e-001fbc00ed03')

# Import bindings for schemas in group
import pyxb.binding.datatypes

# NOTE: All namespace declarations are reserved within the binding
_Namespace_bio = pyxb.namespace.NamespaceForURI(u'http://morphml.org/biophysics/schema', create_if_missing=True)
_Namespace_bio.configureCategories(['typeBinding', 'elementBinding'])
_Namespace_cml = pyxb.namespace.NamespaceForURI(u'http://morphml.org/channelml/schema', create_if_missing=True)
_Namespace_cml.configureCategories(['typeBinding', 'elementBinding'])
_Namespace_meta = pyxb.namespace.NamespaceForURI(u'http://morphml.org/metadata/schema', create_if_missing=True)
_Namespace_meta.configureCategories(['typeBinding', 'elementBinding'])
_Namespace_mml = pyxb.namespace.NamespaceForURI(u'http://morphml.org/morphml/schema', create_if_missing=True)
_Namespace_mml.configureCategories(['typeBinding', 'elementBinding'])
_Namespace_net = pyxb.namespace.NamespaceForURI(u'http://morphml.org/networkml/schema', create_if_missing=True)
_Namespace_net.configureCategories(['typeBinding', 'elementBinding'])
_Namespace = pyxb.namespace.NamespaceForURI(u'http://morphml.org/neuroml/schema', create_if_missing=True)
_Namespace.configureCategories(['typeBinding', 'elementBinding'])

# Atomic simple type: {http://morphml.org/biophysics/schema}MechanismType
class MechanismType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Specifies the type of cellular mechanism. Note could be used for any type of electrophysiological
                property of a section of a cell"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'MechanismType')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 302, 8)
    _Documentation = u'Specifies the type of cellular mechanism. Note could be used for any type of electrophysiological\n                property of a section of a cell'
MechanismType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=MechanismType, enum_prefix=None)
MechanismType.Channel_Mechanism = MechanismType._CF_enumeration.addEnumeration(unicode_value=u'Channel Mechanism', tag=u'Channel_Mechanism')
MechanismType.Ion_Concentration = MechanismType._CF_enumeration.addEnumeration(unicode_value=u'Ion Concentration', tag=u'Ion_Concentration')
MechanismType._InitializeFacetMap(MechanismType._CF_enumeration)
_Namespace_bio.addCategoryObject('typeBinding', u'MechanismType', MechanismType)

# Atomic simple type: {http://morphml.org/biophysics/schema}SynapticDelayValue
class SynapticDelayValue (pyxb.binding.datatypes.double):

    """Units of a delay associated with a synaptic connection"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'SynapticDelayValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 323, 8)
    _Documentation = u'Units of a delay associated with a synaptic connection'
SynapticDelayValue._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=SynapticDelayValue, value=pyxb.binding.datatypes.double(0.0))
SynapticDelayValue._InitializeFacetMap(SynapticDelayValue._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'SynapticDelayValue', SynapticDelayValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}TimeConstantValue
class TimeConstantValue (pyxb.binding.datatypes.double):

    """Units of any time constant, greater than zero"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'TimeConstantValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 337, 8)
    _Documentation = u'Units of any time constant, greater than zero'
TimeConstantValue._CF_minExclusive = pyxb.binding.facets.CF_minExclusive(value_datatype=pyxb.binding.datatypes.double, value=pyxb.binding.datatypes.anySimpleType(u'0'))
TimeConstantValue._InitializeFacetMap(TimeConstantValue._CF_minExclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'TimeConstantValue', TimeConstantValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}InvTimeConstantValue
class InvTimeConstantValue (pyxb.binding.datatypes.double):

    """Units of the inverse of a time constant"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'InvTimeConstantValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 350, 8)
    _Documentation = u'Units of the inverse of a time constant'
InvTimeConstantValue._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=InvTimeConstantValue, value=pyxb.binding.datatypes.double(0.0))
InvTimeConstantValue._InitializeFacetMap(InvTimeConstantValue._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'InvTimeConstantValue', InvTimeConstantValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}TimeConstantValueIncZero
class TimeConstantValueIncZero (pyxb.binding.datatypes.double):

    """Units of any time constant which can have value zero"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'TimeConstantValueIncZero')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 364, 8)
    _Documentation = u'Units of any time constant which can have value zero'
TimeConstantValueIncZero._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=TimeConstantValueIncZero, value=pyxb.binding.datatypes.double(0.0))
TimeConstantValueIncZero._InitializeFacetMap(TimeConstantValueIncZero._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'TimeConstantValueIncZero', TimeConstantValueIncZero)

# Atomic simple type: {http://morphml.org/biophysics/schema}TimeValue
class TimeValue (pyxb.binding.datatypes.double):

    """Units of any time value, zero or greater"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'TimeValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 378, 8)
    _Documentation = u'Units of any time value, zero or greater'
TimeValue._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=TimeValue, value=pyxb.binding.datatypes.double(0.0))
TimeValue._InitializeFacetMap(TimeValue._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'TimeValue', TimeValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}FrequencyValue
class FrequencyValue (pyxb.binding.datatypes.double):

    """Units of any frequency, zero or greater"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'FrequencyValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 392, 8)
    _Documentation = u'Units of any frequency, zero or greater'
FrequencyValue._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=FrequencyValue, value=pyxb.binding.datatypes.double(0.0))
FrequencyValue._InitializeFacetMap(FrequencyValue._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'FrequencyValue', FrequencyValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}ConductanceValue
class ConductanceValue (pyxb.binding.datatypes.double):

    """Units of conductance"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'ConductanceValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 406, 8)
    _Documentation = u'Units of conductance'
ConductanceValue._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=ConductanceValue, value=pyxb.binding.datatypes.double(0.0))
ConductanceValue._InitializeFacetMap(ConductanceValue._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'ConductanceValue', ConductanceValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}ConductanceDensityValue
class ConductanceDensityValue (pyxb.binding.datatypes.double):

    """Units of conductance density"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'ConductanceDensityValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 420, 8)
    _Documentation = u'Units of conductance density'
ConductanceDensityValue._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=ConductanceDensityValue, value=pyxb.binding.datatypes.double(0.0))
ConductanceDensityValue._InitializeFacetMap(ConductanceDensityValue._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'ConductanceDensityValue', ConductanceDensityValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}LengthValue
class LengthValue (pyxb.binding.datatypes.double):

    """Units of length"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'LengthValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 435, 8)
    _Documentation = u'Units of length'
LengthValue._InitializeFacetMap()
_Namespace_bio.addCategoryObject('typeBinding', u'LengthValue', LengthValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}CurrentValue
class CurrentValue (pyxb.binding.datatypes.double):

    """Units of current"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'CurrentValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 450, 8)
    _Documentation = u'Units of current'
CurrentValue._InitializeFacetMap()
_Namespace_bio.addCategoryObject('typeBinding', u'CurrentValue', CurrentValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}ConcentrationValue
class ConcentrationValue (pyxb.binding.datatypes.double):

    """Units of concentration"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'ConcentrationValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 463, 8)
    _Documentation = u'Units of concentration'
ConcentrationValue._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=ConcentrationValue, value=pyxb.binding.datatypes.double(0.0))
ConcentrationValue._InitializeFacetMap(ConcentrationValue._CF_minInclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'ConcentrationValue', ConcentrationValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}VoltageValue
class VoltageValue (pyxb.binding.datatypes.double):

    """Units of voltage"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'VoltageValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 478, 8)
    _Documentation = u'Units of voltage'
VoltageValue._InitializeFacetMap()
_Namespace_bio.addCategoryObject('typeBinding', u'VoltageValue', VoltageValue)

# Atomic simple type: {http://morphml.org/biophysics/schema}TemperatureValue
class TemperatureValue (pyxb.binding.datatypes.double):

    """Units of temperature"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'TemperatureValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 489, 8)
    _Documentation = u'Units of temperature'
TemperatureValue._CF_minExclusive = pyxb.binding.facets.CF_minExclusive(value_datatype=pyxb.binding.datatypes.double, value=pyxb.binding.datatypes.anySimpleType(u'0'))
TemperatureValue._InitializeFacetMap(TemperatureValue._CF_minExclusive)
_Namespace_bio.addCategoryObject('typeBinding', u'TemperatureValue', TemperatureValue)

# Atomic simple type: {http://morphml.org/channelml/schema}ConductanceLaw
class ConductanceLaw (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Introduced in v1.7.3 for new format ChannelML. Specifies which type of conductance law to use: ohmic, etc."""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ConductanceLaw')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 590, 4)
    _Documentation = u'Introduced in v1.7.3 for new format ChannelML. Specifies which type of conductance law to use: ohmic, etc.'
ConductanceLaw._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=ConductanceLaw, enum_prefix=None)
ConductanceLaw.ohmic = ConductanceLaw._CF_enumeration.addEnumeration(unicode_value=u'ohmic', tag=u'ohmic')
ConductanceLaw.integrate_and_fire = ConductanceLaw._CF_enumeration.addEnumeration(unicode_value=u'integrate_and_fire', tag=u'integrate_and_fire')
ConductanceLaw._InitializeFacetMap(ConductanceLaw._CF_enumeration)
_Namespace_cml.addCategoryObject('typeBinding', u'ConductanceLaw', ConductanceLaw)

# Atomic simple type: {http://morphml.org/channelml/schema}Deprecated_IonRole
class Deprecated_IonRole (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Role ion plays in cellular mechanism, e.g. ion passes through the channel (Na, K), or the 
            concentration of the ion is a factor in the rate equations of gating, or the mechanism alters 
            the concentration of this ion. This greatly simplifies the number of roles an ion can play 
            in the channel, but these options cover the majority of cases currently being modelled. Note: the term subtance is used as 
            this formalism can also be used for other chemicals which may be transmitted, modulate channels, etc."""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_IonRole')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 823, 4)
    _Documentation = u'Role ion plays in cellular mechanism, e.g. ion passes through the channel (Na, K), or the \n            concentration of the ion is a factor in the rate equations of gating, or the mechanism alters \n            the concentration of this ion. This greatly simplifies the number of roles an ion can play \n            in the channel, but these options cover the majority of cases currently being modelled. Note: the term subtance is used as \n            this formalism can also be used for other chemicals which may be transmitted, modulate channels, etc.'
Deprecated_IonRole._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=Deprecated_IonRole, enum_prefix=None)
Deprecated_IonRole.PermeatedSubstance = Deprecated_IonRole._CF_enumeration.addEnumeration(unicode_value=u'PermeatedSubstance', tag=u'PermeatedSubstance')
Deprecated_IonRole.PermeatedSubstanceFixedRevPot = Deprecated_IonRole._CF_enumeration.addEnumeration(unicode_value=u'PermeatedSubstanceFixedRevPot', tag=u'PermeatedSubstanceFixedRevPot')
Deprecated_IonRole.ModulatingSubstance = Deprecated_IonRole._CF_enumeration.addEnumeration(unicode_value=u'ModulatingSubstance', tag=u'ModulatingSubstance')
Deprecated_IonRole.SignallingSubstance = Deprecated_IonRole._CF_enumeration.addEnumeration(unicode_value=u'SignallingSubstance', tag=u'SignallingSubstance')
Deprecated_IonRole._InitializeFacetMap(Deprecated_IonRole._CF_enumeration)
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_IonRole', Deprecated_IonRole)

# Atomic simple type: {http://morphml.org/channelml/schema}CoreEquationType
class CoreEquationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Enumeration of core equation types, used from v1.7.3: exp_linear, sigmoidal, exponential"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'CoreEquationType')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1591, 4)
    _Documentation = u'Enumeration of core equation types, used from v1.7.3: exp_linear, sigmoidal, exponential'
CoreEquationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CoreEquationType, enum_prefix=None)
CoreEquationType.exponential = CoreEquationType._CF_enumeration.addEnumeration(unicode_value=u'exponential', tag=u'exponential')
CoreEquationType.sigmoid = CoreEquationType._CF_enumeration.addEnumeration(unicode_value=u'sigmoid', tag=u'sigmoid')
CoreEquationType.exp_linear = CoreEquationType._CF_enumeration.addEnumeration(unicode_value=u'exp_linear', tag=u'exp_linear')
CoreEquationType.generic = CoreEquationType._CF_enumeration.addEnumeration(unicode_value=u'generic', tag=u'generic')
CoreEquationType._InitializeFacetMap(CoreEquationType._CF_enumeration)
_Namespace_cml.addCategoryObject('typeBinding', u'CoreEquationType', CoreEquationType)

# Atomic simple type: {http://morphml.org/channelml/schema}Deprecated_CoreEquationType
class Deprecated_CoreEquationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Core equation types prior to v1.7.3, linoidal, sigmoidal, exponential"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_CoreEquationType')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1622, 4)
    _Documentation = u'Core equation types prior to v1.7.3, linoidal, sigmoidal, exponential'
Deprecated_CoreEquationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=Deprecated_CoreEquationType, enum_prefix=None)
Deprecated_CoreEquationType.exponential = Deprecated_CoreEquationType._CF_enumeration.addEnumeration(unicode_value=u'exponential', tag=u'exponential')
Deprecated_CoreEquationType.sigmoid = Deprecated_CoreEquationType._CF_enumeration.addEnumeration(unicode_value=u'sigmoid', tag=u'sigmoid')
Deprecated_CoreEquationType.linoid = Deprecated_CoreEquationType._CF_enumeration.addEnumeration(unicode_value=u'linoid', tag=u'linoid')
Deprecated_CoreEquationType._InitializeFacetMap(Deprecated_CoreEquationType._CF_enumeration)
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_CoreEquationType', Deprecated_CoreEquationType)

# Atomic simple type: {http://morphml.org/metadata/schema}LengthUnits
class LengthUnits (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Enumeration of length units. Used in MorphML Level 1 files, where length is the only important dimension. Note: micrometer is preferred to micron from v1.8.1"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'LengthUnits')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 180, 4)
    _Documentation = u'Enumeration of length units. Used in MorphML Level 1 files, where length is the only important dimension. Note: micrometer is preferred to micron from v1.8.1'
LengthUnits._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=LengthUnits, enum_prefix=None)
LengthUnits.micron = LengthUnits._CF_enumeration.addEnumeration(unicode_value=u'micron', tag=u'micron')
LengthUnits.micrometer = LengthUnits._CF_enumeration.addEnumeration(unicode_value=u'micrometer', tag=u'micrometer')
LengthUnits.millimeter = LengthUnits._CF_enumeration.addEnumeration(unicode_value=u'millimeter', tag=u'millimeter')
LengthUnits.meter = LengthUnits._CF_enumeration.addEnumeration(unicode_value=u'meter', tag=u'meter')
LengthUnits._InitializeFacetMap(LengthUnits._CF_enumeration)
_Namespace_meta.addCategoryObject('typeBinding', u'LengthUnits', LengthUnits)

# Atomic simple type: {http://morphml.org/metadata/schema}VolumeUnits
class VolumeUnits (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Enumeration of volume units."""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'VolumeUnits')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 202, 4)
    _Documentation = u'Enumeration of volume units.'
VolumeUnits._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=VolumeUnits, enum_prefix=None)
VolumeUnits.cubic_millimeter = VolumeUnits._CF_enumeration.addEnumeration(unicode_value=u'cubic_millimeter', tag=u'cubic_millimeter')
VolumeUnits.millilitre = VolumeUnits._CF_enumeration.addEnumeration(unicode_value=u'millilitre', tag=u'millilitre')
VolumeUnits.litre = VolumeUnits._CF_enumeration.addEnumeration(unicode_value=u'litre', tag=u'litre')
VolumeUnits._InitializeFacetMap(VolumeUnits._CF_enumeration)
_Namespace_meta.addCategoryObject('typeBinding', u'VolumeUnits', VolumeUnits)

# Atomic simple type: {http://morphml.org/metadata/schema}SegmentIdInCell
class SegmentIdInCell (pyxb.binding.datatypes.nonNegativeInteger):

    """Id of individual segment in a cell (integer 0 or greater). Placed in Metadata, as it's used across Levels"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'SegmentIdInCell')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 214, 4)
    _Documentation = u"Id of individual segment in a cell (integer 0 or greater). Placed in Metadata, as it's used across Levels"
SegmentIdInCell._InitializeFacetMap()
_Namespace_meta.addCategoryObject('typeBinding', u'SegmentIdInCell', SegmentIdInCell)

# Atomic simple type: {http://morphml.org/metadata/schema}Notes
class Notes (pyxb.binding.datatypes.string):

    """Textual human readable notes related to the element in question. It's useful to put these into
         the NeuroML files instead of XML comments, as the notes can be extracted and repeated in the files to which the NeuroML is mapped."""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Notes')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 224, 4)
    _Documentation = u"Textual human readable notes related to the element in question. It's useful to put these into\n         the NeuroML files instead of XML comments, as the notes can be extracted and repeated in the files to which the NeuroML is mapped."
Notes._InitializeFacetMap()
_Namespace_meta.addCategoryObject('typeBinding', u'Notes', Notes)

# Atomic simple type: {http://morphml.org/metadata/schema}Group
class Group (pyxb.binding.datatypes.string):

    """Allows elements to be associated, such as for grouping segments or cables into the basal arbor."""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Group')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 234, 4)
    _Documentation = u'Allows elements to be associated, such as for grouping segments or cables into the basal arbor.'
Group._InitializeFacetMap()
_Namespace_meta.addCategoryObject('typeBinding', u'Group', Group)

# Atomic simple type: {http://morphml.org/metadata/schema}YesNo
class YesNo (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """String with only yes or no allowed"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'YesNo')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 308, 8)
    _Documentation = u'String with only yes or no allowed'
YesNo._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=YesNo, enum_prefix=None)
YesNo.yes = YesNo._CF_enumeration.addEnumeration(unicode_value=u'yes', tag=u'yes')
YesNo.no = YesNo._CF_enumeration.addEnumeration(unicode_value=u'no', tag=u'no')
YesNo._InitializeFacetMap(YesNo._CF_enumeration)
_Namespace_meta.addCategoryObject('typeBinding', u'YesNo', YesNo)

# Atomic simple type: {http://morphml.org/metadata/schema}ZeroToOne
class ZeroToOne (pyxb.binding.datatypes.double):

    """Double restricted to between 1 and 0"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'ZeroToOne')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 320, 8)
    _Documentation = u'Double restricted to between 1 and 0'
ZeroToOne._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=ZeroToOne, value=pyxb.binding.datatypes.double(1.0))
ZeroToOne._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=ZeroToOne, value=pyxb.binding.datatypes.double(0.0))
ZeroToOne._InitializeFacetMap(ZeroToOne._CF_maxInclusive,
   ZeroToOne._CF_minInclusive)
_Namespace_meta.addCategoryObject('typeBinding', u'ZeroToOne', ZeroToOne)

# Atomic simple type: {http://morphml.org/metadata/schema}Percentage
class Percentage (pyxb.binding.datatypes.double):

    """Double restricted to between 0 and 100"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Percentage')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 331, 8)
    _Documentation = u'Double restricted to between 0 and 100'
Percentage._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=Percentage, value=pyxb.binding.datatypes.double(100.0))
Percentage._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=Percentage, value=pyxb.binding.datatypes.double(0.0))
Percentage._InitializeFacetMap(Percentage._CF_maxInclusive,
   Percentage._CF_minInclusive)
_Namespace_meta.addCategoryObject('typeBinding', u'Percentage', Percentage)

# Atomic simple type: {http://morphml.org/metadata/schema}NonNegativeDouble
class NonNegativeDouble (pyxb.binding.datatypes.double):

    """Double restricted to 0 or greater"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'NonNegativeDouble')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 342, 8)
    _Documentation = u'Double restricted to 0 or greater'
NonNegativeDouble._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=NonNegativeDouble, value=pyxb.binding.datatypes.double(0.0))
NonNegativeDouble._InitializeFacetMap(NonNegativeDouble._CF_minInclusive)
_Namespace_meta.addCategoryObject('typeBinding', u'NonNegativeDouble', NonNegativeDouble)

# Atomic simple type: {http://morphml.org/metadata/schema}PositiveDouble
class PositiveDouble (pyxb.binding.datatypes.double):

    """Double restricted greater than 0"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'PositiveDouble')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 353, 8)
    _Documentation = u'Double restricted greater than 0'
PositiveDouble._CF_minExclusive = pyxb.binding.facets.CF_minExclusive(value_datatype=pyxb.binding.datatypes.double, value=pyxb.binding.datatypes.anySimpleType(u'0'))
PositiveDouble._InitializeFacetMap(PositiveDouble._CF_minExclusive)
_Namespace_meta.addCategoryObject('typeBinding', u'PositiveDouble', PositiveDouble)

# Atomic simple type: {http://morphml.org/metadata/schema}Units
class Units (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Enumeration of unit scheme used. Only SI or Physiological units allowed"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Units')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 364, 8)
    _Documentation = u'Enumeration of unit scheme used. Only SI or Physiological units allowed'
Units._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=Units, enum_prefix=None)
Units.Physiological_Units = Units._CF_enumeration.addEnumeration(unicode_value=u'Physiological Units', tag=u'Physiological_Units')
Units.SI_Units = Units._CF_enumeration.addEnumeration(unicode_value=u'SI Units', tag=u'SI_Units')
Units._InitializeFacetMap(Units._CF_enumeration)
_Namespace_meta.addCategoryObject('typeBinding', u'Units', Units)

# Atomic simple type: {http://morphml.org/metadata/schema}StatusValue
class StatusValue (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Status enum for stability state of files. This is subject to change."""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'StatusValue')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 538, 4)
    _Documentation = u'Status enum for stability state of files. This is subject to change.'
StatusValue._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=StatusValue, enum_prefix=None)
StatusValue.stable = StatusValue._CF_enumeration.addEnumeration(unicode_value=u'stable', tag=u'stable')
StatusValue.in_progress = StatusValue._CF_enumeration.addEnumeration(unicode_value=u'in_progress', tag=u'in_progress')
StatusValue.known_issues = StatusValue._CF_enumeration.addEnumeration(unicode_value=u'known_issues', tag=u'known_issues')
StatusValue.deprecated = StatusValue._CF_enumeration.addEnumeration(unicode_value=u'deprecated', tag=u'deprecated')
StatusValue._InitializeFacetMap(StatusValue._CF_enumeration)
_Namespace_meta.addCategoryObject('typeBinding', u'StatusValue', StatusValue)

# Atomic simple type: {http://morphml.org/morphml/schema}Metric
class Metric (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Metric for use in InhomogeneousParam"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Metric')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 397, 4)
    _Documentation = u'Metric for use in InhomogeneousParam'
Metric._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=Metric, enum_prefix=None)
Metric.Path_Length_from_root = Metric._CF_enumeration.addEnumeration(unicode_value=u'Path Length from root', tag=u'Path_Length_from_root')
Metric.n3D_radial_position = Metric._CF_enumeration.addEnumeration(unicode_value=u'3D radial position', tag=u'n3D_radial_position')
Metric.n3D_path_length_from_line = Metric._CF_enumeration.addEnumeration(unicode_value=u'3D path length from line', tag=u'n3D_path_length_from_line')
Metric._InitializeFacetMap(Metric._CF_enumeration)
_Namespace_mml.addCategoryObject('typeBinding', u'Metric', Metric)

# Atomic simple type: {http://morphml.org/morphml/schema}SpineShape
class SpineShape (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Enumeration of allowed spine shapes."""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'SpineShape')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 462, 4)
    _Documentation = u'Enumeration of allowed spine shapes.'
SpineShape._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SpineShape, enum_prefix=None)
SpineShape.mushroom = SpineShape._CF_enumeration.addEnumeration(unicode_value=u'mushroom', tag=u'mushroom')
SpineShape.stubby = SpineShape._CF_enumeration.addEnumeration(unicode_value=u'stubby', tag=u'stubby')
SpineShape.thin = SpineShape._CF_enumeration.addEnumeration(unicode_value=u'thin', tag=u'thin')
SpineShape._InitializeFacetMap(SpineShape._CF_enumeration)
_Namespace_mml.addCategoryObject('typeBinding', u'SpineShape', SpineShape)

# Atomic simple type: [anonymous]
class STD_ANON (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 614, 20)
    _Documentation = None
STD_ANON._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON, enum_prefix=None)
STD_ANON.PreToPost = STD_ANON._CF_enumeration.addEnumeration(unicode_value=u'PreToPost', tag=u'PreToPost')
STD_ANON.PostToPre = STD_ANON._CF_enumeration.addEnumeration(unicode_value=u'PostToPre', tag=u'PostToPre')
STD_ANON._InitializeFacetMap(STD_ANON._CF_enumeration)

# Atomic simple type: {http://morphml.org/networkml/schema}SynapseDirection
class SynapseDirection (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Indicated whether a potential synapse location allows a presynaptic connection
                of the specified type, a postsynaptic connection or either. """

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'SynapseDirection')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 940, 8)
    _Documentation = u'Indicated whether a potential synapse location allows a presynaptic connection\n                of the specified type, a postsynaptic connection or either. '
SynapseDirection._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SynapseDirection, enum_prefix=None)
SynapseDirection.pre = SynapseDirection._CF_enumeration.addEnumeration(unicode_value=u'pre', tag=u'pre')
SynapseDirection.post = SynapseDirection._CF_enumeration.addEnumeration(unicode_value=u'post', tag=u'post')
SynapseDirection.preAndOrPost = SynapseDirection._CF_enumeration.addEnumeration(unicode_value=u'preAndOrPost', tag=u'preAndOrPost')
SynapseDirection._InitializeFacetMap(SynapseDirection._CF_enumeration)
_Namespace_net.addCategoryObject('typeBinding', u'SynapseDirection', SynapseDirection)

# Atomic simple type: {http://morphml.org/networkml/schema}CellIdInNetwork
class CellIdInNetwork (pyxb.binding.datatypes.nonNegativeInteger):

    """Id of individual cell in a network"""

    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'CellIdInNetwork')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 954, 8)
    _Documentation = u'Id of individual cell in a network'
CellIdInNetwork._InitializeFacetMap()
_Namespace_net.addCategoryObject('typeBinding', u'CellIdInNetwork', CellIdInNetwork)

# Complex type {http://morphml.org/biophysics/schema}SpecCapacitance with content type ELEMENT_ONLY
class SpecCapacitance (pyxb.binding.basis.complexTypeDefinition):
    """Capacitance per unit area of a group of sections"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'SpecCapacitance')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 134, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), 'parameter', '__httpmorphml_orgbiophysicsschema_SpecCapacitance_httpmorphml_orgbiophysicsschemaparameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 142, 12), )

    
    parameter = property(__parameter.value, __parameter.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}variableParameter uses Python identifier variableParameter
    __variableParameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), 'variableParameter', '__httpmorphml_orgbiophysicsschema_SpecCapacitance_httpmorphml_orgbiophysicsschemavariableParameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 143, 12), )

    
    variableParameter = property(__variableParameter.value, __variableParameter.set, None, u'Note variable_parameter will be the preferred form in v2.0')

    
    # Element {http://morphml.org/biophysics/schema}variable_parameter uses Python identifier variable_parameter
    __variable_parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter'), 'variable_parameter', '__httpmorphml_orgbiophysicsschema_SpecCapacitance_httpmorphml_orgbiophysicsschemavariable_parameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 148, 12), )

    
    variable_parameter = property(__variable_parameter.value, __variable_parameter.set, None, u'Note variable_parameter will be the preferred form in v2.0')

    _ElementMap.update({
        __parameter.name() : __parameter,
        __variableParameter.name() : __variableParameter,
        __variable_parameter.name() : __variable_parameter
    })
    _AttributeMap.update({
        
    })
_Namespace_bio.addCategoryObject('typeBinding', u'SpecCapacitance', SpecCapacitance)


# Complex type {http://morphml.org/biophysics/schema}SpecAxialResistance with content type ELEMENT_ONLY
class SpecAxialResistance (pyxb.binding.basis.complexTypeDefinition):
    """Specific axial resistance of a group of sections"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'SpecAxialResistance')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 157, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), 'parameter', '__httpmorphml_orgbiophysicsschema_SpecAxialResistance_httpmorphml_orgbiophysicsschemaparameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 165, 12), )

    
    parameter = property(__parameter.value, __parameter.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}variableParameter uses Python identifier variableParameter
    __variableParameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), 'variableParameter', '__httpmorphml_orgbiophysicsschema_SpecAxialResistance_httpmorphml_orgbiophysicsschemavariableParameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 166, 12), )

    
    variableParameter = property(__variableParameter.value, __variableParameter.set, None, u'Note variable_parameter will be the preferred form in v2.0')

    
    # Element {http://morphml.org/biophysics/schema}variable_parameter uses Python identifier variable_parameter
    __variable_parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter'), 'variable_parameter', '__httpmorphml_orgbiophysicsschema_SpecAxialResistance_httpmorphml_orgbiophysicsschemavariable_parameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 171, 12), )

    
    variable_parameter = property(__variable_parameter.value, __variable_parameter.set, None, u'Note variable_parameter will be the preferred form in v2.0')

    _ElementMap.update({
        __parameter.name() : __parameter,
        __variableParameter.name() : __variableParameter,
        __variable_parameter.name() : __variable_parameter
    })
    _AttributeMap.update({
        
    })
_Namespace_bio.addCategoryObject('typeBinding', u'SpecAxialResistance', SpecAxialResistance)


# Complex type {http://morphml.org/biophysics/schema}InitialMembPotential with content type ELEMENT_ONLY
class InitialMembPotential (pyxb.binding.basis.complexTypeDefinition):
    """This quantity is often required for computational simulations and specifies the potential
                difference across the membrane at the start of the simulation. This is an optional field"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'InitialMembPotential')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 180, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), 'parameter', '__httpmorphml_orgbiophysicsschema_InitialMembPotential_httpmorphml_orgbiophysicsschemaparameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 189, 12), )

    
    parameter = property(__parameter.value, __parameter.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}variableParameter uses Python identifier variableParameter
    __variableParameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), 'variableParameter', '__httpmorphml_orgbiophysicsschema_InitialMembPotential_httpmorphml_orgbiophysicsschemavariableParameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 190, 12), )

    
    variableParameter = property(__variableParameter.value, __variableParameter.set, None, None)

    _ElementMap.update({
        __parameter.name() : __parameter,
        __variableParameter.name() : __variableParameter
    })
    _AttributeMap.update({
        
    })
_Namespace_bio.addCategoryObject('typeBinding', u'InitialMembPotential', InitialMembPotential)


# Complex type {http://morphml.org/biophysics/schema}IonProperties with content type ELEMENT_ONLY
class IonProperties (pyxb.binding.basis.complexTypeDefinition):
    """Some properties accociated with an ion type which takes part in the mechanisms on the cell"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'IonProperties')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 196, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), 'parameter', '__httpmorphml_orgbiophysicsschema_IonProperties_httpmorphml_orgbiophysicsschemaparameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 201, 12), )

    
    parameter = property(__parameter.value, __parameter.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgbiophysicsschema_IonProperties_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 203, 8)
    __name._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 203, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __parameter.name() : __parameter
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_bio.addCategoryObject('typeBinding', u'IonProperties', IonProperties)


# Complex type {http://morphml.org/biophysics/schema}NamedParameter with content type ELEMENT_ONLY
class NamedParameter (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a value for a quantity and the associated groups of cables 
                        which have this value. Can have any name, but gmax and e are special..."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'NamedParameter')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 208, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), 'group', '__httpmorphml_orgbiophysicsschema_NamedParameter_httpmorphml_orgbiophysicsschemagroup', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 214, 11), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgbiophysicsschema_NamedParameter_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 216, 8)
    __name._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 216, 8)
    
    name = property(__name.value, __name.set, None, u'2 names have special meaning: gmax for the maximum conductance density, and e for the reversal potential of a passive channel')

    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgbiophysicsschema_NamedParameter_value', pyxb.binding.datatypes.double, required=True)
    __value._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 221, 8)
    __value._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 221, 8)
    
    value_ = property(__value.value, __value.set, None, None)

    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        __name.name() : __name,
        __value.name() : __value
    })
_Namespace_bio.addCategoryObject('typeBinding', u'NamedParameter', NamedParameter)


# Complex type {http://morphml.org/biophysics/schema}VariableParameter with content type ELEMENT_ONLY
class VariableParameter (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a value for a quantity which varies over a given group of cables"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'VariableParameter')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 224, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), 'group', '__httpmorphml_orgbiophysicsschema_VariableParameter_httpmorphml_orgbiophysicsschemagroup', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 229, 28), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}inhomogeneous_value uses Python identifier inhomogeneous_value
    __inhomogeneous_value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'inhomogeneous_value'), 'inhomogeneous_value', '__httpmorphml_orgbiophysicsschema_VariableParameter_httpmorphml_orgbiophysicsschemainhomogeneous_value', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 230, 28), )

    
    inhomogeneous_value = property(__inhomogeneous_value.value, __inhomogeneous_value.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgbiophysicsschema_VariableParameter_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 232, 8)
    __name._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 232, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __group.name() : __group,
        __inhomogeneous_value.name() : __inhomogeneous_value
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_bio.addCategoryObject('typeBinding', u'VariableParameter', VariableParameter)


# Complex type {http://morphml.org/biophysics/schema}VariableNamedParameter with content type ELEMENT_ONLY
class VariableNamedParameter (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a value for a quantity which varies over a given group of cables"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'VariableNamedParameter')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 235, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), 'group', '__httpmorphml_orgbiophysicsschema_VariableNamedParameter_httpmorphml_orgbiophysicsschemagroup', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 240, 28), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}inhomogeneous_value uses Python identifier inhomogeneous_value
    __inhomogeneous_value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'inhomogeneous_value'), 'inhomogeneous_value', '__httpmorphml_orgbiophysicsschema_VariableNamedParameter_httpmorphml_orgbiophysicsschemainhomogeneous_value', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 241, 28), )

    
    inhomogeneous_value = property(__inhomogeneous_value.value, __inhomogeneous_value.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgbiophysicsschema_VariableNamedParameter_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 243, 8)
    __name._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 243, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __group.name() : __group,
        __inhomogeneous_value.name() : __inhomogeneous_value
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_bio.addCategoryObject('typeBinding', u'VariableNamedParameter', VariableNamedParameter)


# Complex type {http://morphml.org/biophysics/schema}InhomogeneousValue with content type EMPTY
class InhomogeneousValue (pyxb.binding.basis.complexTypeDefinition):
    """How a value changes over the cable group. Implementation here based on NEURON inhomogeneous parameter specification.
            See example for usage of this element"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'InhomogeneousValue')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 247, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute param_name uses Python identifier param_name
    __param_name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'param_name'), 'param_name', '__httpmorphml_orgbiophysicsschema_InhomogeneousValue_param_name', pyxb.binding.datatypes.string, required=True)
    __param_name._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 252, 8)
    __param_name._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 252, 8)
    
    param_name = property(__param_name.value, __param_name.set, None, u'Name used in the inhomogeneous_param element in the cable group')

    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgbiophysicsschema_InhomogeneousValue_value', pyxb.binding.datatypes.string, required=True)
    __value._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 257, 8)
    __value._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 257, 8)
    
    value_ = property(__value.value, __value.set, None, u'Equation showing how parameter changes as function of variable attribute in inhomogeneous_param element')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __param_name.name() : __param_name,
        __value.name() : __value
    })
_Namespace_bio.addCategoryObject('typeBinding', u'InhomogeneousValue', InhomogeneousValue)


# Complex type {http://morphml.org/biophysics/schema}UnnamedParameter with content type ELEMENT_ONLY
class UnnamedParameter (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a value for a quantity and the associated groups of cables 
                        which have this value. The quantity referred to will be clear from the usage, e.g. InitialMembPotential"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'UnnamedParameter')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 288, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), 'group', '__httpmorphml_orgbiophysicsschema_UnnamedParameter_httpmorphml_orgbiophysicsschemagroup', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 295, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgbiophysicsschema_UnnamedParameter_value', pyxb.binding.datatypes.double, required=True)
    __value._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 297, 8)
    __value._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 297, 8)
    
    value_ = property(__value.value, __value.set, None, None)

    _ElementMap.update({
        __group.name() : __group
    })
    _AttributeMap.update({
        __value.name() : __value
    })
_Namespace_bio.addCategoryObject('typeBinding', u'UnnamedParameter', UnnamedParameter)


# Complex type {http://morphml.org/channelml/schema}Parameters with content type ELEMENT_ONLY
class Parameters (pyxb.binding.basis.complexTypeDefinition):
    """Fixed value parameters which can be used in generic expressions"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Parameters')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 101, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameter'), 'parameter', '__httpmorphml_orgchannelmlschema_Parameters_httpmorphml_orgchannelmlschemaparameter', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 108, 12), )

    
    parameter = property(__parameter.value, __parameter.set, None, None)

    _ElementMap.update({
        __parameter.name() : __parameter
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Parameters', Parameters)


# Complex type {http://morphml.org/channelml/schema}Parameter with content type EMPTY
class Parameter (pyxb.binding.basis.complexTypeDefinition):
    """A single parameter which can be used in generic expressions"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Parameter')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 113, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_Parameter_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 118, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 118, 8)
    
    name = property(__name.value, __name.set, None, u'A unique name for the parameter')

    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgchannelmlschema_Parameter_value', pyxb.binding.datatypes.double, required=True)
    __value._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 124, 8)
    __value._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 124, 8)
    
    value_ = property(__value.value, __value.set, None, u'The default value for the parameter')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __name.name() : __name,
        __value.name() : __value
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Parameter', Parameter)


# Complex type {http://morphml.org/channelml/schema}SynapseType with content type ELEMENT_ONLY
class SynapseType (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a synaptic mechanism"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'SynapseType')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 204, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}status uses Python identifier status
    __status = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'status'), 'status', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgchannelmlschemastatus', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 210, 12), )

    
    status = property(__status.value, __status.set, None, u'Status of the synapse specification: stable, in progress, etc.')

    
    # Element {http://morphml.org/channelml/schema}electrical_syn uses Python identifier electrical_syn
    __electrical_syn = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'electrical_syn'), 'electrical_syn', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgchannelmlschemaelectrical_syn', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 228, 16), )

    
    electrical_syn = property(__electrical_syn.value, __electrical_syn.set, None, u'Electrical synaptic coupling as at a gap junction')

    
    # Element {http://morphml.org/channelml/schema}doub_exp_syn uses Python identifier doub_exp_syn
    __doub_exp_syn = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'doub_exp_syn'), 'doub_exp_syn', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgchannelmlschemadoub_exp_syn', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 233, 16), )

    
    doub_exp_syn = property(__doub_exp_syn.value, __doub_exp_syn.set, None, u'Synaptic conductance with rise time and decay time')

    
    # Element {http://morphml.org/channelml/schema}blocking_syn uses Python identifier blocking_syn
    __blocking_syn = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'blocking_syn'), 'blocking_syn', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgchannelmlschemablocking_syn', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 238, 16), )

    
    blocking_syn = property(__blocking_syn.value, __blocking_syn.set, None, u'For example NMDA receptor synapses')

    
    # Element {http://morphml.org/channelml/schema}multi_decay_syn uses Python identifier multi_decay_syn
    __multi_decay_syn = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'multi_decay_syn'), 'multi_decay_syn', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgchannelmlschemamulti_decay_syn', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 244, 16), )

    
    multi_decay_syn = property(__multi_decay_syn.value, __multi_decay_syn.set, None, u'An extension incorporating multiple decay time courses')

    
    # Element {http://morphml.org/channelml/schema}fac_dep_syn uses Python identifier fac_dep_syn
    __fac_dep_syn = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'fac_dep_syn'), 'fac_dep_syn', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgchannelmlschemafac_dep_syn', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 250, 16), )

    
    fac_dep_syn = property(__fac_dep_syn.value, __fac_dep_syn.set, None, u'A facilitating and depressing synaptic mechanism')

    
    # Element {http://morphml.org/channelml/schema}stdp_syn uses Python identifier stdp_syn
    __stdp_syn = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'stdp_syn'), 'stdp_syn', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgchannelmlschemastdp_syn', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 256, 16), )

    
    stdp_syn = property(__stdp_syn.value, __stdp_syn.set, None, u'A synaptic mechanism implementing basic Spike Timing Dependent Plasticity based on Song and Abbott, 2001')

    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}authorList uses Python identifier authorList
    __authorList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), 'authorList', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemaauthorList', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12), )

    
    authorList = property(__authorList.value, __authorList.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}publication uses Python identifier publication
    __publication = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), 'publication', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemapublication', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12), )

    
    publication = property(__publication.value, __publication.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuronDBref uses Python identifier neuronDBref
    __neuronDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), 'neuronDBref', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemaneuronDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12), )

    
    neuronDBref = property(__neuronDBref.value, __neuronDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}modelDBref uses Python identifier modelDBref
    __modelDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), 'modelDBref', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemamodelDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12), )

    
    modelDBref = property(__modelDBref.value, __modelDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuroMorphoRef uses Python identifier neuroMorphoRef
    __neuroMorphoRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), 'neuroMorphoRef', '__httpmorphml_orgchannelmlschema_SynapseType_httpmorphml_orgmetadataschemaneuroMorphoRef', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12), )

    
    neuroMorphoRef = property(__neuroMorphoRef.value, __neuroMorphoRef.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_SynapseType_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 264, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 264, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __status.name() : __status,
        __electrical_syn.name() : __electrical_syn,
        __doub_exp_syn.name() : __doub_exp_syn,
        __blocking_syn.name() : __blocking_syn,
        __multi_decay_syn.name() : __multi_decay_syn,
        __fac_dep_syn.name() : __fac_dep_syn,
        __stdp_syn.name() : __stdp_syn,
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __authorList.name() : __authorList,
        __publication.name() : __publication,
        __neuronDBref.name() : __neuronDBref,
        __modelDBref.name() : __modelDBref,
        __neuroMorphoRef.name() : __neuroMorphoRef
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_cml.addCategoryObject('typeBinding', u'SynapseType', SynapseType)


# Complex type {http://morphml.org/channelml/schema}Deprecated_Ohmic with content type ELEMENT_ONLY
class Deprecated_Ohmic (pyxb.binding.basis.complexTypeDefinition):
    """Signifies an ohmic relation; the current is proportional to the potential difference across the channel. Deprecated! Will be removed in v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_Ohmic')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 639, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}conductance uses Python identifier conductance
    __conductance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'conductance'), 'conductance', '__httpmorphml_orgchannelmlschema_Deprecated_Ohmic_httpmorphml_orgchannelmlschemaconductance', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 644, 12), )

    
    conductance = property(__conductance.value, __conductance.set, None, u'Description of the conductance including maximum conductance density and possible (voltage and/or concentration dependent) gating mechanisms')

    
    # Attribute ion uses Python identifier ion
    __ion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'ion'), 'ion', '__httpmorphml_orgchannelmlschema_Deprecated_Ohmic_ion', pyxb.binding.datatypes.string)
    __ion._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 673, 8)
    __ion._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 673, 8)
    
    ion = property(__ion.value, __ion.set, None, u'The ion which will flow due to the conductance. Note this should be already declared in an Ion element at the beginning of the file.')

    _ElementMap.update({
        __conductance.name() : __conductance
    })
    _AttributeMap.update({
        __ion.name() : __ion
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_Ohmic', Deprecated_Ohmic)


# Complex type {http://morphml.org/channelml/schema}ImplementationPrefs with content type ELEMENT_ONLY
class ImplementationPrefs (pyxb.binding.basis.complexTypeDefinition):
    """These items ideally shouldn't be in a specification which deals with 
            a description of the physiology of the channel. However, some channels won't be properly
            implemented in the scripting mechanism of given simulator using the standard mappings
            unless these factors are taken into account, e.g. if the rate equations change rapidly,
            but the default table size isn't large enough."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ImplementationPrefs')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 683, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}comment uses Python identifier comment
    __comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'comment'), 'comment', '__httpmorphml_orgchannelmlschema_ImplementationPrefs_httpmorphml_orgchannelmlschemacomment', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 692, 12), )

    
    comment = property(__comment.value, __comment.set, None, u'Comment element to give explination for the implementation preferences. Having a dedicated element as opposed to a <-- comment --> allows the comment to be repeated in the script file impl. ')

    
    # Element {http://morphml.org/channelml/schema}table_settings uses Python identifier table_settings
    __table_settings = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'table_settings'), 'table_settings', '__httpmorphml_orgchannelmlschema_ImplementationPrefs_httpmorphml_orgchannelmlschematable_settings', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 697, 12), )

    
    table_settings = property(__table_settings.value, __table_settings.set, None, u'Preferences for the table of values for the rate equations, e.g. used in the TABLE statement in NMODL, or in tabchannel GENESIS objects')

    _ElementMap.update({
        __comment.name() : __comment,
        __table_settings.name() : __table_settings
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'ImplementationPrefs', ImplementationPrefs)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON (pyxb.binding.basis.complexTypeDefinition):
    """Preferences for the table of values for the rate equations, e.g. used in the TABLE statement in NMODL, or in tabchannel GENESIS objects"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 701, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute max_v uses Python identifier max_v
    __max_v = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_v'), 'max_v', '__httpmorphml_orgchannelmlschema_CTD_ANON_max_v', pyxb.binding.datatypes.double, unicode_default=u'70')
    __max_v._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 702, 20)
    __max_v._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 702, 20)
    
    max_v = property(__max_v.value, __max_v.set, None, u'The maximum potential from which to calculate the tables of rate values')

    
    # Attribute min_v uses Python identifier min_v
    __min_v = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'min_v'), 'min_v', '__httpmorphml_orgchannelmlschema_CTD_ANON_min_v', pyxb.binding.datatypes.double, unicode_default=u'-100')
    __min_v._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 707, 20)
    __min_v._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 707, 20)
    
    min_v = property(__min_v.value, __min_v.set, None, u'The minimum potential from which to calculate the tables of rate values')

    
    # Attribute table_divisions uses Python identifier table_divisions
    __table_divisions = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'table_divisions'), 'table_divisions', '__httpmorphml_orgchannelmlschema_CTD_ANON_table_divisions', pyxb.binding.datatypes.positiveInteger, unicode_default=u'200')
    __table_divisions._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 712, 20)
    __table_divisions._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 712, 20)
    
    table_divisions = property(__table_divisions.value, __table_divisions.set, None, u'The number of divisions in the table')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __max_v.name() : __max_v,
        __min_v.name() : __min_v,
        __table_divisions.name() : __table_divisions
    })



# Complex type {http://morphml.org/channelml/schema}RateAdjustments with content type ELEMENT_ONLY
class RateAdjustments (pyxb.binding.basis.complexTypeDefinition):
    """Adjustments necessary to all the rate equations, e.g 
            temperature dependencies, voltage offsets introduced when moving 
            between species, etc. See the XSL mappings for more information on the 
            meaning of these adjustments."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'RateAdjustments')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 722, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}q10_settings uses Python identifier q10_settings
    __q10_settings = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'q10_settings'), 'q10_settings', '__httpmorphml_orgchannelmlschema_RateAdjustments_httpmorphml_orgchannelmlschemaq10_settings', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 731, 12), )

    
    q10_settings = property(__q10_settings.value, __q10_settings.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}offset uses Python identifier offset
    __offset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'offset'), 'offset', '__httpmorphml_orgchannelmlschema_RateAdjustments_httpmorphml_orgchannelmlschemaoffset', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 733, 12), )

    
    offset = property(__offset.value, __offset.set, None, None)

    _ElementMap.update({
        __q10_settings.name() : __q10_settings,
        __offset.name() : __offset
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'RateAdjustments', RateAdjustments)


# Complex type {http://morphml.org/channelml/schema}GatingComplex with content type ELEMENT_ONLY
class GatingComplex (pyxb.binding.basis.complexTypeDefinition):
    """Preferred element for defining a gate since v1.7.3. Definition of a single voltage/concentration dependent gate, 
            with explicit definition of open and closed states and information on the transition rates between them."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'GatingComplex')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 861, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}closed_state uses Python identifier closed_state
    __closed_state = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'closed_state'), 'closed_state', '__httpmorphml_orgchannelmlschema_GatingComplex_httpmorphml_orgchannelmlschemaclosed_state', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 869, 12), )

    
    closed_state = property(__closed_state.value, __closed_state.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}open_state uses Python identifier open_state
    __open_state = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'open_state'), 'open_state', '__httpmorphml_orgchannelmlschema_GatingComplex_httpmorphml_orgchannelmlschemaopen_state', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 870, 12), )

    
    open_state = property(__open_state.value, __open_state.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}initialisation uses Python identifier initialisation
    __initialisation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation'), 'initialisation', '__httpmorphml_orgchannelmlschema_GatingComplex_httpmorphml_orgchannelmlschemainitialisation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 873, 12), )

    
    initialisation = property(__initialisation.value, __initialisation.set, None, u'For debugging/testing only! Use with caution!!')

    
    # Element {http://morphml.org/channelml/schema}transition uses Python identifier transition
    __transition = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition'), 'transition', '__httpmorphml_orgchannelmlschema_GatingComplex_httpmorphml_orgchannelmlschematransition', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 879, 12), )

    
    transition = property(__transition.value, __transition.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}time_course uses Python identifier time_course
    __time_course = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'time_course'), 'time_course', '__httpmorphml_orgchannelmlschema_GatingComplex_httpmorphml_orgchannelmlschematime_course', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 880, 12), )

    
    time_course = property(__time_course.value, __time_course.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}steady_state uses Python identifier steady_state
    __steady_state = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'steady_state'), 'steady_state', '__httpmorphml_orgchannelmlschema_GatingComplex_httpmorphml_orgchannelmlschemasteady_state', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 881, 12), )

    
    steady_state = property(__steady_state.value, __steady_state.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_GatingComplex_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 885, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 885, 8)
    
    name = property(__name.value, __name.set, None, u'Reference for the gating complex, e.g. m, h, n')

    
    # Attribute instances uses Python identifier instances
    __instances = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'instances'), 'instances', '__httpmorphml_orgchannelmlschema_GatingComplex_instances', pyxb.binding.datatypes.nonNegativeInteger, required=True)
    __instances._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 891, 8)
    __instances._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 891, 8)
    
    instances = property(__instances.value, __instances.set, None, u'The number of instances of the gate, i.e. the power to which the gating variable is raised in the expression for the total conductance')

    _ElementMap.update({
        __closed_state.name() : __closed_state,
        __open_state.name() : __open_state,
        __initialisation.name() : __initialisation,
        __transition.name() : __transition,
        __time_course.name() : __time_course,
        __steady_state.name() : __steady_state
    })
    _AttributeMap.update({
        __name.name() : __name,
        __instances.name() : __instances
    })
_Namespace_cml.addCategoryObject('typeBinding', u'GatingComplex', GatingComplex)


# Complex type {http://morphml.org/channelml/schema}ClosedState with content type EMPTY
class ClosedState (pyxb.binding.basis.complexTypeDefinition):
    """Closed state of a gating complex"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ClosedState')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 902, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgchannelmlschema_ClosedState_id', pyxb.binding.datatypes.string, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 907, 8)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 907, 8)
    
    id = property(__id.value, __id.set, None, u'Id to use in transition elements when specifying this as the from or to state of the transition.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })
_Namespace_cml.addCategoryObject('typeBinding', u'ClosedState', ClosedState)


# Complex type {http://morphml.org/channelml/schema}Gate with content type ELEMENT_ONLY
class Gate (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a single voltage/concentration dependent gate"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Gate')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 939, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}state uses Python identifier state
    __state = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'state'), 'state', '__httpmorphml_orgchannelmlschema_Gate_httpmorphml_orgchannelmlschemastate', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 944, 12), )

    
    state = property(__state.value, __state.set, None, u'Internal state of the gate, specifying a name, and possibly a fractional contribution. \n                    HHGate or KSGate elements will specify the rate equations, etc. for the gate, referencing this state name.')

    
    # Attribute power uses Python identifier power
    __power = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'power'), 'power', '__httpmorphml_orgchannelmlschema_Gate_power', pyxb.binding.datatypes.nonNegativeInteger, required=True)
    __power._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 955, 8)
    __power._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 955, 8)
    
    power = property(__power.value, __power.set, None, u'The power to which the gate is raised in the expression for the total conductance')

    _ElementMap.update({
        __state.name() : __state
    })
    _AttributeMap.update({
        __power.name() : __power
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Gate', Gate)


# Complex type {http://morphml.org/channelml/schema}Deprecated_HHGate with content type ELEMENT_ONLY
class Deprecated_HHGate (pyxb.binding.basis.complexTypeDefinition):
    """Gate with Hodgkin Huxley like state transitions"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_HHGate')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 964, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}transition uses Python identifier transition
    __transition = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition'), 'transition', '__httpmorphml_orgchannelmlschema_Deprecated_HHGate_httpmorphml_orgchannelmlschematransition', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 969, 12), )

    
    transition = property(__transition.value, __transition.set, None, None)

    
    # Attribute state uses Python identifier state
    __state = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'state'), 'state', '__httpmorphml_orgchannelmlschema_Deprecated_HHGate_state', pyxb.binding.datatypes.string, required=True)
    __state._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 971, 8)
    __state._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 971, 8)
    
    state = property(__state.value, __state.set, None, None)

    _ElementMap.update({
        __transition.name() : __transition
    })
    _AttributeMap.update({
        __state.name() : __state
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_HHGate', Deprecated_HHGate)


# Complex type {http://morphml.org/channelml/schema}Deprecated_KSGate with content type ELEMENT_ONLY
class Deprecated_KSGate (pyxb.binding.basis.complexTypeDefinition):
    """Gate with kinetic scheme transitions"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_KSGate')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 975, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}state uses Python identifier state
    __state = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'state'), 'state', '__httpmorphml_orgchannelmlschema_Deprecated_KSGate_httpmorphml_orgchannelmlschemastate', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 980, 12), )

    
    state = property(__state.value, __state.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}transition uses Python identifier transition
    __transition = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition'), 'transition', '__httpmorphml_orgchannelmlschema_Deprecated_KSGate_httpmorphml_orgchannelmlschematransition', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 981, 12), )

    
    transition = property(__transition.value, __transition.set, None, None)

    _ElementMap.update({
        __state.name() : __state,
        __transition.name() : __transition
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_KSGate', Deprecated_KSGate)


# Complex type {http://morphml.org/channelml/schema}Deprecated_KSState with content type EMPTY
class Deprecated_KSState (pyxb.binding.basis.complexTypeDefinition):
    """Single kinetic scheme state. Transitions will happen between these states. Deprecated! Will be removed in v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_KSState')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 986, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_Deprecated_KSState_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 990, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 990, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_KSState', Deprecated_KSState)


# Complex type {http://morphml.org/channelml/schema}Deprecated_Transition with content type ELEMENT_ONLY
class Deprecated_Transition (pyxb.binding.basis.complexTypeDefinition):
    """Deprecated since v1.7.3. What causes the gate to open and close. A dependence on potential difference, 
            or a voltage and (ion) concentration dependence"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_Transition')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1118, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}voltage_gate uses Python identifier voltage_gate
    __voltage_gate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'voltage_gate'), 'voltage_gate', '__httpmorphml_orgchannelmlschema_Deprecated_Transition_httpmorphml_orgchannelmlschemavoltage_gate', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1124, 12), )

    
    voltage_gate = property(__voltage_gate.value, __voltage_gate.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}voltage_conc_gate uses Python identifier voltage_conc_gate
    __voltage_conc_gate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'voltage_conc_gate'), 'voltage_conc_gate', '__httpmorphml_orgchannelmlschema_Deprecated_Transition_httpmorphml_orgchannelmlschemavoltage_conc_gate', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1125, 12), )

    
    voltage_conc_gate = property(__voltage_conc_gate.value, __voltage_conc_gate.set, None, None)

    
    # Attribute source uses Python identifier source
    __source = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'source'), 'source', '__httpmorphml_orgchannelmlschema_Deprecated_Transition_source', pyxb.binding.datatypes.string)
    __source._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1127, 8)
    __source._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1127, 8)
    
    source = property(__source.value, __source.set, None, u'Source state of the transition if used in kinetic scheme. Must be used with attribute target. Use this in preference to src!!!')

    
    # Attribute target uses Python identifier target
    __target = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'target'), 'target', '__httpmorphml_orgchannelmlschema_Deprecated_Transition_target', pyxb.binding.datatypes.string)
    __target._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1137, 8)
    __target._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1137, 8)
    
    target = property(__target.value, __target.set, None, u'Target state of the transition if used in kinetic scheme. Must be used with attribute src')

    _ElementMap.update({
        __voltage_gate.name() : __voltage_gate,
        __voltage_conc_gate.name() : __voltage_conc_gate
    })
    _AttributeMap.update({
        __source.name() : __source,
        __target.name() : __target
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_Transition', Deprecated_Transition)


# Complex type {http://morphml.org/channelml/schema}Initialisation with content type EMPTY
class Initialisation (pyxb.binding.basis.complexTypeDefinition):
    """Element added for *testing purposes only*. Used to "incorrectly" initialise a channel when trying 
            to compare it to a mod file implementation (e.g. see Traub et al 2005 channels). Value here will be ignored if option in 
            neuroConstruct "Force correct ChannelML init" is used. Use with caution!!"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Initialisation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1145, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgchannelmlschema_Initialisation_value', pyxb.binding.datatypes.string, required=True)
    __value._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1151, 8)
    __value._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1151, 8)
    
    value_ = property(__value.value, __value.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __value.name() : __value
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Initialisation', Initialisation)


# Complex type {http://morphml.org/channelml/schema}Deprecated_VoltageGate with content type ELEMENT_ONLY
class Deprecated_VoltageGate (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a voltage gate. Normally this will be specified as rate equations for 
            alpha and beta, or for tau and inf. Deprecated! Will be removed in v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_VoltageGate')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1155, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}initialisation uses Python identifier initialisation
    __initialisation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation'), 'initialisation', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageGate_httpmorphml_orgchannelmlschemainitialisation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1163, 12), )

    
    initialisation = property(__initialisation.value, __initialisation.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}tau uses Python identifier tau
    __tau = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'tau'), 'tau', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageGate_httpmorphml_orgchannelmlschematau', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1170, 12), )

    
    tau = property(__tau.value, __tau.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}inf uses Python identifier inf
    __inf = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'inf'), 'inf', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageGate_httpmorphml_orgchannelmlschemainf', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1171, 12), )

    
    inf = property(__inf.value, __inf.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}alpha uses Python identifier alpha
    __alpha = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'alpha'), 'alpha', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageGate_httpmorphml_orgchannelmlschemaalpha', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1280, 12), )

    
    alpha = property(__alpha.value, __alpha.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}beta uses Python identifier beta
    __beta = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'beta'), 'beta', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageGate_httpmorphml_orgchannelmlschemabeta', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1281, 12), )

    
    beta = property(__beta.value, __beta.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}gamma uses Python identifier gamma
    __gamma = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'gamma'), 'gamma', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageGate_httpmorphml_orgchannelmlschemagamma', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1292, 12), )

    
    gamma = property(__gamma.value, __gamma.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}zeta uses Python identifier zeta
    __zeta = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'zeta'), 'zeta', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageGate_httpmorphml_orgchannelmlschemazeta', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12), )

    
    zeta = property(__zeta.value, __zeta.set, None, None)

    _ElementMap.update({
        __initialisation.name() : __initialisation,
        __tau.name() : __tau,
        __inf.name() : __inf,
        __alpha.name() : __alpha,
        __beta.name() : __beta,
        __gamma.name() : __gamma,
        __zeta.name() : __zeta
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_VoltageGate', Deprecated_VoltageGate)


# Complex type {http://morphml.org/channelml/schema}Deprecated_VoltageConcGate with content type ELEMENT_ONLY
class Deprecated_VoltageConcGate (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a mechanics of a gate which depends on voltage and concentration (e.g. Calcium conc dependent K channel). 
            Normally this will be specified as rate equations for alpha and beta (in terms of v and conc), or for tau and inf. Deprecated! Will be removed in v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_VoltageConcGate')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1177, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}initialisation uses Python identifier initialisation
    __initialisation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation'), 'initialisation', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschemainitialisation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1184, 12), )

    
    initialisation = property(__initialisation.value, __initialisation.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}conc_dependence uses Python identifier conc_dependence
    __conc_dependence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_dependence'), 'conc_dependence', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschemaconc_dependence', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1186, 12), )

    
    conc_dependence = property(__conc_dependence.value, __conc_dependence.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}tau uses Python identifier tau
    __tau = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'tau'), 'tau', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschematau', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1193, 12), )

    
    tau = property(__tau.value, __tau.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}inf uses Python identifier inf
    __inf = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'inf'), 'inf', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschemainf', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1194, 12), )

    
    inf = property(__inf.value, __inf.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}gamma uses Python identifier gamma
    __gamma = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'gamma'), 'gamma', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschemagamma', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1292, 12), )

    
    gamma = property(__gamma.value, __gamma.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}zeta uses Python identifier zeta
    __zeta = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'zeta'), 'zeta', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschemazeta', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12), )

    
    zeta = property(__zeta.value, __zeta.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}alpha uses Python identifier alpha
    __alpha = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'alpha'), 'alpha', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschemaalpha', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1303, 12), )

    
    alpha = property(__alpha.value, __alpha.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}beta uses Python identifier beta
    __beta = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'beta'), 'beta', '__httpmorphml_orgchannelmlschema_Deprecated_VoltageConcGate_httpmorphml_orgchannelmlschemabeta', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1304, 12), )

    
    beta = property(__beta.value, __beta.set, None, None)

    _ElementMap.update({
        __initialisation.name() : __initialisation,
        __conc_dependence.name() : __conc_dependence,
        __tau.name() : __tau,
        __inf.name() : __inf,
        __gamma.name() : __gamma,
        __zeta.name() : __zeta,
        __alpha.name() : __alpha,
        __beta.name() : __beta
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_VoltageConcGate', Deprecated_VoltageConcGate)


# Complex type {http://morphml.org/channelml/schema}Deprecated_RateConstantEqnChoice with content type ELEMENT_ONLY
class Deprecated_RateConstantEqnChoice (pyxb.binding.basis.complexTypeDefinition):
    """Choice of the various rate constant expressions allowed"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_RateConstantEqnChoice')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1310, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}parameterised_hh uses Python identifier parameterised_hh
    __parameterised_hh = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameterised_hh'), 'parameterised_hh', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqnChoice_httpmorphml_orgchannelmlschemaparameterised_hh', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1319, 16), )

    
    parameterised_hh = property(__parameterised_hh.value, __parameterised_hh.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}generic_equation_hh uses Python identifier generic_equation_hh
    __generic_equation_hh = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic_equation_hh'), 'generic_equation_hh', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqnChoice_httpmorphml_orgchannelmlschemageneric_equation_hh', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1320, 16), )

    
    generic_equation_hh = property(__generic_equation_hh.value, __generic_equation_hh.set, None, u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0')

    
    # Element {http://morphml.org/channelml/schema}generic uses Python identifier generic
    __generic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic'), 'generic', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqnChoice_httpmorphml_orgchannelmlschemageneric', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1323, 16), )

    
    generic = property(__generic.value, __generic.set, None, u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0')

    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqnChoice_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqnChoice_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqnChoice_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqnChoice_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    _ElementMap.update({
        __parameterised_hh.name() : __parameterised_hh,
        __generic_equation_hh.name() : __generic_equation_hh,
        __generic.name() : __generic,
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_RateConstantEqnChoice', Deprecated_RateConstantEqnChoice)


# Complex type {http://morphml.org/channelml/schema}Deprecated_RateConstVoltConcDep with content type ELEMENT_ONLY
class Deprecated_RateConstVoltConcDep (pyxb.binding.basis.complexTypeDefinition):
    """Rate constant expressions allowed for voltage and conc dependent channels. Note, at this stage no
            Akd like expression for a generic voltage/conc dep experssion. Time will tell if there's an expression common enough 
            across different models to be expressed in such a way"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_RateConstVoltConcDep')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1332, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}generic_equation_hh uses Python identifier generic_equation_hh
    __generic_equation_hh = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic_equation_hh'), 'generic_equation_hh', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstVoltConcDep_httpmorphml_orgchannelmlschemageneric_equation_hh', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1339, 12), )

    
    generic_equation_hh = property(__generic_equation_hh.value, __generic_equation_hh.set, None, u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0')

    
    # Element {http://morphml.org/channelml/schema}generic uses Python identifier generic
    __generic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic'), 'generic', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstVoltConcDep_httpmorphml_orgchannelmlschemageneric', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1342, 12), )

    
    generic = property(__generic.value, __generic.set, None, u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0')

    _ElementMap.update({
        __generic_equation_hh.name() : __generic_equation_hh,
        __generic.name() : __generic
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_RateConstVoltConcDep', Deprecated_RateConstVoltConcDep)


# Complex type {http://morphml.org/channelml/schema}Deprecated_RateConstantEqn with content type ELEMENT_ONLY
class Deprecated_RateConstantEqn (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a rate constant equation."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_RateConstantEqn')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1350, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameter'), 'parameter', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqn_httpmorphml_orgchannelmlschemaparameter', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1355, 12), )

    
    parameter = property(__parameter.value, __parameter.set, None, u'A parameter which is used in the equation')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'type'), 'type', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqn_type', pyxb.binding.datatypes.string, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1361, 8)
    __type._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1361, 8)
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute expr uses Python identifier expr
    __expr = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr'), 'expr', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqn_expr', pyxb.binding.datatypes.string)
    __expr._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1362, 8)
    __expr._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1362, 8)
    
    expr = property(__expr.value, __expr.set, None, None)

    _ElementMap.update({
        __parameter.name() : __parameter
    })
    _AttributeMap.update({
        __type.name() : __type,
        __expr.name() : __expr
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_RateConstantEqn', Deprecated_RateConstantEqn)


# Complex type {http://morphml.org/channelml/schema}Deprecated_GenericEquation with content type EMPTY
class Deprecated_GenericEquation (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a type of rate constant equation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_GenericEquation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1390, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute expr uses Python identifier expr
    __expr = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr'), 'expr', '__httpmorphml_orgchannelmlschema_Deprecated_GenericEquation_expr', pyxb.binding.datatypes.string, required=True)
    __expr._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1395, 8)
    __expr._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1395, 8)
    
    expr = property(__expr.value, __expr.set, None, u"Note: only variable allowed in expression is v (or for an expression for tau or inf,\n                alpha and beta can be used too). Also, liberal use of brackets, e.g. 5.0*(exp (-50*(v +46))) instead \n                of 5.0* exp (-50*(v +46)) is advised, due to GENESIS's handling of exp, abs, etc. ")

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __expr.name() : __expr
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_GenericEquation', Deprecated_GenericEquation)


# Complex type {http://morphml.org/channelml/schema}IonConcentration with content type ELEMENT_ONLY
class IonConcentration (pyxb.binding.basis.complexTypeDefinition):
    """Specification of how an ion concentration alters with time, e.g. calcium dynamics. This may influence other
                   channels (e.g. Ca dependent K channels), and other mechanisms may have a contribution to the concentration of the ion specified here."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'IonConcentration')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1409, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}status uses Python identifier status
    __status = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'status'), 'status', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgchannelmlschemastatus', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1417, 12), )

    
    status = property(__status.value, __status.set, None, u'Status of the ion conc mech specification: stable, in progress, etc.')

    
    # Element {http://morphml.org/channelml/schema}ion_species uses Python identifier ion_species
    __ion_species = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion_species'), 'ion_species', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgchannelmlschemaion_species', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1431, 12), )

    
    ion_species = property(__ion_species.value, __ion_species.set, None, u'Which ion is involved in mechanism.')

    
    # Element {http://morphml.org/channelml/schema}decaying_pool_model uses Python identifier decaying_pool_model
    __decaying_pool_model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'decaying_pool_model'), 'decaying_pool_model', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgchannelmlschemadecaying_pool_model', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1439, 16), )

    
    decaying_pool_model = property(__decaying_pool_model.value, __decaying_pool_model.set, None, u'At present there is only one choice of a model for this process,\n                        more can be added later..')

    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}authorList uses Python identifier authorList
    __authorList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), 'authorList', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemaauthorList', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12), )

    
    authorList = property(__authorList.value, __authorList.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}publication uses Python identifier publication
    __publication = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), 'publication', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemapublication', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12), )

    
    publication = property(__publication.value, __publication.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuronDBref uses Python identifier neuronDBref
    __neuronDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), 'neuronDBref', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemaneuronDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12), )

    
    neuronDBref = property(__neuronDBref.value, __neuronDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}modelDBref uses Python identifier modelDBref
    __modelDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), 'modelDBref', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemamodelDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12), )

    
    modelDBref = property(__modelDBref.value, __modelDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuroMorphoRef uses Python identifier neuroMorphoRef
    __neuroMorphoRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), 'neuroMorphoRef', '__httpmorphml_orgchannelmlschema_IonConcentration_httpmorphml_orgmetadataschemaneuroMorphoRef', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12), )

    
    neuroMorphoRef = property(__neuroMorphoRef.value, __neuroMorphoRef.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_IonConcentration_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1447, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1447, 8)
    
    name = property(__name.value, __name.set, None, u'A unique name for this ion concentration mechanism, as opposed to name of the ion used.')

    _ElementMap.update({
        __status.name() : __status,
        __ion_species.name() : __ion_species,
        __decaying_pool_model.name() : __decaying_pool_model,
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __authorList.name() : __authorList,
        __publication.name() : __publication,
        __neuronDBref.name() : __neuronDBref,
        __modelDBref.name() : __modelDBref,
        __neuroMorphoRef.name() : __neuroMorphoRef
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_cml.addCategoryObject('typeBinding', u'IonConcentration', IonConcentration)


# Complex type {http://morphml.org/channelml/schema}IonSpecies with content type SIMPLE
class IonSpecies (pyxb.binding.basis.complexTypeDefinition):
    """Which ion is involved in an ion_concentration mechanism. Note in v2.0 the attribute form for defining the name will be required."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'IonSpecies')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1457, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_IonSpecies_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1463, 16)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1463, 16)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_cml.addCategoryObject('typeBinding', u'IonSpecies', IonSpecies)


# Complex type {http://morphml.org/channelml/schema}FixedPoolInfo with content type ELEMENT_ONLY
class FixedPoolInfo (pyxb.binding.basis.complexTypeDefinition):
    """(IN PROGRESS, not stable!!!!) In this case the parameter which determines how quickly the internal pool 'fills' is given as a fixed value. Note this is a far from ideal 
        way to express this value, but needed to be included as this was the parameter which was all that was present in a number of models, e.g. Traub et al. 2003 Layer 2/3 cell."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'FixedPoolInfo')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1559, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}phi uses Python identifier phi
    __phi = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'phi'), 'phi', '__httpmorphml_orgchannelmlschema_FixedPoolInfo_httpmorphml_orgchannelmlschemaphi', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1569, 12), )

    
    phi = property(__phi.value, __phi.set, None, None)

    _ElementMap.update({
        __phi.name() : __phi
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'FixedPoolInfo', FixedPoolInfo)


# Complex type {http://morphml.org/channelml/schema}Deprecated_Parameter with content type ELEMENT_ONLY
class Deprecated_Parameter (pyxb.binding.basis.complexTypeDefinition):
    """Generic parameter used in rate equations"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_Parameter')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1576, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_Deprecated_Parameter_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_Deprecated_Parameter_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_Deprecated_Parameter_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_Deprecated_Parameter_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_Deprecated_Parameter_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1584, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1584, 8)
    
    name = property(__name.value, __name.set, None, None)

    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgchannelmlschema_Deprecated_Parameter_value', pyxb.binding.datatypes.double, required=True)
    __value._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1585, 8)
    __value._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1585, 8)
    
    value_ = property(__value.value, __value.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __name.name() : __name,
        __value.name() : __value
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_Parameter', Deprecated_Parameter)


# Complex type {http://morphml.org/metadata/schema}Point with content type EMPTY
class Point (pyxb.binding.basis.complexTypeDefinition):
    """A 3D point with optional diameter. Note: the units for these values
                        will be specified in the file in which the element is used, e.g.
            in a MorphML file with <b>length_units="micrometer"</b> in the morphml element. Assume micrometer
            if no other units are given."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Point')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 30, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute x uses Python identifier x
    __x = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'x'), 'x', '__httpmorphml_orgmetadataschema_Point_x', pyxb.binding.datatypes.double, required=True)
    __x._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 37, 8)
    __x._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 37, 8)
    
    x = property(__x.value, __x.set, None, None)

    
    # Attribute y uses Python identifier y
    __y = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'y'), 'y', '__httpmorphml_orgmetadataschema_Point_y', pyxb.binding.datatypes.double, required=True)
    __y._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 38, 8)
    __y._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 38, 8)
    
    y = property(__y.value, __y.set, None, None)

    
    # Attribute z uses Python identifier z
    __z = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'z'), 'z', '__httpmorphml_orgmetadataschema_Point_z', pyxb.binding.datatypes.double, required=True)
    __z._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 39, 8)
    __z._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 39, 8)
    
    z = property(__z.value, __z.set, None, None)

    
    # Attribute diameter uses Python identifier diameter
    __diameter = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'diameter'), 'diameter', '__httpmorphml_orgmetadataschema_Point_diameter', pyxb.binding.datatypes.double)
    __diameter._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 40, 8)
    __diameter._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 40, 8)
    
    diameter = property(__diameter.value, __diameter.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __x.name() : __x,
        __y.name() : __y,
        __z.name() : __z,
        __diameter.name() : __diameter
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Point', Point)


# Complex type {http://morphml.org/metadata/schema}Point3D with content type EMPTY
class Point3D (pyxb.binding.basis.complexTypeDefinition):
    """A 3D point with no diameter. Note: the units for these values
                        will be specified in the file in which the element is used, e.g.
            in a MorphML file with <b>length_units="micrometer"</b> in the morphml element. Assume micrometer
            if no other units are given."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Point3D')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 44, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute x uses Python identifier x
    __x = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'x'), 'x', '__httpmorphml_orgmetadataschema_Point3D_x', pyxb.binding.datatypes.double, required=True)
    __x._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 51, 8)
    __x._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 51, 8)
    
    x = property(__x.value, __x.set, None, None)

    
    # Attribute y uses Python identifier y
    __y = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'y'), 'y', '__httpmorphml_orgmetadataschema_Point3D_y', pyxb.binding.datatypes.double, required=True)
    __y._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 52, 8)
    __y._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 52, 8)
    
    y = property(__y.value, __y.set, None, None)

    
    # Attribute z uses Python identifier z
    __z = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'z'), 'z', '__httpmorphml_orgmetadataschema_Point3D_z', pyxb.binding.datatypes.double, required=True)
    __z._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 53, 8)
    __z._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 53, 8)
    
    z = property(__z.value, __z.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __x.name() : __x,
        __y.name() : __y,
        __z.name() : __z
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Point3D', Point3D)


# Complex type {http://morphml.org/metadata/schema}Points with content type ELEMENT_ONLY
class Points (pyxb.binding.basis.complexTypeDefinition):
    """A collection of points."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Points')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 57, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}point uses Python identifier point
    __point = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'point'), 'point', '__httpmorphml_orgmetadataschema_Points_httpmorphml_orgmetadataschemapoint', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 62, 12), )

    
    point = property(__point.value, __point.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmetadataschema_Points_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 64, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 64, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __point.name() : __point
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Points', Points)


# Complex type {http://morphml.org/metadata/schema}Sphere with content type ELEMENT_ONLY
class Sphere (pyxb.binding.basis.complexTypeDefinition):
    """A spherical structure such as a cell body or cell."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Sphere')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 69, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}center uses Python identifier center
    __center = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'center'), 'center', '__httpmorphml_orgmetadataschema_Sphere_httpmorphml_orgmetadataschemacenter', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 74, 12), )

    
    center = property(__center.value, __center.set, None, u'Diameter of sphere is obtained from center Point.')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmetadataschema_Sphere_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 80, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 80, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __center.name() : __center
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Sphere', Sphere)


# Complex type {http://morphml.org/metadata/schema}RectangularBox with content type ELEMENT_ONLY
class RectangularBox (pyxb.binding.basis.complexTypeDefinition):
    """A Rectangular Box for locating cells in 3D."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'RectangularBox')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 85, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}corner uses Python identifier corner
    __corner = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'corner'), 'corner', '__httpmorphml_orgmetadataschema_RectangularBox_httpmorphml_orgmetadataschemacorner', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 90, 12), )

    
    corner = property(__corner.value, __corner.set, None, u'Location of vertex with lowest x, y, z coords.')

    
    # Element {http://morphml.org/metadata/schema}size uses Python identifier size
    __size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'size'), 'size', '__httpmorphml_orgmetadataschema_RectangularBox_httpmorphml_orgmetadataschemasize', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 95, 12), )

    
    size = property(__size.value, __size.set, None, u'Size of box. Note if width, height or depth is zero, implies a lower dimension box, e.g. 2D plane.')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmetadataschema_RectangularBox_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 106, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 106, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __corner.name() : __corner,
        __size.name() : __size
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_meta.addCategoryObject('typeBinding', u'RectangularBox', RectangularBox)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_ (pyxb.binding.basis.complexTypeDefinition):
    """Size of box. Note if width, height or depth is zero, implies a lower dimension box, e.g. 2D plane."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 99, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute width uses Python identifier width
    __width = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'width'), 'width', '__httpmorphml_orgmetadataschema_CTD_ANON_width', pyxb.binding.datatypes.double)
    __width._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 100, 24)
    __width._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 100, 24)
    
    width = property(__width.value, __width.set, None, None)

    
    # Attribute height uses Python identifier height
    __height = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'height'), 'height', '__httpmorphml_orgmetadataschema_CTD_ANON_height', pyxb.binding.datatypes.double)
    __height._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 101, 24)
    __height._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 101, 24)
    
    height = property(__height.value, __height.set, None, None)

    
    # Attribute depth uses Python identifier depth
    __depth = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'depth'), 'depth', '__httpmorphml_orgmetadataschema_CTD_ANON_depth', pyxb.binding.datatypes.double)
    __depth._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 102, 24)
    __depth._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 102, 24)
    
    depth = property(__depth.value, __depth.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __width.name() : __width,
        __height.name() : __height,
        __depth.name() : __depth
    })



# Complex type {http://morphml.org/metadata/schema}NonSpatialGrid with content type EMPTY
class NonSpatialGrid (pyxb.binding.basis.complexTypeDefinition):
    """Specifies a grid of up to 3 dimensions, without any explicit 3D location information."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'NonSpatialGrid')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 112, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute x uses Python identifier x
    __x = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'x'), 'x', '__httpmorphml_orgmetadataschema_NonSpatialGrid_x', pyxb.binding.datatypes.positiveInteger, required=True)
    __x._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 117, 8)
    __x._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 117, 8)
    
    x = property(__x.value, __x.set, None, None)

    
    # Attribute y uses Python identifier y
    __y = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'y'), 'y', '__httpmorphml_orgmetadataschema_NonSpatialGrid_y', pyxb.binding.datatypes.positiveInteger)
    __y._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 118, 8)
    __y._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 118, 8)
    
    y = property(__y.value, __y.set, None, None)

    
    # Attribute z uses Python identifier z
    __z = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'z'), 'z', '__httpmorphml_orgmetadataschema_NonSpatialGrid_z', pyxb.binding.datatypes.positiveInteger)
    __z._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 119, 8)
    __z._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 119, 8)
    
    z = property(__z.value, __z.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __x.name() : __x,
        __y.name() : __y,
        __z.name() : __z
    })
_Namespace_meta.addCategoryObject('typeBinding', u'NonSpatialGrid', NonSpatialGrid)


# Complex type {http://morphml.org/metadata/schema}Polyhedron with content type ELEMENT_ONLY
class Polyhedron (pyxb.binding.basis.complexTypeDefinition):
    """A 3d surface to represent the cell body or histological structure."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Polyhedron')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 148, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}polygons uses Python identifier polygons
    __polygons = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'polygons'), 'polygons', '__httpmorphml_orgmetadataschema_Polyhedron_httpmorphml_orgmetadataschemapolygons', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 153, 12), )

    
    polygons = property(__polygons.value, __polygons.set, None, u'Collection of polygons defining the polyhedron.')

    _ElementMap.update({
        __polygons.name() : __polygons
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Polyhedron', Polyhedron)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_2 (pyxb.binding.basis.complexTypeDefinition):
    """Collection of polygons defining the polyhedron."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 157, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}polygon uses Python identifier polygon
    __polygon = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'polygon'), 'polygon', '__httpmorphml_orgmetadataschema_CTD_ANON__httpmorphml_orgmetadataschemapolygon', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 159, 24), )

    
    polygon = property(__polygon.value, __polygon.set, None, None)

    _ElementMap.update({
        __polygon.name() : __polygon
    })
    _AttributeMap.update({
        
    })



# Complex type {http://morphml.org/metadata/schema}Annotation with content type ELEMENT_ONLY
class Annotation (pyxb.binding.basis.complexTypeDefinition):
    """Concise processing directives for downstream applications."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Annotation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 169, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _HasWildcardElement = True
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Annotation', Annotation)


# Complex type {http://morphml.org/metadata/schema}Property with content type ELEMENT_ONLY
class Property (pyxb.binding.basis.complexTypeDefinition):
    """A Tag/Value/Type tuple. Note prior to v1.7.1, tag and value were sub elements. The attribute option is now preferred."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Property')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 243, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}tag uses Python identifier tag
    __tag = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'tag'), 'tag', '__httpmorphml_orgmetadataschema_Property_httpmorphml_orgmetadataschematag', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 249, 12), )

    
    tag = property(__tag.value, __tag.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}value uses Python identifier value_
    __value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'value'), 'value_', '__httpmorphml_orgmetadataschema_Property_httpmorphml_orgmetadataschemavalue', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 250, 12), )

    
    value_ = property(__value.value, __value.set, None, None)

    
    # Attribute tag uses Python identifier tag_
    __tag_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'tag'), 'tag_', '__httpmorphml_orgmetadataschema_Property_tag', pyxb.binding.datatypes.string)
    __tag_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 252, 8)
    __tag_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 252, 8)
    
    tag_ = property(__tag_.value, __tag_.set, None, None)

    
    # Attribute value uses Python identifier value_2
    __value_2 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_2', '__httpmorphml_orgmetadataschema_Property_value', pyxb.binding.datatypes.string)
    __value_2._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 253, 8)
    __value_2._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 253, 8)
    
    value_2 = property(__value_2.value, __value_2.set, None, None)

    _ElementMap.update({
        __tag.name() : __tag,
        __value.name() : __value
    })
    _AttributeMap.update({
        __tag_.name() : __tag_,
        __value_2.name() : __value_2
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Property', Property)


# Complex type {http://morphml.org/metadata/schema}Properties with content type ELEMENT_ONLY
class Properties (pyxb.binding.basis.complexTypeDefinition):
    """A collection of Properties"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Properties')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 258, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}property uses Python identifier property_
    __property = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'property'), 'property_', '__httpmorphml_orgmetadataschema_Properties_httpmorphml_orgmetadataschemaproperty', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 263, 12), )

    
    property_ = property(__property.value, __property.set, None, None)

    _ElementMap.update({
        __property.name() : __property
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Properties', Properties)


# Complex type {http://morphml.org/metadata/schema}PropertyDetail with content type ELEMENT_ONLY
class PropertyDetail (pyxb.binding.basis.complexTypeDefinition):
    """Metadata for each Property."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'PropertyDetail')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 269, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'description'), 'description', '__httpmorphml_orgmetadataschema_PropertyDetail_httpmorphml_orgmetadataschemadescription', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 274, 12), )

    
    description = property(__description.value, __description.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'type'), 'type', '__httpmorphml_orgmetadataschema_PropertyDetail_httpmorphml_orgmetadataschematype', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 275, 12), )

    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute property uses Python identifier property_
    __property = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'property'), 'property_', '__httpmorphml_orgmetadataschema_PropertyDetail_property', pyxb.binding.datatypes.string)
    __property._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 277, 8)
    __property._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 277, 8)
    
    property_ = property(__property.value, __property.set, None, None)

    _ElementMap.update({
        __description.name() : __description,
        __type.name() : __type
    })
    _AttributeMap.update({
        __property.name() : __property
    })
_Namespace_meta.addCategoryObject('typeBinding', u'PropertyDetail', PropertyDetail)


# Complex type {http://morphml.org/metadata/schema}GroupDetail with content type ELEMENT_ONLY
class GroupDetail (pyxb.binding.basis.complexTypeDefinition):
    """Metadata for each Group."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'GroupDetail')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 282, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}description uses Python identifier description
    __description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'description'), 'description', '__httpmorphml_orgmetadataschema_GroupDetail_httpmorphml_orgmetadataschemadescription', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 287, 12), )

    
    description = property(__description.value, __description.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmetadataschema_GroupDetail_httpmorphml_orgmetadataschemaproperties', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 288, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Attribute group uses Python identifier group
    __group = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'group'), 'group', '__httpmorphml_orgmetadataschema_GroupDetail_group', pyxb.binding.datatypes.string)
    __group._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 290, 8)
    __group._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 290, 8)
    
    group = property(__group.value, __group.set, None, None)

    _ElementMap.update({
        __description.name() : __description,
        __properties.name() : __properties
    })
    _AttributeMap.update({
        __group.name() : __group
    })
_Namespace_meta.addCategoryObject('typeBinding', u'GroupDetail', GroupDetail)


# Complex type {http://morphml.org/metadata/schema}NeuroMorphoRef with content type ELEMENT_ONLY
class NeuroMorphoRef (pyxb.binding.basis.complexTypeDefinition):
    """A reference to an entity in NeuroMorpho.org 
                            Note: This element will possibly change when a new set of schema 
                            files is adopted for adding references, authors, citations, etc. See 
                            mailing lists for latest status"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'NeuroMorphoRef')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 406, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}morphologyRef uses Python identifier morphologyRef
    __morphologyRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'morphologyRef'), 'morphologyRef', '__httpmorphml_orgmetadataschema_NeuroMorphoRef_httpmorphml_orgmetadataschemamorphologyRef', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 414, 12), )

    
    morphologyRef = property(__morphologyRef.value, __morphologyRef.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri'), 'uri', '__httpmorphml_orgmetadataschema_NeuroMorphoRef_httpmorphml_orgmetadataschemauri', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 415, 12), )

    
    uri = property(__uri.value, __uri.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}comment uses Python identifier comment
    __comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), 'comment', '__httpmorphml_orgmetadataschema_NeuroMorphoRef_httpmorphml_orgmetadataschemacomment', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 416, 12), )

    
    comment = property(__comment.value, __comment.set, None, u'Comment on how this morphology relates to the current model')

    _ElementMap.update({
        __morphologyRef.name() : __morphologyRef,
        __uri.name() : __uri,
        __comment.name() : __comment
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'NeuroMorphoRef', NeuroMorphoRef)


# Complex type {http://morphml.org/metadata/schema}NeuronDBReference with content type ELEMENT_ONLY
class NeuronDBReference (pyxb.binding.basis.complexTypeDefinition):
    """A reference to an entity in NeuronDB 
                            Note: This element will possibly change when a new set of schema 
                            files is adopted for adding references, authors, citations, etc. See 
                mailing lists for latest status"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'NeuronDBReference')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 425, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}modelName uses Python identifier modelName
    __modelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelName'), 'modelName', '__httpmorphml_orgmetadataschema_NeuronDBReference_httpmorphml_orgmetadataschemamodelName', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 433, 12), )

    
    modelName = property(__modelName.value, __modelName.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri'), 'uri', '__httpmorphml_orgmetadataschema_NeuronDBReference_httpmorphml_orgmetadataschemauri', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 434, 12), )

    
    uri = property(__uri.value, __uri.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}comment uses Python identifier comment
    __comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), 'comment', '__httpmorphml_orgmetadataschema_NeuronDBReference_httpmorphml_orgmetadataschemacomment', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 435, 12), )

    
    comment = property(__comment.value, __comment.set, None, u'Comment on how this neuron relates to the current model')

    _ElementMap.update({
        __modelName.name() : __modelName,
        __uri.name() : __uri,
        __comment.name() : __comment
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'NeuronDBReference', NeuronDBReference)


# Complex type {http://morphml.org/metadata/schema}ModelDBReference with content type ELEMENT_ONLY
class ModelDBReference (pyxb.binding.basis.complexTypeDefinition):
    """A reference to an entity in ModelDB 
                            Note: This element will possibly change when a new set of schema 
                            files is adopted for adding references, authors, citations, etc. See 
                mailing lists for latest status"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'ModelDBReference')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 444, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}modelName uses Python identifier modelName
    __modelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelName'), 'modelName', '__httpmorphml_orgmetadataschema_ModelDBReference_httpmorphml_orgmetadataschemamodelName', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 452, 12), )

    
    modelName = property(__modelName.value, __modelName.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri'), 'uri', '__httpmorphml_orgmetadataschema_ModelDBReference_httpmorphml_orgmetadataschemauri', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 453, 12), )

    
    uri = property(__uri.value, __uri.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}comment uses Python identifier comment
    __comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), 'comment', '__httpmorphml_orgmetadataschema_ModelDBReference_httpmorphml_orgmetadataschemacomment', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 454, 12), )

    
    comment = property(__comment.value, __comment.set, None, u'Comment on how this model relates to the current model in NeuroML')

    _ElementMap.update({
        __modelName.name() : __modelName,
        __uri.name() : __uri,
        __comment.name() : __comment
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'ModelDBReference', ModelDBReference)


# Complex type {http://morphml.org/metadata/schema}Publication with content type ELEMENT_ONLY
class Publication (pyxb.binding.basis.complexTypeDefinition):
    """A reference to a publication 
                            Note: This element will possibly change when a new set of schema 
                            files is adopted for adding references, authors, citations, etc. See 
                mailing lists for latest status"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Publication')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 464, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}fullTitle uses Python identifier fullTitle
    __fullTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'fullTitle'), 'fullTitle', '__httpmorphml_orgmetadataschema_Publication_httpmorphml_orgmetadataschemafullTitle', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 472, 12), )

    
    fullTitle = property(__fullTitle.value, __fullTitle.set, None, u'A reasonably complete reference to the paper, etc. including journal, authors, issue, year. \n                    Mainly for quick recognition of the paper. The PubMed ref should contain the unique ID.')

    
    # Element {http://morphml.org/metadata/schema}pubmedRef uses Python identifier pubmedRef
    __pubmedRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'pubmedRef'), 'pubmedRef', '__httpmorphml_orgmetadataschema_Publication_httpmorphml_orgmetadataschemapubmedRef', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 478, 12), )

    
    pubmedRef = property(__pubmedRef.value, __pubmedRef.set, None, u'URL of paper in PubMed (starting with http://www.ncbi.nlm.nih.gov)')

    
    # Element {http://morphml.org/metadata/schema}comment uses Python identifier comment
    __comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), 'comment', '__httpmorphml_orgmetadataschema_Publication_httpmorphml_orgmetadataschemacomment', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 483, 12), )

    
    comment = property(__comment.value, __comment.set, None, u'Comment on how this publication relates to the current model')

    _ElementMap.update({
        __fullTitle.name() : __fullTitle,
        __pubmedRef.name() : __pubmedRef,
        __comment.name() : __comment
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Publication', Publication)


# Complex type {http://morphml.org/metadata/schema}Authors with content type ELEMENT_ONLY
class Authors (pyxb.binding.basis.complexTypeDefinition):
    """A reference to an author 
                            Note: This element will possibly change when a new set of schema 
                            files is adopted for adding references, authors, citations, etc. See 
                mailing lists for latest status"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Authors')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 491, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}modelAuthor uses Python identifier modelAuthor
    __modelAuthor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelAuthor'), 'modelAuthor', '__httpmorphml_orgmetadataschema_Authors_httpmorphml_orgmetadataschemamodelAuthor', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 499, 12), )

    
    modelAuthor = property(__modelAuthor.value, __modelAuthor.set, None, u'Author of the original model')

    
    # Element {http://morphml.org/metadata/schema}modelTranslator uses Python identifier modelTranslator
    __modelTranslator = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelTranslator'), 'modelTranslator', '__httpmorphml_orgmetadataschema_Authors_httpmorphml_orgmetadataschemamodelTranslator', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 504, 12), )

    
    modelTranslator = property(__modelTranslator.value, __modelTranslator.set, None, u'Person who translated the model to NeuroML')

    _ElementMap.update({
        __modelAuthor.name() : __modelAuthor,
        __modelTranslator.name() : __modelTranslator
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Authors', Authors)


# Complex type {http://morphml.org/metadata/schema}Person with content type ELEMENT_ONLY
class Person (pyxb.binding.basis.complexTypeDefinition):
    """A generic reference to a person, for authorship, etc"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Person')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 513, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'name'), 'name', '__httpmorphml_orgmetadataschema_Person_httpmorphml_orgmetadataschemaname', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 518, 12), )

    
    name = property(__name.value, __name.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}institution uses Python identifier institution
    __institution = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'institution'), 'institution', '__httpmorphml_orgmetadataschema_Person_httpmorphml_orgmetadataschemainstitution', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 520, 12), )

    
    institution = property(__institution.value, __institution.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}email uses Python identifier email
    __email = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'email'), 'email', '__httpmorphml_orgmetadataschema_Person_httpmorphml_orgmetadataschemaemail', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 522, 12), )

    
    email = property(__email.value, __email.set, None, u"Useful to have. Note: something like '- at -' replacing the @ might be wise, in case a HTML version of the file goes online.")

    
    # Element {http://morphml.org/metadata/schema}comment uses Python identifier comment
    __comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), 'comment', '__httpmorphml_orgmetadataschema_Person_httpmorphml_orgmetadataschemacomment', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 527, 12), )

    
    comment = property(__comment.value, __comment.set, None, u'Optional comment on their specific contribution')

    _ElementMap.update({
        __name.name() : __name,
        __institution.name() : __institution,
        __email.name() : __email,
        __comment.name() : __comment
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Person', Person)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_3 (pyxb.binding.basis.complexTypeDefinition):
    """Collection of all extracellular histological features."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 43, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_CTD_ANON_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_CTD_ANON_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_CTD_ANON_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_CTD_ANON_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}feature uses Python identifier feature
    __feature = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'feature'), 'feature', '__httpmorphml_orgmorphmlschema_CTD_ANON_httpmorphml_orgmorphmlschemafeature', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 46, 24), )

    
    feature = property(__feature.value, __feature.set, None, u'A single feature of note.')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __feature.name() : __feature
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_4 (pyxb.binding.basis.complexTypeDefinition):
    """Collection of all PropertyDetails for this instance."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 67, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/morphml/schema}propertyDetail uses Python identifier propertyDetail
    __propertyDetail = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'propertyDetail'), 'propertyDetail', '__httpmorphml_orgmorphmlschema_CTD_ANON__httpmorphml_orgmorphmlschemapropertyDetail', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 69, 24), )

    
    propertyDetail = property(__propertyDetail.value, __propertyDetail.set, None, None)

    _ElementMap.update({
        __propertyDetail.name() : __propertyDetail
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_5 (pyxb.binding.basis.complexTypeDefinition):
    """Collection of all GroupDetails for this instance."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 82, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/morphml/schema}groupDetail uses Python identifier groupDetail
    __groupDetail = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'groupDetail'), 'groupDetail', '__httpmorphml_orgmorphmlschema_CTD_ANON_2_httpmorphml_orgmorphmlschemagroupDetail', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 84, 24), )

    
    groupDetail = property(__groupDetail.value, __groupDetail.set, None, None)

    _ElementMap.update({
        __groupDetail.name() : __groupDetail
    })
    _AttributeMap.update({
        
    })



# Complex type {http://morphml.org/morphml/schema}Cells with content type ELEMENT_ONLY
class Cells (pyxb.binding.basis.complexTypeDefinition):
    """Collection of all cells."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Cells')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 121, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/morphml/schema}cell uses Python identifier cell
    __cell = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'cell'), 'cell', '__httpmorphml_orgmorphmlschema_Cells_httpmorphml_orgmorphmlschemacell', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 126, 16), )

    
    cell = property(__cell.value, __cell.set, None, u'A single cell.')

    _ElementMap.update({
        __cell.name() : __cell
    })
    _AttributeMap.update({
        
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Cells', Cells)


# Complex type {http://morphml.org/morphml/schema}Cell with content type ELEMENT_ONLY
class Cell (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a cell."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Cell')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 136, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}authorList uses Python identifier authorList
    __authorList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), 'authorList', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemaauthorList', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12), )

    
    authorList = property(__authorList.value, __authorList.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}publication uses Python identifier publication
    __publication = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), 'publication', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemapublication', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12), )

    
    publication = property(__publication.value, __publication.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuronDBref uses Python identifier neuronDBref
    __neuronDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), 'neuronDBref', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemaneuronDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12), )

    
    neuronDBref = property(__neuronDBref.value, __neuronDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}modelDBref uses Python identifier modelDBref
    __modelDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), 'modelDBref', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemamodelDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12), )

    
    modelDBref = property(__modelDBref.value, __modelDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuroMorphoRef uses Python identifier neuroMorphoRef
    __neuroMorphoRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), 'neuroMorphoRef', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmetadataschemaneuroMorphoRef', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12), )

    
    neuroMorphoRef = property(__neuroMorphoRef.value, __neuroMorphoRef.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}status uses Python identifier status
    __status = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'status'), 'status', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmorphmlschemastatus', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 142, 12), )

    
    status = property(__status.value, __status.set, None, u'Status of the cell model: stable, in progress, etc.\n                    Further test comments explaining the current status should be added.')

    
    # Element {http://morphml.org/morphml/schema}segments uses Python identifier segments
    __segments = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'segments'), 'segments', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmorphmlschemasegments', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 154, 12), )

    
    segments = property(__segments.value, __segments.set, None, u'A segment defines the smallest unit within a possibly branching structure, such as a dendrite or axon. The first segment should represent the soma, if needed for downstream applications.')

    
    # Element {http://morphml.org/morphml/schema}cables uses Python identifier cables
    __cables = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'cables'), 'cables', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmorphmlschemacables', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 189, 24), )

    
    cables = property(__cables.value, __cables.set, None, u'The collection of cables. Each cable will be associated with a number of connected segments.')

    
    # Element {http://morphml.org/morphml/schema}cellBody uses Python identifier cellBody
    __cellBody = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'cellBody'), 'cellBody', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmorphmlschemacellBody', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 224, 12), )

    
    cellBody = property(__cellBody.value, __cellBody.set, None, u'Used for anatomical representation of the soma. Use a Segment with equivalent properties to retain connectivity of branches to the soma for downstream applications (e.g. neuronal simulators).')

    
    # Element {http://morphml.org/morphml/schema}spines uses Python identifier spines
    __spines = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'spines'), 'spines', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmorphmlschemaspines', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 241, 12), )

    
    spines = property(__spines.value, __spines.set, None, u'The collection of spines.')

    
    # Element {http://morphml.org/morphml/schema}freePoints uses Python identifier freePoints
    __freePoints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'freePoints'), 'freePoints', '__httpmorphml_orgmorphmlschema_Cell_httpmorphml_orgmorphmlschemafreePoints', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 260, 12), )

    
    freePoints = property(__freePoints.value, __freePoints.set, None, u'The collection of varicosities or synaptic connections.')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmorphmlschema_Cell_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 268, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 268, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __authorList.name() : __authorList,
        __publication.name() : __publication,
        __neuronDBref.name() : __neuronDBref,
        __modelDBref.name() : __modelDBref,
        __neuroMorphoRef.name() : __neuroMorphoRef,
        __status.name() : __status,
        __segments.name() : __segments,
        __cables.name() : __cables,
        __cellBody.name() : __cellBody,
        __spines.name() : __spines,
        __freePoints.name() : __freePoints
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Cell', Cell)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_6 (pyxb.binding.basis.complexTypeDefinition):
    """A segment defines the smallest unit within a possibly branching structure, such as a dendrite or axon. The first segment should represent the soma, if needed for downstream applications."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 160, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_CTD_ANON_3_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_CTD_ANON_3_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_CTD_ANON_3_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_CTD_ANON_3_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}segment uses Python identifier segment
    __segment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'segment'), 'segment', '__httpmorphml_orgmorphmlschema_CTD_ANON_3_httpmorphml_orgmorphmlschemasegment', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 163, 24), )

    
    segment = property(__segment.value, __segment.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __segment.name() : __segment
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_7 (pyxb.binding.basis.complexTypeDefinition):
    """The collection of cables. Each cable will be associated with a number of connected segments."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 194, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_CTD_ANON_4_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_CTD_ANON_4_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_CTD_ANON_4_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_CTD_ANON_4_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}cable uses Python identifier cable
    __cable = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'cable'), 'cable', '__httpmorphml_orgmorphmlschema_CTD_ANON_4_httpmorphml_orgmorphmlschemacable', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 197, 24), )

    
    cable = property(__cable.value, __cable.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}cablegroup uses Python identifier cablegroup
    __cablegroup = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'cablegroup'), 'cablegroup', '__httpmorphml_orgmorphmlschema_CTD_ANON_4_httpmorphml_orgmorphmlschemacablegroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 198, 24), )

    
    cablegroup = property(__cablegroup.value, __cablegroup.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __cable.name() : __cable,
        __cablegroup.name() : __cablegroup
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_8 (pyxb.binding.basis.complexTypeDefinition):
    """Used for anatomical representation of the soma. Use a Segment with equivalent properties to retain connectivity of branches to the soma for downstream applications (e.g. neuronal simulators)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 228, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_CTD_ANON_5_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_CTD_ANON_5_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_CTD_ANON_5_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_CTD_ANON_5_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}polygon uses Python identifier polygon
    __polygon = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'polygon'), 'polygon', '__httpmorphml_orgmorphmlschema_CTD_ANON_5_httpmorphml_orgmorphmlschemapolygon', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 232, 28), )

    
    polygon = property(__polygon.value, __polygon.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}polyhedron uses Python identifier polyhedron
    __polyhedron = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'polyhedron'), 'polyhedron', '__httpmorphml_orgmorphmlschema_CTD_ANON_5_httpmorphml_orgmorphmlschemapolyhedron', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 233, 28), )

    
    polyhedron = property(__polyhedron.value, __polyhedron.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}sphere uses Python identifier sphere
    __sphere = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'sphere'), 'sphere', '__httpmorphml_orgmorphmlschema_CTD_ANON_5_httpmorphml_orgmorphmlschemasphere', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 234, 28), )

    
    sphere = property(__sphere.value, __sphere.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __polygon.name() : __polygon,
        __polyhedron.name() : __polyhedron,
        __sphere.name() : __sphere
    })
    _AttributeMap.update({
        
    })



# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_9 (pyxb.binding.basis.complexTypeDefinition):
    """The collection of spines."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 245, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_CTD_ANON_6_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_CTD_ANON_6_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_CTD_ANON_6_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_CTD_ANON_6_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}spine uses Python identifier spine
    __spine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'spine'), 'spine', '__httpmorphml_orgmorphmlschema_CTD_ANON_6_httpmorphml_orgmorphmlschemaspine', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 248, 24), )

    
    spine = property(__spine.value, __spine.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __spine.name() : __spine
    })
    _AttributeMap.update({
        
    })



# Complex type {http://morphml.org/morphml/schema}CableGroup with content type ELEMENT_ONLY
class CableGroup (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a cable group. Cable groups can also be specified by adding an element group to the cable element"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'CableGroup')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 370, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/morphml/schema}cable uses Python identifier cable
    __cable = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'cable'), 'cable', '__httpmorphml_orgmorphmlschema_CableGroup_httpmorphml_orgmorphmlschemacable', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 375, 12), )

    
    cable = property(__cable.value, __cable.set, None, u'The id of a single cable in the group')

    
    # Element {http://morphml.org/morphml/schema}inhomogeneous_param uses Python identifier inhomogeneous_param
    __inhomogeneous_param = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'inhomogeneous_param'), 'inhomogeneous_param', '__httpmorphml_orgmorphmlschema_CableGroup_httpmorphml_orgmorphmlschemainhomogeneous_param', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 386, 12), )

    
    inhomogeneous_param = property(__inhomogeneous_param.value, __inhomogeneous_param.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmorphmlschema_CableGroup_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 388, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 388, 8)
    
    name = property(__name.value, __name.set, None, u'Name of the cable group')

    _ElementMap.update({
        __cable.name() : __cable,
        __inhomogeneous_param.name() : __inhomogeneous_param
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_mml.addCategoryObject('typeBinding', u'CableGroup', CableGroup)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_10 (pyxb.binding.basis.complexTypeDefinition):
    """The id of a single cable in the group"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 380, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgmorphmlschema_CTD_ANON_7_id', pyxb.binding.datatypes.nonNegativeInteger, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 381, 20)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 381, 20)
    
    id = property(__id.value, __id.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id
    })



# Complex type {http://morphml.org/morphml/schema}InhomogeneousParam with content type ELEMENT_ONLY
class InhomogeneousParam (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a parameter which varies along a cable group."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'InhomogeneousParam')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 409, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/morphml/schema}metric uses Python identifier metric
    __metric = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'metric'), 'metric', '__httpmorphml_orgmorphmlschema_InhomogeneousParam_httpmorphml_orgmorphmlschemametric', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 414, 12), )

    
    metric = property(__metric.value, __metric.set, None, u'The metric used to determine the variable')

    
    # Element {http://morphml.org/morphml/schema}proximal uses Python identifier proximal
    __proximal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal'), 'proximal', '__httpmorphml_orgmorphmlschema_InhomogeneousParam_httpmorphml_orgmorphmlschemaproximal', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 420, 12), )

    
    proximal = property(__proximal.value, __proximal.set, None, u'Information on the value of the variable at the proximal point. If this element is absent,\n                    the value of the variable is determined simply from the metric, e.g. absolute path length')

    
    # Element {http://morphml.org/morphml/schema}distal uses Python identifier distal
    __distal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal'), 'distal', '__httpmorphml_orgmorphmlschema_InhomogeneousParam_httpmorphml_orgmorphmlschemadistal', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 434, 12), )

    
    distal = property(__distal.value, __distal.set, None, u'Information on the value of the variable at the distal point. If this element is absent, the\n                    value of the variable is determined simply from the metric, e.g. path length')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmorphmlschema_InhomogeneousParam_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 449, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 449, 8)
    
    name = property(__name.value, __name.set, None, u'Name of the inhomogeneous parameter specification')

    
    # Attribute variable uses Python identifier variable
    __variable = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'variable'), 'variable', '__httpmorphml_orgmorphmlschema_InhomogeneousParam_variable', pyxb.binding.datatypes.string, required=True)
    __variable._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 454, 8)
    __variable._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 454, 8)
    
    variable = property(__variable.value, __variable.set, None, u'Name of the variable which will change over the length')

    _ElementMap.update({
        __metric.name() : __metric,
        __proximal.name() : __proximal,
        __distal.name() : __distal
    })
    _AttributeMap.update({
        __name.name() : __name,
        __variable.name() : __variable
    })
_Namespace_mml.addCategoryObject('typeBinding', u'InhomogeneousParam', InhomogeneousParam)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_11 (pyxb.binding.basis.complexTypeDefinition):
    """Information on the value of the variable at the proximal point. If this element is absent,
                    the value of the variable is determined simply from the metric, e.g. absolute path length"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 425, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute translationStart uses Python identifier translationStart
    __translationStart = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'translationStart'), 'translationStart', '__httpmorphml_orgmorphmlschema_CTD_ANON_8_translationStart', pyxb.binding.datatypes.double, required=True)
    __translationStart._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 426, 20)
    __translationStart._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 426, 20)
    
    translationStart = property(__translationStart.value, __translationStart.set, None, u'The variable is translated to this value at the proximal point')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __translationStart.name() : __translationStart
    })



# Complex type [anonymous] with content type EMPTY
class CTD_ANON_12 (pyxb.binding.basis.complexTypeDefinition):
    """Information on the value of the variable at the distal point. If this element is absent, the
                    value of the variable is determined simply from the metric, e.g. path length"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 439, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute normalizationEnd uses Python identifier normalizationEnd
    __normalizationEnd = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'normalizationEnd'), 'normalizationEnd', '__httpmorphml_orgmorphmlschema_CTD_ANON_9_normalizationEnd', pyxb.binding.datatypes.double, required=True)
    __normalizationEnd._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 440, 20)
    __normalizationEnd._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 440, 20)
    
    normalizationEnd = property(__normalizationEnd.value, __normalizationEnd.set, None, u'The variable is normalised so that it has this value at the distal point')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __normalizationEnd.name() : __normalizationEnd
    })



# Complex type {http://morphml.org/morphml/schema}Feature with content type ELEMENT_ONLY
class Feature (pyxb.binding.basis.complexTypeDefinition):
    """The group of things allowed in features."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Feature')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 524, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}path uses Python identifier path
    __path = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'path'), 'path', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmorphmlschemapath', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 530, 12), )

    
    path = property(__path.value, __path.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}freePoints uses Python identifier freePoints
    __freePoints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'freePoints'), 'freePoints', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmorphmlschemafreePoints', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 531, 12), )

    
    freePoints = property(__freePoints.value, __freePoints.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}manifold uses Python identifier manifold
    __manifold = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'manifold'), 'manifold', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmorphmlschemamanifold', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 532, 12), )

    
    manifold = property(__manifold.value, __manifold.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}polygon uses Python identifier polygon
    __polygon = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'polygon'), 'polygon', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmorphmlschemapolygon', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 533, 12), )

    
    polygon = property(__polygon.value, __polygon.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}polyhedron uses Python identifier polyhedron
    __polyhedron = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'polyhedron'), 'polyhedron', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmorphmlschemapolyhedron', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 534, 12), )

    
    polyhedron = property(__polyhedron.value, __polyhedron.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}sphere uses Python identifier sphere
    __sphere = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'sphere'), 'sphere', '__httpmorphml_orgmorphmlschema_Feature_httpmorphml_orgmorphmlschemasphere', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 535, 12), )

    
    sphere = property(__sphere.value, __sphere.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmorphmlschema_Feature_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 537, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 537, 8)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __path.name() : __path,
        __freePoints.name() : __freePoints,
        __manifold.name() : __manifold,
        __polygon.name() : __polygon,
        __polyhedron.name() : __polyhedron,
        __sphere.name() : __sphere
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Feature', Feature)


# Complex type {http://morphml.org/networkml/schema}Populations with content type ELEMENT_ONLY
class Populations (pyxb.binding.basis.complexTypeDefinition):
    """The list of cell populations"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Populations')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 118, 9)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Populations_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Populations_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Populations_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Populations_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}population uses Python identifier population
    __population = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'population'), 'population', '__httpmorphml_orgnetworkmlschema_Populations_httpmorphml_orgnetworkmlschemapopulation', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 124, 16), )

    
    population = property(__population.value, __population.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __population.name() : __population
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'Populations', Populations)


# Complex type {http://morphml.org/networkml/schema}Input with content type ELEMENT_ONLY
class Input (pyxb.binding.basis.complexTypeDefinition):
    """Description of a single electrical input to a number of cells"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Input')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 166, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Input_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Input_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Input_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Input_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}pulse_input uses Python identifier pulse_input
    __pulse_input = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'pulse_input'), 'pulse_input', '__httpmorphml_orgnetworkmlschema_Input_httpmorphml_orgnetworkmlschemapulse_input', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 178, 20), )

    
    pulse_input = property(__pulse_input.value, __pulse_input.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}random_stim uses Python identifier random_stim
    __random_stim = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'random_stim'), 'random_stim', '__httpmorphml_orgnetworkmlschema_Input_httpmorphml_orgnetworkmlschemarandom_stim', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 179, 20), )

    
    random_stim = property(__random_stim.value, __random_stim.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}target uses Python identifier target
    __target = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'target'), 'target', '__httpmorphml_orgnetworkmlschema_Input_httpmorphml_orgnetworkmlschematarget', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 182, 18), )

    
    target = property(__target.value, __target.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgnetworkmlschema_Input_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 187, 12)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 187, 12)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __pulse_input.name() : __pulse_input,
        __random_stim.name() : __random_stim,
        __target.name() : __target
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_Namespace_net.addCategoryObject('typeBinding', u'Input', Input)


# Complex type {http://morphml.org/networkml/schema}InputTarget with content type ELEMENT_ONLY
class InputTarget (pyxb.binding.basis.complexTypeDefinition):
    """Specifies the cell group and which cells/segments to apply the stimulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'InputTarget')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 227, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_InputTarget_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_InputTarget_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_InputTarget_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_InputTarget_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}sites uses Python identifier sites
    __sites = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'sites'), 'sites', '__httpmorphml_orgnetworkmlschema_InputTarget_httpmorphml_orgnetworkmlschemasites', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 241, 20), )

    
    sites = property(__sites.value, __sites.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}site_pattern uses Python identifier site_pattern
    __site_pattern = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'site_pattern'), 'site_pattern', '__httpmorphml_orgnetworkmlschema_InputTarget_httpmorphml_orgnetworkmlschemasite_pattern', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 242, 20), )

    
    site_pattern = property(__site_pattern.value, __site_pattern.set, None, None)

    
    # Attribute cell_group uses Python identifier cell_group
    __cell_group = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cell_group'), 'cell_group', '__httpmorphml_orgnetworkmlschema_InputTarget_cell_group', pyxb.binding.datatypes.string)
    __cell_group._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 247, 11)
    __cell_group._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 247, 11)
    
    cell_group = property(__cell_group.value, __cell_group.set, None, u'The cell group to which to apply the stimulation. Note for v2.0 population is the preferred name of this attribute (not cell_group).')

    
    # Attribute population uses Python identifier population
    __population = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'population'), 'population', '__httpmorphml_orgnetworkmlschema_InputTarget_population', pyxb.binding.datatypes.string)
    __population._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 255, 11)
    __population._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 255, 11)
    
    population = property(__population.value, __population.set, None, u'The cell group to which to apply the stimulation. Note for v2.0 population is the preferred name of this attribute (not cell_group).')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __sites.name() : __sites,
        __site_pattern.name() : __site_pattern
    })
    _AttributeMap.update({
        __cell_group.name() : __cell_group,
        __population.name() : __population
    })
_Namespace_net.addCategoryObject('typeBinding', u'InputTarget', InputTarget)


# Complex type {http://morphml.org/networkml/schema}InputSitePattern with content type ELEMENT_ONLY
class InputSitePattern (pyxb.binding.basis.complexTypeDefinition):
    """Information on the number of cells on which to apply inputs. 
                Currently only two, but could be expanded to include other scenarios, e.g. all cells in 3d region."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'InputSitePattern')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 265, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/networkml/schema}all_cells uses Python identifier all_cells
    __all_cells = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'all_cells'), 'all_cells', '__httpmorphml_orgnetworkmlschema_InputSitePattern_httpmorphml_orgnetworkmlschemaall_cells', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 273, 16), )

    
    all_cells = property(__all_cells.value, __all_cells.set, None, u'Apply input on all cells in group')

    
    # Element {http://morphml.org/networkml/schema}percentage_cells uses Python identifier percentage_cells
    __percentage_cells = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'percentage_cells'), 'percentage_cells', '__httpmorphml_orgnetworkmlschema_InputSitePattern_httpmorphml_orgnetworkmlschemapercentage_cells', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 279, 16), )

    
    percentage_cells = property(__percentage_cells.value, __percentage_cells.set, None, u'Apply input to a certain percentage of cells in a group')

    _ElementMap.update({
        __all_cells.name() : __all_cells,
        __percentage_cells.name() : __percentage_cells
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'InputSitePattern', InputSitePattern)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_13 (pyxb.binding.basis.complexTypeDefinition):
    """Apply input on all cells in group"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 277, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })



# Complex type {http://morphml.org/networkml/schema}InputSites with content type ELEMENT_ONLY
class InputSites (pyxb.binding.basis.complexTypeDefinition):
    """The list of input sites"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'InputSites')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 295, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_InputSites_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_InputSites_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_InputSites_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_InputSites_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}site uses Python identifier site
    __site = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'site'), 'site', '__httpmorphml_orgnetworkmlschema_InputSites_httpmorphml_orgnetworkmlschemasite', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 302, 16), )

    
    site = property(__site.value, __site.set, None, None)

    
    # Attribute size uses Python identifier size
    __size = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'size'), 'size', '__httpmorphml_orgnetworkmlschema_InputSites_size', pyxb.binding.datatypes.nonNegativeInteger)
    __size._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 305, 12)
    __size._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 305, 12)
    
    size = property(__size.value, __size.set, None, u'The number of instances of inputs. \n                    This is redundant information, but can be useful when the file is being parsed to allocate memory for an array of cells. \n                    NOTE: likely to be required from v2.0')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __site.name() : __site
    })
    _AttributeMap.update({
        __size.name() : __size
    })
_Namespace_net.addCategoryObject('typeBinding', u'InputSites', InputSites)


# Complex type {http://morphml.org/networkml/schema}Population with content type ELEMENT_ONLY
class Population (pyxb.binding.basis.complexTypeDefinition):
    """Description of a cell population of the same type"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Population')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 336, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Population_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Population_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Population_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Population_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}cell_type uses Python identifier cell_type
    __cell_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'cell_type'), 'cell_type', '__httpmorphml_orgnetworkmlschema_Population_httpmorphml_orgnetworkmlschemacell_type', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 344, 16), )

    
    cell_type = property(__cell_type.value, __cell_type.set, None, u'The cell type for this population. NOTE: an attribute value for cell_type WILL BE PREFERRED FORMAT IN v2.0. The option for this element will be removed!')

    
    # Element {http://morphml.org/networkml/schema}instances uses Python identifier instances
    __instances = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'instances'), 'instances', '__httpmorphml_orgnetworkmlschema_Population_httpmorphml_orgnetworkmlschemainstances', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 354, 20), )

    
    instances = property(__instances.value, __instances.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}pop_location uses Python identifier pop_location
    __pop_location = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'pop_location'), 'pop_location', '__httpmorphml_orgnetworkmlschema_Population_httpmorphml_orgnetworkmlschemapop_location', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 355, 20), )

    
    pop_location = property(__pop_location.value, __pop_location.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgnetworkmlschema_Population_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 360, 12)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 360, 12)
    
    name = property(__name.value, __name.set, None, u'The name of the population')

    
    # Attribute cell_type uses Python identifier cell_type_
    __cell_type_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cell_type'), 'cell_type_', '__httpmorphml_orgnetworkmlschema_Population_cell_type', pyxb.binding.datatypes.string)
    __cell_type_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 365, 12)
    __cell_type_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 365, 12)
    
    cell_type_ = property(__cell_type_.value, __cell_type_.set, None, u'The cell type for this population. Optional now, but WILL BE PREFERRED FORMAT IN v2.0')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __cell_type.name() : __cell_type,
        __instances.name() : __instances,
        __pop_location.name() : __pop_location
    })
    _AttributeMap.update({
        __name.name() : __name,
        __cell_type_.name() : __cell_type_
    })
_Namespace_net.addCategoryObject('typeBinding', u'Population', Population)


# Complex type {http://morphml.org/networkml/schema}Instances with content type ELEMENT_ONLY
class Instances (pyxb.binding.basis.complexTypeDefinition):
    """Cell Instance position information"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Instances')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 376, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Instances_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Instances_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Instances_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Instances_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}instance uses Python identifier instance
    __instance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'instance'), 'instance', '__httpmorphml_orgnetworkmlschema_Instances_httpmorphml_orgnetworkmlschemainstance', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 382, 16), )

    
    instance = property(__instance.value, __instance.set, None, None)

    
    # Attribute size uses Python identifier size
    __size = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'size'), 'size', '__httpmorphml_orgnetworkmlschema_Instances_size', pyxb.binding.datatypes.nonNegativeInteger, required=True)
    __size._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 386, 12)
    __size._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 386, 12)
    
    size = property(__size.value, __size.set, None, u'The number of instances of cells for this population. \n                    This is redundant information, but can be useful when the file is being parsed to allocate memory for an array of cells. \n                    NOTE: required from v1.7.3')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __instance.name() : __instance
    })
    _AttributeMap.update({
        __size.name() : __size
    })
_Namespace_net.addCategoryObject('typeBinding', u'Instances', Instances)


# Complex type {http://morphml.org/networkml/schema}Projection with content type ELEMENT_ONLY
class Projection (pyxb.binding.basis.complexTypeDefinition):
    """Description of how one cell population makes synaptic connections with another"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Projection')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 397, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}source uses Python identifier source
    __source = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'source'), 'source', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgnetworkmlschemasource', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 405, 16), )

    
    source = property(__source.value, __source.set, None, u'Cell population where synaptic connection begins. NOTE: attribute values for source and target WILL BE THE PREFERRED FORMAT IN v2.0. The option for this element will be removed!')

    
    # Element {http://morphml.org/networkml/schema}target uses Python identifier target
    __target = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'target'), 'target', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgnetworkmlschematarget', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 410, 16), )

    
    target = property(__target.value, __target.set, None, u'Cell population where synaptic connection terminates. NOTE: attribute values for source and target WILL BE THE PREFERRED FORMAT IN v2.0. The option for this element will be removed!')

    
    # Element {http://morphml.org/networkml/schema}synapse_props uses Python identifier synapse_props
    __synapse_props = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_props'), 'synapse_props', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgnetworkmlschemasynapse_props', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 416, 16), )

    
    synapse_props = property(__synapse_props.value, __synapse_props.set, None, u'Properties of a synapse associated with this connection.')

    
    # Element {http://morphml.org/networkml/schema}connections uses Python identifier connections
    __connections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'connections'), 'connections', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgnetworkmlschemaconnections', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 427, 20), )

    
    connections = property(__connections.value, __connections.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}connectivity_pattern uses Python identifier connectivity_pattern
    __connectivity_pattern = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'connectivity_pattern'), 'connectivity_pattern', '__httpmorphml_orgnetworkmlschema_Projection_httpmorphml_orgnetworkmlschemaconnectivity_pattern', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 428, 20), )

    
    connectivity_pattern = property(__connectivity_pattern.value, __connectivity_pattern.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgnetworkmlschema_Projection_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 434, 12)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 434, 12)
    
    name = property(__name.value, __name.set, None, u'String reference for the projection')

    
    # Attribute source uses Python identifier source_
    __source_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'source'), 'source_', '__httpmorphml_orgnetworkmlschema_Projection_source', pyxb.binding.datatypes.string)
    __source_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 439, 12)
    __source_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 439, 12)
    
    source_ = property(__source_.value, __source_.set, None, u'Cell population where synaptic connection begins. Optional now, but WILL BE PREFERRED FORMAT IN v2.0')

    
    # Attribute target uses Python identifier target_
    __target_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'target'), 'target_', '__httpmorphml_orgnetworkmlschema_Projection_target', pyxb.binding.datatypes.string)
    __target_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 444, 12)
    __target_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 444, 12)
    
    target_ = property(__target_.value, __target_.set, None, u'Cell population where synaptic connection terminates. Optional now, but WILL BE PREFERRED FORMAT IN v2.0')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __source.name() : __source,
        __target.name() : __target,
        __synapse_props.name() : __synapse_props,
        __connections.name() : __connections,
        __connectivity_pattern.name() : __connectivity_pattern
    })
    _AttributeMap.update({
        __name.name() : __name,
        __source_.name() : __source_,
        __target_.name() : __target_
    })
_Namespace_net.addCategoryObject('typeBinding', u'Projection', Projection)


# Complex type {http://morphml.org/networkml/schema}SynapseProperties with content type ELEMENT_ONLY
class SynapseProperties (pyxb.binding.basis.complexTypeDefinition):
    """Pre v1.7.1 format for global synapse properties. Preferred format is GlobalSynapticProperties. This option will be disabled in v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'SynapseProperties')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 453, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_SynapseProperties_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_SynapseProperties_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_SynapseProperties_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_SynapseProperties_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}synapse_type uses Python identifier synapse_type
    __synapse_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type'), 'synapse_type', '__httpmorphml_orgnetworkmlschema_SynapseProperties_httpmorphml_orgnetworkmlschemasynapse_type', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 462, 16), )

    
    synapse_type = property(__synapse_type.value, __synapse_type.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}default_values uses Python identifier default_values
    __default_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'default_values'), 'default_values', '__httpmorphml_orgnetworkmlschema_SynapseProperties_httpmorphml_orgnetworkmlschemadefault_values', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 463, 16), )

    
    default_values = property(__default_values.value, __default_values.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __synapse_type.name() : __synapse_type,
        __default_values.name() : __default_values
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'SynapseProperties', SynapseProperties)


# Complex type {http://morphml.org/networkml/schema}ConnectivityPattern with content type ELEMENT_ONLY
class ConnectivityPattern (pyxb.binding.basis.complexTypeDefinition):
    """Information on the number of target cells connected to source cells, etc."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'ConnectivityPattern')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 571, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/networkml/schema}all_to_all uses Python identifier all_to_all
    __all_to_all = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'all_to_all'), 'all_to_all', '__httpmorphml_orgnetworkmlschema_ConnectivityPattern_httpmorphml_orgnetworkmlschemaall_to_all', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 578, 16), )

    
    all_to_all = property(__all_to_all.value, __all_to_all.set, None, u'Connect every pre cell to every post cell')

    
    # Element {http://morphml.org/networkml/schema}fixed_probability uses Python identifier fixed_probability
    __fixed_probability = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'fixed_probability'), 'fixed_probability', '__httpmorphml_orgnetworkmlschema_ConnectivityPattern_httpmorphml_orgnetworkmlschemafixed_probability', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 584, 16), )

    
    fixed_probability = property(__fixed_probability.value, __fixed_probability.set, None, u'For each pre - post pair, there is a fixed probability of connection')

    
    # Element {http://morphml.org/networkml/schema}per_cell_connection uses Python identifier per_cell_connection
    __per_cell_connection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'per_cell_connection'), 'per_cell_connection', '__httpmorphml_orgnetworkmlschema_ConnectivityPattern_httpmorphml_orgnetworkmlschemaper_cell_connection', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 592, 16), )

    
    per_cell_connection = property(__per_cell_connection.value, __per_cell_connection.set, None, u'Connection built iteratively from each pre (or post) cell based on a number of parameters')

    _ElementMap.update({
        __all_to_all.name() : __all_to_all,
        __fixed_probability.name() : __fixed_probability,
        __per_cell_connection.name() : __per_cell_connection
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'ConnectivityPattern', ConnectivityPattern)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_14 (pyxb.binding.basis.complexTypeDefinition):
    """Connect every pre cell to every post cell"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 582, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })



# Complex type {http://morphml.org/networkml/schema}Connections with content type ELEMENT_ONLY
class Connections (pyxb.binding.basis.complexTypeDefinition):
    """The list of cell connections"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Connections')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 629, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Connections_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Connections_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Connections_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Connections_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}connection uses Python identifier connection
    __connection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'connection'), 'connection', '__httpmorphml_orgnetworkmlschema_Connections_httpmorphml_orgnetworkmlschemaconnection', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 636, 16), )

    
    connection = property(__connection.value, __connection.set, None, None)

    
    # Attribute size uses Python identifier size
    __size = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'size'), 'size', '__httpmorphml_orgnetworkmlschema_Connections_size', pyxb.binding.datatypes.nonNegativeInteger)
    __size._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 640, 12)
    __size._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 640, 12)
    
    size = property(__size.value, __size.set, None, u'The number of instances of connections. \n                    This is redundant information, but can be useful when the file is being parsed to allocate memory for an array of cells. \n                    NOTE: likely to be required from v2.0')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __connection.name() : __connection
    })
    _AttributeMap.update({
        __size.name() : __size
    })
_Namespace_net.addCategoryObject('typeBinding', u'Connections', Connections)


# Complex type {http://morphml.org/networkml/schema}CellInstance with content type ELEMENT_ONLY
class CellInstance (pyxb.binding.basis.complexTypeDefinition):
    """An instance of a cell at a the specified location"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'CellInstance')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 650, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_CellInstance_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_CellInstance_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_CellInstance_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_CellInstance_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}location uses Python identifier location
    __location = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'location'), 'location', '__httpmorphml_orgnetworkmlschema_CellInstance_httpmorphml_orgnetworkmlschemalocation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 657, 16), )

    
    location = property(__location.value, __location.set, None, None)

    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgnetworkmlschema_CellInstance_id', pyxb.binding.datatypes.nonNegativeInteger, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 660, 12)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 660, 12)
    
    id = property(__id.value, __id.set, None, u'A unique non negative integer id for the cell instance')

    
    # Attribute node_id uses Python identifier node_id
    __node_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'node_id'), 'node_id', '__httpmorphml_orgnetworkmlschema_CellInstance_node_id', pyxb.binding.datatypes.nonNegativeInteger)
    __node_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 666, 12)
    __node_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 666, 12)
    
    node_id = property(__node_id.value, __node_id.set, None, u'An optional specification of the node id on which this cell should run. This can be used\n                    to allow exchange of neuronal networks partitioned for execution in\n                    distributed computing environments. A parsing appliction can ignore this inforation and create its own partition.')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __location.name() : __location
    })
    _AttributeMap.update({
        __id.name() : __id,
        __node_id.name() : __node_id
    })
_Namespace_net.addCategoryObject('typeBinding', u'CellInstance', CellInstance)


# Complex type {http://morphml.org/networkml/schema}PopulationLocation with content type ELEMENT_ONLY
class PopulationLocation (pyxb.binding.basis.complexTypeDefinition):
    """Description of the 3D positioning of cells in the population, in place of giving explicit locations for each cell"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'PopulationLocation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 772, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_PopulationLocation_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_PopulationLocation_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_PopulationLocation_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_PopulationLocation_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}random_arrangement uses Python identifier random_arrangement
    __random_arrangement = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'random_arrangement'), 'random_arrangement', '__httpmorphml_orgnetworkmlschema_PopulationLocation_httpmorphml_orgnetworkmlschemarandom_arrangement', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 780, 20), )

    
    random_arrangement = property(__random_arrangement.value, __random_arrangement.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}grid_arrangement uses Python identifier grid_arrangement
    __grid_arrangement = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'grid_arrangement'), 'grid_arrangement', '__httpmorphml_orgnetworkmlschema_PopulationLocation_httpmorphml_orgnetworkmlschemagrid_arrangement', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 781, 20), )

    
    grid_arrangement = property(__grid_arrangement.value, __grid_arrangement.set, None, None)

    
    # Attribute reference uses Python identifier reference
    __reference = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'reference'), 'reference', '__httpmorphml_orgnetworkmlschema_PopulationLocation_reference', pyxb.binding.datatypes.string)
    __reference._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 787, 12)
    __reference._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 787, 12)
    
    reference = property(__reference.value, __reference.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __random_arrangement.name() : __random_arrangement,
        __grid_arrangement.name() : __grid_arrangement
    })
    _AttributeMap.update({
        __reference.name() : __reference
    })
_Namespace_net.addCategoryObject('typeBinding', u'PopulationLocation', PopulationLocation)


# Complex type {http://morphml.org/networkml/schema}RandomArrangement with content type ELEMENT_ONLY
class RandomArrangement (pyxb.binding.basis.complexTypeDefinition):
    """A random arrangement of cells in a 3D location. Note other 3D regions besides spheres and rectangles can be added if required."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'RandomArrangement')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 792, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_RandomArrangement_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_RandomArrangement_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_RandomArrangement_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_RandomArrangement_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}population_size uses Python identifier population_size
    __population_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'population_size'), 'population_size', '__httpmorphml_orgnetworkmlschema_RandomArrangement_httpmorphml_orgnetworkmlschemapopulation_size', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 798, 16), )

    
    population_size = property(__population_size.value, __population_size.set, None, u'Number of cells to place randomly in the specified 3D location')

    
    # Element {http://morphml.org/networkml/schema}spherical_location uses Python identifier spherical_location
    __spherical_location = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'spherical_location'), 'spherical_location', '__httpmorphml_orgnetworkmlschema_RandomArrangement_httpmorphml_orgnetworkmlschemaspherical_location', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 804, 20), )

    
    spherical_location = property(__spherical_location.value, __spherical_location.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}rectangular_location uses Python identifier rectangular_location
    __rectangular_location = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'rectangular_location'), 'rectangular_location', '__httpmorphml_orgnetworkmlschema_RandomArrangement_httpmorphml_orgnetworkmlschemarectangular_location', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 805, 20), )

    
    rectangular_location = property(__rectangular_location.value, __rectangular_location.set, None, None)

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __population_size.name() : __population_size,
        __spherical_location.name() : __spherical_location,
        __rectangular_location.name() : __rectangular_location
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'RandomArrangement', RandomArrangement)


# Complex type {http://morphml.org/networkml/schema}GridArrangement with content type ELEMENT_ONLY
class GridArrangement (pyxb.binding.basis.complexTypeDefinition):
    """A regular placement of the cells in a number of dimensions"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'GridArrangement')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 811, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_GridArrangement_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_GridArrangement_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_GridArrangement_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_GridArrangement_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}non_spatial_grid uses Python identifier non_spatial_grid
    __non_spatial_grid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'non_spatial_grid'), 'non_spatial_grid', '__httpmorphml_orgnetworkmlschema_GridArrangement_httpmorphml_orgnetworkmlschemanon_spatial_grid', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 822, 20), )

    
    non_spatial_grid = property(__non_spatial_grid.value, __non_spatial_grid.set, None, u'Specifying this means the precise spatial location of the cells is irrelvant')

    
    # Element {http://morphml.org/networkml/schema}rectangular_location uses Python identifier rectangular_location
    __rectangular_location = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'rectangular_location'), 'rectangular_location', '__httpmorphml_orgnetworkmlschema_GridArrangement_httpmorphml_orgnetworkmlschemarectangular_location', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 842, 16), )

    
    rectangular_location = property(__rectangular_location.value, __rectangular_location.set, None, u'3D box in which the cells are regularly packed. Note if one or two of dimensions of the box is zero it can be a 2D or 1D grid (respectively).')

    
    # Element {http://morphml.org/networkml/schema}spacing uses Python identifier spacing
    __spacing = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'spacing'), 'spacing', '__httpmorphml_orgnetworkmlschema_GridArrangement_httpmorphml_orgnetworkmlschemaspacing', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 849, 16), )

    
    spacing = property(__spacing.value, __spacing.set, None, u'Separation of the cells in each dimension')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __non_spatial_grid.name() : __non_spatial_grid,
        __rectangular_location.name() : __rectangular_location,
        __spacing.name() : __spacing
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'GridArrangement', GridArrangement)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_15 (pyxb.binding.basis.complexTypeDefinition):
    """Separation of the cells in each dimension"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 853, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute x uses Python identifier x
    __x = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'x'), 'x', '__httpmorphml_orgnetworkmlschema_CTD_ANON_2_x', pyxb.binding.datatypes.double)
    __x._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 854, 24)
    __x._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 854, 24)
    
    x = property(__x.value, __x.set, None, None)

    
    # Attribute y uses Python identifier y
    __y = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'y'), 'y', '__httpmorphml_orgnetworkmlschema_CTD_ANON_2_y', pyxb.binding.datatypes.double)
    __y._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 855, 24)
    __y._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 855, 24)
    
    y = property(__y.value, __y.set, None, None)

    
    # Attribute z uses Python identifier z
    __z = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'z'), 'z', '__httpmorphml_orgnetworkmlschema_CTD_ANON_2_z', pyxb.binding.datatypes.double)
    __z._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 856, 24)
    __z._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 856, 24)
    
    z = property(__z.value, __z.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __x.name() : __x,
        __y.name() : __y,
        __z.name() : __z
    })



# Complex type {http://morphml.org/networkml/schema}Level3Connectivity with content type ELEMENT_ONLY
class Level3Connectivity (pyxb.binding.basis.complexTypeDefinition):
    """Biophysics of Level3 cell, including specification for allowable synaptic locations.
                Note: from v1.7.1 the preferred way to specify a potential synaptic location is with a potential_syn_loc element under connectivity under cell, as
                opposed to the potentialSynapticLocation under biophysics under cell. The former will be the only option from v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Level3Connectivity')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 863, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/networkml/schema}potential_syn_loc uses Python identifier potential_syn_loc
    __potential_syn_loc = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'potential_syn_loc'), 'potential_syn_loc', '__httpmorphml_orgnetworkmlschema_Level3Connectivity_httpmorphml_orgnetworkmlschemapotential_syn_loc', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 870, 16), )

    
    potential_syn_loc = property(__potential_syn_loc.value, __potential_syn_loc.set, None, None)

    _ElementMap.update({
        __potential_syn_loc.name() : __potential_syn_loc
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'Level3Connectivity', Level3Connectivity)


# Complex type {http://morphml.org/networkml/schema}PotentialSynapticLocation with content type ELEMENT_ONLY
class PotentialSynapticLocation (pyxb.binding.basis.complexTypeDefinition):
    """Subset of sections on cell where synaptic connection of a particular type is allowed. 
                Note: from v1.7.1 the preferred way to specify a potential synaptic location is with a potential_syn_loc element under connectivity under cell, as
            opposed to the potentialSynapticLocation under biophysics under cell. The former will be the only option from v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'PotentialSynapticLocation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 908, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_PotentialSynapticLocation_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_PotentialSynapticLocation_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_PotentialSynapticLocation_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_PotentialSynapticLocation_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}synapse_type uses Python identifier synapse_type
    __synapse_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type'), 'synapse_type', '__httpmorphml_orgnetworkmlschema_PotentialSynapticLocation_httpmorphml_orgnetworkmlschemasynapse_type', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 918, 20), )

    
    synapse_type = property(__synapse_type.value, __synapse_type.set, None, u'Which of the synaptic mechanisms can be present')

    
    # Element {http://morphml.org/networkml/schema}synapse_direction uses Python identifier synapse_direction
    __synapse_direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_direction'), 'synapse_direction', '__httpmorphml_orgnetworkmlschema_PotentialSynapticLocation_httpmorphml_orgnetworkmlschemasynapse_direction', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 923, 20), )

    
    synapse_direction = property(__synapse_direction.value, __synapse_direction.set, None, u'Whether this synapse location allows a presynaptic connection, a postsynaptic\n                                connection or either')

    
    # Element {http://morphml.org/networkml/schema}group uses Python identifier group_
    __group_ = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'group'), 'group_', '__httpmorphml_orgnetworkmlschema_PotentialSynapticLocation_httpmorphml_orgnetworkmlschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 929, 20), )

    
    group_ = property(__group_.value, __group_.set, None, u'List of groups of sections allowing the synapse')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __synapse_type.name() : __synapse_type,
        __synapse_direction.name() : __synapse_direction,
        __group_.name() : __group_
    })
    _AttributeMap.update({
        
    })
_Namespace_net.addCategoryObject('typeBinding', u'PotentialSynapticLocation', PotentialSynapticLocation)


# Complex type {http://morphml.org/neuroml/schema}Level3Cells with content type ELEMENT_ONLY
class Level3Cells (pyxb.binding.basis.complexTypeDefinition):
    """Set of Level 3 cells"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace, u'Level3Cells')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 96, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/neuroml/schema}cell uses Python identifier cell
    __cell = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace, u'cell'), 'cell', '__httpmorphml_orgneuromlschema_Level3Cells_httpmorphml_orgneuromlschemacell', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 101, 16), )

    
    cell = property(__cell.value, __cell.set, None, u'A single cell specified in MorphML extended to include channel density info.')

    _ElementMap.update({
        __cell.name() : __cell
    })
    _AttributeMap.update({
        
    })
_Namespace.addCategoryObject('typeBinding', u'Level3Cells', Level3Cells)


# Complex type {http://morphml.org/biophysics/schema}Biophysics with content type ELEMENT_ONLY
class Biophysics (pyxb.binding.basis.complexTypeDefinition):
    """Description of biophysical properties of a cell."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'Biophysics')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 45, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}mechanism uses Python identifier mechanism
    __mechanism = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'mechanism'), 'mechanism', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemamechanism', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 50, 12), )

    
    mechanism = property(__mechanism.value, __mechanism.set, None, u'Definition of placement of a single electrophysiological mechanism (e.g. channel mechanism)\n                        on a group of cables of a cell. Note there should be at least one of these to specify the passive membrane conductance.\n                        Note: elements spec_capacitance, spec_axial_resistance, ion_props etc. should be used in preference to specificCapacitance etc!')

    
    # Element {http://morphml.org/biophysics/schema}specificCapacitance uses Python identifier specificCapacitance
    __specificCapacitance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificCapacitance'), 'specificCapacitance', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemaspecificCapacitance', False, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 58, 16), )

    
    specificCapacitance = property(__specificCapacitance.value, __specificCapacitance.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}spec_capacitance uses Python identifier spec_capacitance
    __spec_capacitance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_capacitance'), 'spec_capacitance', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemaspec_capacitance', False, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 59, 16), )

    
    spec_capacitance = property(__spec_capacitance.value, __spec_capacitance.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}specificAxialResistance uses Python identifier specificAxialResistance
    __specificAxialResistance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificAxialResistance'), 'specificAxialResistance', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemaspecificAxialResistance', False, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 62, 16), )

    
    specificAxialResistance = property(__specificAxialResistance.value, __specificAxialResistance.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}spec_axial_resistance uses Python identifier spec_axial_resistance
    __spec_axial_resistance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_axial_resistance'), 'spec_axial_resistance', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemaspec_axial_resistance', False, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 63, 16), )

    
    spec_axial_resistance = property(__spec_axial_resistance.value, __spec_axial_resistance.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}initialMembPotential uses Python identifier initialMembPotential
    __initialMembPotential = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'initialMembPotential'), 'initialMembPotential', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemainitialMembPotential', False, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 66, 16), )

    
    initialMembPotential = property(__initialMembPotential.value, __initialMembPotential.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}init_memb_potential uses Python identifier init_memb_potential
    __init_memb_potential = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'init_memb_potential'), 'init_memb_potential', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemainit_memb_potential', False, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 67, 16), )

    
    init_memb_potential = property(__init_memb_potential.value, __init_memb_potential.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}ionProperties uses Python identifier ionProperties
    __ionProperties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'ionProperties'), 'ionProperties', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemaionProperties', False, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 70, 16), )

    
    ionProperties = property(__ionProperties.value, __ionProperties.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}ion_props uses Python identifier ion_props
    __ion_props = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'ion_props'), 'ion_props', '__httpmorphml_orgbiophysicsschema_Biophysics_httpmorphml_orgbiophysicsschemaion_props', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 71, 16), )

    
    ion_props = property(__ion_props.value, __ion_props.set, None, None)

    
    # Attribute units uses Python identifier units
    __units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'units'), 'units', '__httpmorphml_orgbiophysicsschema_Biophysics_units', Units, required=True)
    __units._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 75, 17)
    __units._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 75, 17)
    
    units = property(__units.value, __units.set, None, u'Unit system of all quantities.')

    _ElementMap.update({
        __mechanism.name() : __mechanism,
        __specificCapacitance.name() : __specificCapacitance,
        __spec_capacitance.name() : __spec_capacitance,
        __specificAxialResistance.name() : __specificAxialResistance,
        __spec_axial_resistance.name() : __spec_axial_resistance,
        __initialMembPotential.name() : __initialMembPotential,
        __init_memb_potential.name() : __init_memb_potential,
        __ionProperties.name() : __ionProperties,
        __ion_props.name() : __ion_props
    })
    _AttributeMap.update({
        __units.name() : __units
    })
_Namespace_bio.addCategoryObject('typeBinding', u'Biophysics', Biophysics)


# Complex type {http://morphml.org/biophysics/schema}Mechanism with content type ELEMENT_ONLY
class Mechanism (pyxb.binding.basis.complexTypeDefinition):
    """Definition of placement of a single electrophysiological mechanism (e.g. channel mechanism)
                        on a group of cables of a cell"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_bio, u'Mechanism')
    _XSDLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 86, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/biophysics/schema}parameter uses Python identifier parameter
    __parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), 'parameter', '__httpmorphml_orgbiophysicsschema_Mechanism_httpmorphml_orgbiophysicsschemaparameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 93, 12), )

    
    parameter = property(__parameter.value, __parameter.set, None, None)

    
    # Element {http://morphml.org/biophysics/schema}variableParameter uses Python identifier variableParameter
    __variableParameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), 'variableParameter', '__httpmorphml_orgbiophysicsschema_Mechanism_httpmorphml_orgbiophysicsschemavariableParameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 94, 12), )

    
    variableParameter = property(__variableParameter.value, __variableParameter.set, None, u'Note variable_parameter will be the preferred form in v2.0')

    
    # Element {http://morphml.org/biophysics/schema}variable_parameter uses Python identifier variable_parameter
    __variable_parameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter'), 'variable_parameter', '__httpmorphml_orgbiophysicsschema_Mechanism_httpmorphml_orgbiophysicsschemavariable_parameter', True, pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 99, 12), )

    
    variable_parameter = property(__variable_parameter.value, __variable_parameter.set, None, u'Note variable_parameter will be the preferred form in v2.0')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgbiophysicsschema_Mechanism_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 106, 8)
    __name._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 106, 8)
    
    name = property(__name.value, __name.set, None, u'Name of the mechanism. Should refer to a named mechanism in a ChannelML file')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'type'), 'type', '__httpmorphml_orgbiophysicsschema_Mechanism_type', MechanismType, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 111, 8)
    __type._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 111, 8)
    
    type = property(__type.value, __type.set, None, u'Specifies the type of cellular mechanism (Channel Mechanism/Ion Concentration). Note could be used for any type of electrophysiological property of a section of a cell')

    
    # Attribute passive_conductance uses Python identifier passive_conductance
    __passive_conductance = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'passive_conductance'), 'passive_conductance', '__httpmorphml_orgbiophysicsschema_Mechanism_passive_conductance', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    __passive_conductance._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 116, 8)
    __passive_conductance._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 116, 8)
    
    passive_conductance = property(__passive_conductance.value, __passive_conductance.set, None, u"Whether this is a passive/leak conductance. In this case, 2 params, gmax and e should be sufficient to fully specify the\n            mechanism, independent of any implementation. Useful e.g. for mapping to and from inbuilt mechanisms in simulators (e.g. pas in NEURON, Em/Rm in GENESIS).\n        NOTE: this attribute will be required in v2.0!! Don't use passiveConductance anymore.\n            Changed for consistency with ChannelML and NetworkML naming conventions.")

    
    # Attribute passiveConductance uses Python identifier passiveConductance
    __passiveConductance = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'passiveConductance'), 'passiveConductance', '__httpmorphml_orgbiophysicsschema_Mechanism_passiveConductance', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    __passiveConductance._DeclarationLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 124, 8)
    __passiveConductance._UseLocation = pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 124, 8)
    
    passiveConductance = property(__passiveConductance.value, __passiveConductance.set, None, u'Whether this is a passive/leak conductance. NOTE: this attribute will be removed in v2.0!! Use passive_conductance instead.\n            Changed for consistency with ChannelML and NetworkML naming conventions.')

    _ElementMap.update({
        __parameter.name() : __parameter,
        __variableParameter.name() : __variableParameter,
        __variable_parameter.name() : __variable_parameter
    })
    _AttributeMap.update({
        __name.name() : __name,
        __type.name() : __type,
        __passive_conductance.name() : __passive_conductance,
        __passiveConductance.name() : __passiveConductance
    })
_Namespace_bio.addCategoryObject('typeBinding', u'Mechanism', Mechanism)


# Complex type {http://morphml.org/channelml/schema}ChannelML with content type ELEMENT_ONLY
class ChannelML (pyxb.binding.basis.complexTypeDefinition):
    """Root element containing the ions used in the mechanism, the unit system of the 
            file (as attribute), and information on channels and/or ion concentration dynamics. Normally only the ion element and 
            one of channel_type, synapse_type or ion_concentration should be present."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ChannelML')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 60, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}ion uses Python identifier ion
    __ion = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion'), 'ion', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgchannelmlschemaion', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 68, 12), )

    
    ion = property(__ion.value, __ion.set, None, u'One or more ions which play some role in the mechanism, e.g. transmitted by the channel, alters the rate, etc. Note: deprecated since v1.7.3')

    
    # Element {http://morphml.org/channelml/schema}channel_type uses Python identifier channel_type
    __channel_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'channel_type'), 'channel_type', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgchannelmlschemachannel_type', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 73, 12), )

    
    channel_type = property(__channel_type.value, __channel_type.set, None, u'Specification of a voltage or ligand gated membrane conductance mechanism')

    
    # Element {http://morphml.org/channelml/schema}synapse_type uses Python identifier synapse_type
    __synapse_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'synapse_type'), 'synapse_type', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgchannelmlschemasynapse_type', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 78, 12), )

    
    synapse_type = property(__synapse_type.value, __synapse_type.set, None, u'Specification of a synaptic conductance, triggered by a presynaptic event')

    
    # Element {http://morphml.org/channelml/schema}ion_concentration uses Python identifier ion_concentration
    __ion_concentration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion_concentration'), 'ion_concentration', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgchannelmlschemaion_concentration', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 83, 12), )

    
    ion_concentration = property(__ion_concentration.value, __ion_concentration.set, None, u'Specification of how an ion concentration alters with time, e.g. calcium dynamics. This may influence other\n                   channels (e.g. Ca dependent K channels), and other mechanisms may have a contribution to the concentration of the ion specified here\n                   (e.g. a channel transmitting calcium).')

    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_ChannelML_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute units uses Python identifier units
    __units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'units'), 'units', '__httpmorphml_orgchannelmlschema_ChannelML_units', Units, required=True)
    __units._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 92, 8)
    __units._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 92, 8)
    
    units = property(__units.value, __units.set, None, u'Unit system of all quantities. Only SI or Physiological units are allowed!')

    _ElementMap.update({
        __ion.name() : __ion,
        __channel_type.name() : __channel_type,
        __synapse_type.name() : __synapse_type,
        __ion_concentration.name() : __ion_concentration,
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __units.name() : __units
    })
_Namespace_cml.addCategoryObject('typeBinding', u'ChannelML', ChannelML)


# Complex type {http://morphml.org/channelml/schema}ChannelType with content type ELEMENT_ONLY
class ChannelType (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a voltage/concentration dependent cell membrane conductance"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ChannelType')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 132, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}status uses Python identifier status
    __status = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'status'), 'status', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgchannelmlschemastatus', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 138, 12), )

    
    status = property(__status.value, __status.set, None, u'Status of the channel specification: stable, in progress, etc.')

    
    # Element {http://morphml.org/channelml/schema}parameters uses Python identifier parameters
    __parameters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameters'), 'parameters', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgchannelmlschemaparameters', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 153, 12), )

    
    parameters = property(__parameters.value, __parameters.set, None, u'Fixed value parameters which can be used in generic expressions')

    
    # Element {http://morphml.org/channelml/schema}current_voltage_relation uses Python identifier current_voltage_relation
    __current_voltage_relation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'current_voltage_relation'), 'current_voltage_relation', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgchannelmlschemacurrent_voltage_relation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 161, 12), )

    
    current_voltage_relation = property(__current_voltage_relation.value, __current_voltage_relation.set, None, u'The specification of how the current flow etc. into the cell relates to the membrane potential \n                    difference (e.g. Ohmic relationship)')

    
    # Element {http://morphml.org/channelml/schema}hh_gate uses Python identifier hh_gate
    __hh_gate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'hh_gate'), 'hh_gate', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgchannelmlschemahh_gate', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 169, 12), )

    
    hh_gate = property(__hh_gate.value, __hh_gate.set, None, u'Channel specification based on the Hodgkin Huxley formalism. Deprecated! Will be removed in v2.0')

    
    # Element {http://morphml.org/channelml/schema}ks_gate uses Python identifier ks_gate
    __ks_gate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'ks_gate'), 'ks_gate', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgchannelmlschemaks_gate', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 175, 12), )

    
    ks_gate = property(__ks_gate.value, __ks_gate.set, None, u'Channel specification based on a kinetic scheme formalism. Deprecated! Will be removed in v2.0')

    
    # Element {http://morphml.org/channelml/schema}impl_prefs uses Python identifier impl_prefs
    __impl_prefs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'impl_prefs'), 'impl_prefs', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgchannelmlschemaimpl_prefs', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 181, 12), )

    
    impl_prefs = property(__impl_prefs.value, __impl_prefs.set, None, u'Optional recommended values, e.g. for size of tables, when creating an implementation of the \n                    channel mechanism on a specific simulator')

    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}authorList uses Python identifier authorList
    __authorList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), 'authorList', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemaauthorList', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12), )

    
    authorList = property(__authorList.value, __authorList.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}publication uses Python identifier publication
    __publication = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), 'publication', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemapublication', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12), )

    
    publication = property(__publication.value, __publication.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuronDBref uses Python identifier neuronDBref
    __neuronDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), 'neuronDBref', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemaneuronDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12), )

    
    neuronDBref = property(__neuronDBref.value, __neuronDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}modelDBref uses Python identifier modelDBref
    __modelDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), 'modelDBref', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemamodelDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12), )

    
    modelDBref = property(__modelDBref.value, __modelDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuroMorphoRef uses Python identifier neuroMorphoRef
    __neuroMorphoRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), 'neuroMorphoRef', '__httpmorphml_orgchannelmlschema_ChannelType_httpmorphml_orgmetadataschemaneuroMorphoRef', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12), )

    
    neuroMorphoRef = property(__neuroMorphoRef.value, __neuroMorphoRef.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_ChannelType_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 190, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 190, 8)
    
    name = property(__name.value, __name.set, None, u'A unique name for the channel mechanism')

    
    # Attribute density uses Python identifier density
    __density = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'density'), 'density', '__httpmorphml_orgchannelmlschema_ChannelType_density', YesNo, unicode_default=u'yes')
    __density._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 195, 8)
    __density._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 195, 8)
    
    density = property(__density.value, __density.set, None, u'Is this a specification of conductance per unit area? Note: almost all channel mechanisms to far have been density mechanisms. \n                This attribute is subject to change when use of ChannelML for single channel conductances is supported.')

    _ElementMap.update({
        __status.name() : __status,
        __parameters.name() : __parameters,
        __current_voltage_relation.name() : __current_voltage_relation,
        __hh_gate.name() : __hh_gate,
        __ks_gate.name() : __ks_gate,
        __impl_prefs.name() : __impl_prefs,
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __authorList.name() : __authorList,
        __publication.name() : __publication,
        __neuronDBref.name() : __neuronDBref,
        __modelDBref.name() : __modelDBref,
        __neuroMorphoRef.name() : __neuroMorphoRef
    })
    _AttributeMap.update({
        __name.name() : __name,
        __density.name() : __density
    })
_Namespace_cml.addCategoryObject('typeBinding', u'ChannelType', ChannelType)


# Complex type {http://morphml.org/channelml/schema}ElectricalSynapse with content type ELEMENT_ONLY
class ElectricalSynapse (pyxb.binding.basis.complexTypeDefinition):
    """Electrical synaptic coupling as at a gap junction. A simple model with just a parameter for the (2 way) conductance"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ElectricalSynapse')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 269, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_ElectricalSynapse_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_ElectricalSynapse_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_ElectricalSynapse_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_ElectricalSynapse_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute conductance uses Python identifier conductance
    __conductance = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'conductance'), 'conductance', '__httpmorphml_orgchannelmlschema_ElectricalSynapse_conductance', ConductanceValue, required=True)
    __conductance._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 276, 8)
    __conductance._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 276, 8)
    
    conductance = property(__conductance.value, __conductance.set, None, u'The conductance of the electrical connection')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __conductance.name() : __conductance
    })
_Namespace_cml.addCategoryObject('typeBinding', u'ElectricalSynapse', ElectricalSynapse)


# Complex type {http://morphml.org/channelml/schema}DoubleExponentialSynapse with content type ELEMENT_ONLY
class DoubleExponentialSynapse (pyxb.binding.basis.complexTypeDefinition):
    """A basic synaptic mechanism with a double exponential conductance time course. This mechanism maps 
            easily on to mechanisms in both NEURON (Exp2Syn) and GENESIS (synchan)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'DoubleExponentialSynapse')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 286, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute max_conductance uses Python identifier max_conductance
    __max_conductance = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_conductance'), 'max_conductance', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_max_conductance', ConductanceValue, required=True)
    __max_conductance._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 294, 8)
    __max_conductance._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 294, 8)
    
    max_conductance = property(__max_conductance.value, __max_conductance.set, None, u'The maximum conductance of the channel')

    
    # Attribute rise_time uses Python identifier rise_time
    __rise_time = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'rise_time'), 'rise_time', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_rise_time', TimeConstantValueIncZero, required=True)
    __rise_time._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 299, 8)
    __rise_time._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 299, 8)
    
    rise_time = property(__rise_time.value, __rise_time.set, None, u'The characteristic rise time of the conductance waveform ')

    
    # Attribute decay_time uses Python identifier decay_time
    __decay_time = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'decay_time'), 'decay_time', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_decay_time', TimeConstantValue, required=True)
    __decay_time._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 304, 8)
    __decay_time._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 304, 8)
    
    decay_time = property(__decay_time.value, __decay_time.set, None, u'The characteristic decay time of the conductance waveform ')

    
    # Attribute reversal_potential uses Python identifier reversal_potential
    __reversal_potential = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'reversal_potential'), 'reversal_potential', '__httpmorphml_orgchannelmlschema_DoubleExponentialSynapse_reversal_potential', VoltageValue, required=True)
    __reversal_potential._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 309, 8)
    __reversal_potential._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 309, 8)
    
    reversal_potential = property(__reversal_potential.value, __reversal_potential.set, None, u'The reversal potential of the synapse, which (along with the membrane potential) will determine the current passing through the synapse when the conductance is non zero ')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __max_conductance.name() : __max_conductance,
        __rise_time.name() : __rise_time,
        __decay_time.name() : __decay_time,
        __reversal_potential.name() : __reversal_potential
    })
_Namespace_cml.addCategoryObject('typeBinding', u'DoubleExponentialSynapse', DoubleExponentialSynapse)


# Complex type {http://morphml.org/channelml/schema}Block with content type EMPTY
class Block (pyxb.binding.basis.complexTypeDefinition):
    """Specification for the influence of a blocking species on the conductance of a BlockingSynapse. Based on the
            mechanism for blocking of an NMDA receptor by Mg as outlined in Gabbiani et al, 1994, Maex DeSchutter 1998"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Block')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 335, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute species uses Python identifier species
    __species = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'species'), 'species', '__httpmorphml_orgchannelmlschema_Block_species', pyxb.binding.datatypes.string, required=True)
    __species._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 340, 8)
    __species._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 340, 8)
    
    species = property(__species.value, __species.set, None, u'Name of species. For ions use lowercase, e.g. mg')

    
    # Attribute conc uses Python identifier conc
    __conc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'conc'), 'conc', '__httpmorphml_orgchannelmlschema_Block_conc', ConcentrationValue, required=True)
    __conc._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 346, 8)
    __conc._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 346, 8)
    
    conc = property(__conc.value, __conc.set, None, u'Concentration of species. Multiplicative factor for total conductance: 1/(1 + eta * [conc] * exp(-1* gamma * V))')

    
    # Attribute eta uses Python identifier eta
    __eta = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'eta'), 'eta', '__httpmorphml_orgchannelmlschema_Block_eta', pyxb.binding.datatypes.double, required=True)
    __eta._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 352, 8)
    __eta._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 352, 8)
    
    eta = property(__eta.value, __eta.set, None, u'Used in multiplicative factor for total conductance: 1/(1 + eta * [conc] * exp(-1* gamma * V))')

    
    # Attribute gamma uses Python identifier gamma
    __gamma = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'gamma'), 'gamma', '__httpmorphml_orgchannelmlschema_Block_gamma', pyxb.binding.datatypes.double, required=True)
    __gamma._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 361, 8)
    __gamma._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 361, 8)
    
    gamma = property(__gamma.value, __gamma.set, None, u'Used in multiplicative factor for total conductance: 1/(1 + eta * [conc] * exp(-1* gamma * V))')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __species.name() : __species,
        __conc.name() : __conc,
        __eta.name() : __eta,
        __gamma.name() : __gamma
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Block', Block)


# Complex type {http://morphml.org/channelml/schema}FacDep with content type EMPTY
class FacDep (pyxb.binding.basis.complexTypeDefinition):
    """Facilitating and depressing synaptic parameters. See mapping to NEURON mod file for implementation details."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'FacDep')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 458, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute init_release_prob uses Python identifier init_release_prob
    __init_release_prob = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'init_release_prob'), 'init_release_prob', '__httpmorphml_orgchannelmlschema_FacDep_init_release_prob', pyxb.binding.datatypes.double, required=True)
    __init_release_prob._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 462, 8)
    __init_release_prob._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 462, 8)
    
    init_release_prob = property(__init_release_prob.value, __init_release_prob.set, None, None)

    
    # Attribute tau_rec uses Python identifier tau_rec
    __tau_rec = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'tau_rec'), 'tau_rec', '__httpmorphml_orgchannelmlschema_FacDep_tau_rec', TimeConstantValueIncZero, required=True)
    __tau_rec._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 463, 8)
    __tau_rec._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 463, 8)
    
    tau_rec = property(__tau_rec.value, __tau_rec.set, None, None)

    
    # Attribute tau_fac uses Python identifier tau_fac
    __tau_fac = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'tau_fac'), 'tau_fac', '__httpmorphml_orgchannelmlschema_FacDep_tau_fac', TimeConstantValueIncZero, required=True)
    __tau_fac._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 464, 8)
    __tau_fac._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 464, 8)
    
    tau_fac = property(__tau_fac.value, __tau_fac.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __init_release_prob.name() : __init_release_prob,
        __tau_rec.name() : __tau_rec,
        __tau_fac.name() : __tau_fac
    })
_Namespace_cml.addCategoryObject('typeBinding', u'FacDep', FacDep)


# Complex type {http://morphml.org/channelml/schema}StdpDep with content type EMPTY
class StdpDep (pyxb.binding.basis.complexTypeDefinition):
    """A synaptic mechanism implementing basic Spike Timing Dependent Plasticity based on Song and Abbott, 2001. See mapping to NEURON mod file for implementation details."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'StdpDep')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 467, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute tau_ltp uses Python identifier tau_ltp
    __tau_ltp = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'tau_ltp'), 'tau_ltp', '__httpmorphml_orgchannelmlschema_StdpDep_tau_ltp', TimeConstantValue, required=True)
    __tau_ltp._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 472, 8)
    __tau_ltp._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 472, 8)
    
    tau_ltp = property(__tau_ltp.value, __tau_ltp.set, None, None)

    
    # Attribute del_weight_ltp uses Python identifier del_weight_ltp
    __del_weight_ltp = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'del_weight_ltp'), 'del_weight_ltp', '__httpmorphml_orgchannelmlschema_StdpDep_del_weight_ltp', pyxb.binding.datatypes.double, required=True)
    __del_weight_ltp._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 473, 8)
    __del_weight_ltp._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 473, 8)
    
    del_weight_ltp = property(__del_weight_ltp.value, __del_weight_ltp.set, None, None)

    
    # Attribute tau_ltd uses Python identifier tau_ltd
    __tau_ltd = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'tau_ltd'), 'tau_ltd', '__httpmorphml_orgchannelmlschema_StdpDep_tau_ltd', TimeConstantValue, required=True)
    __tau_ltd._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 474, 8)
    __tau_ltd._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 474, 8)
    
    tau_ltd = property(__tau_ltd.value, __tau_ltd.set, None, None)

    
    # Attribute del_weight_ltd uses Python identifier del_weight_ltd
    __del_weight_ltd = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'del_weight_ltd'), 'del_weight_ltd', '__httpmorphml_orgchannelmlschema_StdpDep_del_weight_ltd', pyxb.binding.datatypes.double, required=True)
    __del_weight_ltd._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 475, 8)
    __del_weight_ltd._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 475, 8)
    
    del_weight_ltd = property(__del_weight_ltd.value, __del_weight_ltd.set, None, None)

    
    # Attribute max_syn_weight uses Python identifier max_syn_weight
    __max_syn_weight = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_syn_weight'), 'max_syn_weight', '__httpmorphml_orgchannelmlschema_StdpDep_max_syn_weight', pyxb.binding.datatypes.double, required=True)
    __max_syn_weight._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 476, 8)
    __max_syn_weight._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 476, 8)
    
    max_syn_weight = property(__max_syn_weight.value, __max_syn_weight.set, None, None)

    
    # Attribute post_spike_thresh uses Python identifier post_spike_thresh
    __post_spike_thresh = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'post_spike_thresh'), 'post_spike_thresh', '__httpmorphml_orgchannelmlschema_StdpDep_post_spike_thresh', VoltageValue, required=True)
    __post_spike_thresh._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 477, 8)
    __post_spike_thresh._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 477, 8)
    
    post_spike_thresh = property(__post_spike_thresh.value, __post_spike_thresh.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __tau_ltp.name() : __tau_ltp,
        __del_weight_ltp.name() : __del_weight_ltp,
        __tau_ltd.name() : __tau_ltd,
        __del_weight_ltd.name() : __del_weight_ltd,
        __max_syn_weight.name() : __max_syn_weight,
        __post_spike_thresh.name() : __post_spike_thresh
    })
_Namespace_cml.addCategoryObject('typeBinding', u'StdpDep', StdpDep)


# Complex type {http://morphml.org/channelml/schema}CurrentVoltageRelation with content type ELEMENT_ONLY
class CurrentVoltageRelation (pyxb.binding.basis.complexTypeDefinition):
    """How the current through the channel depends on the conductance of the channel. 
            Only ohmic and integrate_and_fire supported at the moment"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'CurrentVoltageRelation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 483, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}ohmic uses Python identifier ohmic
    __ohmic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'ohmic'), 'ohmic', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_httpmorphml_orgchannelmlschemaohmic', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 491, 12), )

    
    ohmic = property(__ohmic.value, __ohmic.set, None, u'Deprecated since v1.7.3. Use attribute cond_law and gate elements below this element instead. ')

    
    # Element {http://morphml.org/channelml/schema}integrate_and_fire uses Python identifier integrate_and_fire
    __integrate_and_fire = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'integrate_and_fire'), 'integrate_and_fire', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_httpmorphml_orgchannelmlschemaintegrate_and_fire', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 497, 12), )

    
    integrate_and_fire = property(__integrate_and_fire.value, __integrate_and_fire.set, None, u'Note: use attribute cond_law="integrate_and_fire" and no other attributes here when using this. \n                    Signifies a current which will cause the cell to behave like an integrate and fire neuron')

    
    # Element {http://morphml.org/channelml/schema}conc_dependence uses Python identifier conc_dependence
    __conc_dependence = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_dependence'), 'conc_dependence', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_httpmorphml_orgchannelmlschemaconc_dependence', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 504, 12), )

    
    conc_dependence = property(__conc_dependence.value, __conc_dependence.set, None, u'Preferred location of conc_dependence since v1.7.3. ')

    
    # Element {http://morphml.org/channelml/schema}conc_factor uses Python identifier conc_factor
    __conc_factor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_factor'), 'conc_factor', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_httpmorphml_orgchannelmlschemaconc_factor', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 510, 12), )

    
    conc_factor = property(__conc_factor.value, __conc_factor.set, None, u'Preferred location of conc_factor since v1.7.3. ')

    
    # Element {http://morphml.org/channelml/schema}q10_settings uses Python identifier q10_settings
    __q10_settings = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'q10_settings'), 'q10_settings', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_httpmorphml_orgchannelmlschemaq10_settings', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 516, 12), )

    
    q10_settings = property(__q10_settings.value, __q10_settings.set, None, u'Preferred location of Q10 information since v1.7.3. ')

    
    # Element {http://morphml.org/channelml/schema}offset uses Python identifier offset
    __offset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'offset'), 'offset', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_httpmorphml_orgchannelmlschemaoffset', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 522, 12), )

    
    offset = property(__offset.value, __offset.set, None, u'Preferred location of offset information since v1.7.3. ')

    
    # Element {http://morphml.org/channelml/schema}gate uses Python identifier gate
    __gate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'gate'), 'gate', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_httpmorphml_orgchannelmlschemagate', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 528, 12), )

    
    gate = property(__gate.value, __gate.set, None, u'Preferred way of expressing gating complexes since v1.7.3. ')

    
    # Attribute cond_law uses Python identifier cond_law
    __cond_law = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cond_law'), 'cond_law', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_cond_law', ConductanceLaw)
    __cond_law._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 540, 8)
    __cond_law._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 540, 8)
    
    cond_law = property(__cond_law.value, __cond_law.set, None, u'Introduced in v1.7.3 for new format ChannelML. Specifies which type of conductance law to use: ohmic, etc.')

    
    # Attribute ion uses Python identifier ion
    __ion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'ion'), 'ion', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_ion', pyxb.binding.datatypes.string)
    __ion._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 547, 8)
    __ion._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 547, 8)
    
    ion = property(__ion.value, __ion.set, None, u'Introduced in v1.7.3 for new format ChannelML. The ion which will flow due to the conductance. Note this should be already declared in an Ion element at the beginning of the file.')

    
    # Attribute default_gmax uses Python identifier default_gmax
    __default_gmax = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'default_gmax'), 'default_gmax', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_default_gmax', ConductanceDensityValue)
    __default_gmax._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 554, 8)
    __default_gmax._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 554, 8)
    
    default_gmax = property(__default_gmax.value, __default_gmax.set, None, u'Introduced in v1.7.3 for new format ChannelML. Maximum conductance density of channel. Note this will normally be reset when the channel mechanism is placed on a cell, but it it \n                useful to have a default value here.')

    
    # Attribute default_erev uses Python identifier default_erev
    __default_erev = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'default_erev'), 'default_erev', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_default_erev', VoltageValue)
    __default_erev._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 562, 8)
    __default_erev._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 562, 8)
    
    default_erev = property(__default_erev.value, __default_erev.set, None, u'Most implementations of these channel mechanisms (e.g. a mod file) will need a value for the\n                reversal potential for the ion which flows through the channel. However, this is a property of the cell, as opposed to the channel.\n                For convenience though, a typical value can be used here, so a pretty self contained script can be produced, but when used in a real cell the\n                actual value for erev must be calculated')

    
    # Attribute charge uses Python identifier charge
    __charge = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'charge'), 'charge', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_charge', pyxb.binding.datatypes.positiveInteger)
    __charge._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 572, 8)
    __charge._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 572, 8)
    
    charge = property(__charge.value, __charge.set, None, u'Electrical charge of the ion in question')

    
    # Attribute fixed_erev uses Python identifier fixed_erev
    __fixed_erev = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fixed_erev'), 'fixed_erev', '__httpmorphml_orgchannelmlschema_CurrentVoltageRelation_fixed_erev', YesNo, unicode_default=u'no')
    __fixed_erev._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 579, 8)
    __fixed_erev._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 579, 8)
    
    fixed_erev = property(__fixed_erev.value, __fixed_erev.set, None, u'Flags whether the reversal potential can be influenced from outside the channel (value = no; default)\n                as is normally the case (e.g. a Ca channel whose reversal potential is influenced by a decaying calcium pool), or \n                whether the rev pot remains fixed (just for this channel) at default_erev (value = yes)')

    _ElementMap.update({
        __ohmic.name() : __ohmic,
        __integrate_and_fire.name() : __integrate_and_fire,
        __conc_dependence.name() : __conc_dependence,
        __conc_factor.name() : __conc_factor,
        __q10_settings.name() : __q10_settings,
        __offset.name() : __offset,
        __gate.name() : __gate
    })
    _AttributeMap.update({
        __cond_law.name() : __cond_law,
        __ion.name() : __ion,
        __default_gmax.name() : __default_gmax,
        __default_erev.name() : __default_erev,
        __charge.name() : __charge,
        __fixed_erev.name() : __fixed_erev
    })
_Namespace_cml.addCategoryObject('typeBinding', u'CurrentVoltageRelation', CurrentVoltageRelation)


# Complex type {http://morphml.org/channelml/schema}IntegrateAndFire with content type EMPTY
class IntegrateAndFire (pyxb.binding.basis.complexTypeDefinition):
    """Signifies a current which will cause the cell to behave like an integrate and fire neuron. There are many ways to describe an
        Integrate and Fire mechanism, this one is based on the implementation in NEURON of the COBA IandF cell as described in Brette et al (2007)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'IntegrateAndFire')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 611, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute threshold uses Python identifier threshold
    __threshold = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'threshold'), 'threshold', '__httpmorphml_orgchannelmlschema_IntegrateAndFire_threshold', VoltageValue, required=True)
    __threshold._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 617, 8)
    __threshold._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 617, 8)
    
    threshold = property(__threshold.value, __threshold.set, None, u'Voltage at which the mechanism causes the segment/cell to fire, i.e. membrane potential will be reset to v_reset')

    
    # Attribute t_refrac uses Python identifier t_refrac
    __t_refrac = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u't_refrac'), 't_refrac', '__httpmorphml_orgchannelmlschema_IntegrateAndFire_t_refrac', TimeValue, required=True)
    __t_refrac._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 621, 8)
    __t_refrac._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 621, 8)
    
    t_refrac = property(__t_refrac.value, __t_refrac.set, None, u'Time after a spike during which the segment will be clamped to v_reset (clamping current given by i = g_refrac*(v - v_reset))')

    
    # Attribute v_reset uses Python identifier v_reset
    __v_reset = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'v_reset'), 'v_reset', '__httpmorphml_orgchannelmlschema_IntegrateAndFire_v_reset', VoltageValue, required=True)
    __v_reset._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 625, 8)
    __v_reset._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 625, 8)
    
    v_reset = property(__v_reset.value, __v_reset.set, None, u'Membrane potential is reset to this after spiking')

    
    # Attribute g_refrac uses Python identifier g_refrac
    __g_refrac = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'g_refrac'), 'g_refrac', '__httpmorphml_orgchannelmlschema_IntegrateAndFire_g_refrac', ConductanceValue, required=True)
    __g_refrac._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 629, 8)
    __g_refrac._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 629, 8)
    
    g_refrac = property(__g_refrac.value, __g_refrac.set, None, u'Conductance during the period t_refrac after a spike, when the current due to this mechanism is given by i = g_refrac*(v - v_reset), therefore a high value for g_refrac, e.g. 100 microsiemens, will effectively clamp the cell at v_reset')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __threshold.name() : __threshold,
        __t_refrac.name() : __t_refrac,
        __v_reset.name() : __v_reset,
        __g_refrac.name() : __g_refrac
    })
_Namespace_cml.addCategoryObject('typeBinding', u'IntegrateAndFire', IntegrateAndFire)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_16 (pyxb.binding.basis.complexTypeDefinition):
    """Description of the conductance including maximum conductance density and possible (voltage and/or concentration dependent) gating mechanisms"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 648, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}rate_adjustments uses Python identifier rate_adjustments
    __rate_adjustments = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'rate_adjustments'), 'rate_adjustments', '__httpmorphml_orgchannelmlschema_CTD_ANON__httpmorphml_orgchannelmlschemarate_adjustments', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 651, 24), )

    
    rate_adjustments = property(__rate_adjustments.value, __rate_adjustments.set, None, u'Adjustments, e.g. temperature dependence, to apply to the gating mechanisms')

    
    # Element {http://morphml.org/channelml/schema}conc_factor uses Python identifier conc_factor
    __conc_factor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_factor'), 'conc_factor', '__httpmorphml_orgchannelmlschema_CTD_ANON__httpmorphml_orgchannelmlschemaconc_factor', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 656, 24), )

    
    conc_factor = property(__conc_factor.value, __conc_factor.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}gate uses Python identifier gate
    __gate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'gate'), 'gate', '__httpmorphml_orgchannelmlschema_CTD_ANON__httpmorphml_orgchannelmlschemagate', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 658, 24), )

    
    gate = property(__gate.value, __gate.set, None, u'Voltage/concentration dependent gate')

    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_CTD_ANON__httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_CTD_ANON__httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_CTD_ANON__httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_CTD_ANON__httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute default_gmax uses Python identifier default_gmax
    __default_gmax = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'default_gmax'), 'default_gmax', '__httpmorphml_orgchannelmlschema_CTD_ANON__default_gmax', ConductanceDensityValue, required=True)
    __default_gmax._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 664, 20)
    __default_gmax._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 664, 20)
    
    default_gmax = property(__default_gmax.value, __default_gmax.set, None, u'Maximum conductance density of channel')

    _ElementMap.update({
        __rate_adjustments.name() : __rate_adjustments,
        __conc_factor.name() : __conc_factor,
        __gate.name() : __gate,
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __default_gmax.name() : __default_gmax
    })



# Complex type {http://morphml.org/channelml/schema}Offset with content type EMPTY
class Offset (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://morphml.org/channelml/schema}Offset with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Offset')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 738, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgchannelmlschema_Offset_value', VoltageValue, required=True)
    __value._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 739, 8)
    __value._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 739, 8)
    
    value_ = property(__value.value, __value.set, None, u'Offset introduced to alter voltage dependence of \n                rate equations, see NEURON/GENESIS mappings for details')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __value.name() : __value
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Offset', Offset)


# Complex type {http://morphml.org/channelml/schema}Q10Settings with content type EMPTY
class Q10Settings (pyxb.binding.basis.complexTypeDefinition):
    """Q10 scaling affects the tau in the rate equations. It allows rate equations determined at one temperature to be used at a different temperature.
            If tauExp is the experimentally measured tau, the rate at temperature T is given by tau(T) = tauExp / q10_factor ^ ((T - experimental_temp)/10). NOTE: if fixed_q10 is specified
            the expression will be tau(T) = tauExp / fixed_q10, and the experimental_temp can be used to check that a simulation is running
            at the desired temperature. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Q10Settings')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 749, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute gate uses Python identifier gate
    __gate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'gate'), 'gate', '__httpmorphml_orgchannelmlschema_Q10Settings_gate', pyxb.binding.datatypes.string)
    __gate._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 758, 12)
    __gate._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 758, 12)
    
    gate = property(__gate.value, __gate.set, None, u'The gate to which the Q10 adjustment should be applied. If this attribute is not present, assume the adjustment applies at all gates.')

    
    # Attribute fixed_q10 uses Python identifier fixed_q10
    __fixed_q10 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fixed_q10'), 'fixed_q10', '__httpmorphml_orgchannelmlschema_Q10Settings_fixed_q10', pyxb.binding.datatypes.double)
    __fixed_q10._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 764, 12)
    __fixed_q10._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 764, 12)
    
    fixed_q10 = property(__fixed_q10.value, __fixed_q10.set, None, u'Q10 factor if the cell is to be run at a different temp than that at which \n                    the alpha and beta were determined. Only one of fixed_q10 or q10_factor should be specified!')

    
    # Attribute q10_factor uses Python identifier q10_factor
    __q10_factor = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'q10_factor'), 'q10_factor', '__httpmorphml_orgchannelmlschema_Q10Settings_q10_factor', pyxb.binding.datatypes.double)
    __q10_factor._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 771, 12)
    __q10_factor._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 771, 12)
    
    q10_factor = property(__q10_factor.value, __q10_factor.set, None, u'Q10 factor if the cell is to be run at a different temp than that at which \n                    the alpha and beta were determined. Only one of fixed_q10 or q10_factor should be specified!')

    
    # Attribute experimental_temp uses Python identifier experimental_temp
    __experimental_temp = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'experimental_temp'), 'experimental_temp', '__httpmorphml_orgchannelmlschema_Q10Settings_experimental_temp', TemperatureValue, required=True)
    __experimental_temp._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 778, 12)
    __experimental_temp._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 778, 12)
    
    experimental_temp = property(__experimental_temp.value, __experimental_temp.set, None, u'The experimental temperature at which alpha and beta rate \n                    equations were determined were measured')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __gate.name() : __gate,
        __fixed_q10.name() : __fixed_q10,
        __q10_factor.name() : __q10_factor,
        __experimental_temp.name() : __experimental_temp
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Q10Settings', Q10Settings)


# Complex type {http://morphml.org/channelml/schema}Deprecated_Ion with content type ELEMENT_ONLY
class Deprecated_Ion (pyxb.binding.basis.complexTypeDefinition):
    """Definition of an ion which is involved in this channel mechanism. Note: deprecated since v1.7.3"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_Ion')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 787, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 796, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 796, 8)
    
    name = property(__name.value, __name.set, None, u'Simple name for the ion. Due to the conventions used in NEURON, it is usually best to use \n                the lower case form of the chemical symbol, e.g. na, ca, k')

    
    # Attribute default_erev uses Python identifier default_erev
    __default_erev = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'default_erev'), 'default_erev', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_default_erev', VoltageValue)
    __default_erev._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 802, 8)
    __default_erev._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 802, 8)
    
    default_erev = property(__default_erev.value, __default_erev.set, None, u'Most implementations of these channel mechanisms (e.g. a mod file) will need a value for the\n                reversal potential for the ion which flows through the channel. However, this is a property of the cell, as opposed to the channel.\n                For convenience though, a typical value can be used here, so a pretty self contained script can be produced, but when used in a real cell the\n                actual value for erev must be calculated')

    
    # Attribute charge uses Python identifier charge
    __charge = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'charge'), 'charge', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_charge', pyxb.binding.datatypes.positiveInteger, required=True)
    __charge._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 810, 8)
    __charge._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 810, 8)
    
    charge = property(__charge.value, __charge.set, None, u'Electrical charge of the ion in question')

    
    # Attribute role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'role'), 'role', '__httpmorphml_orgchannelmlschema_Deprecated_Ion_role', Deprecated_IonRole, unicode_default=u'PermeatedSubstance')
    __role._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 815, 8)
    __role._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 815, 8)
    
    role = property(__role.value, __role.set, None, u'What role the ion plays in the dynamics of the channel/cell mechanism')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __name.name() : __name,
        __default_erev.name() : __default_erev,
        __charge.name() : __charge,
        __role.name() : __role
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_Ion', Deprecated_Ion)


# Complex type {http://morphml.org/channelml/schema}OpenState with content type EMPTY
class OpenState (pyxb.binding.basis.complexTypeDefinition):
    """Open state of a gating complex"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'OpenState')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 915, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgchannelmlschema_OpenState_id', pyxb.binding.datatypes.string, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 920, 8)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 920, 8)
    
    id = property(__id.value, __id.set, None, u'Id to use in transition elements when specifying this as the from or to state of the transition.')

    
    # Attribute fraction uses Python identifier fraction
    __fraction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fraction'), 'fraction', '__httpmorphml_orgchannelmlschema_OpenState_fraction', ZeroToOne, unicode_default=u'1')
    __fraction._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 927, 8)
    __fraction._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 927, 8)
    
    fraction = property(__fraction.value, __fraction.set, None, u'The fractional conductance of the gate in this state. Has value 1 if not present')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __fraction.name() : __fraction
    })
_Namespace_cml.addCategoryObject('typeBinding', u'OpenState', OpenState)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_17 (pyxb.binding.basis.complexTypeDefinition):
    """Internal state of the gate, specifying a name, and possibly a fractional contribution. 
                    HHGate or KSGate elements will specify the rate equations, etc. for the gate, referencing this state name."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 949, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_CTD_ANON_2_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 950, 20)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 950, 20)
    
    name = property(__name.value, __name.set, None, None)

    
    # Attribute fraction uses Python identifier fraction
    __fraction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fraction'), 'fraction', '__httpmorphml_orgchannelmlschema_CTD_ANON_2_fraction', ZeroToOne, unicode_default=u'1')
    __fraction._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 951, 20)
    __fraction._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 951, 20)
    
    fraction = property(__fraction.value, __fraction.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __name.name() : __name,
        __fraction.name() : __fraction
    })



# Complex type {http://morphml.org/channelml/schema}Transition with content type EMPTY
class Transition (pyxb.binding.basis.complexTypeDefinition):
    """Transition between states in a GatingComplex"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Transition')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1038, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute from uses Python identifier from_
    __from = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'from'), 'from_', '__httpmorphml_orgchannelmlschema_Transition_from', pyxb.binding.datatypes.string, required=True)
    __from._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 996, 8)
    __from._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 996, 8)
    
    from_ = property(__from.value, __from.set, None, u'Source state of the transition in kinetic scheme. ')

    
    # Attribute to uses Python identifier to
    __to = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'to'), 'to', '__httpmorphml_orgchannelmlschema_Transition_to', pyxb.binding.datatypes.string, required=True)
    __to._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1002, 8)
    __to._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1002, 8)
    
    to = property(__to.value, __to.set, None, u'Target state of the transition in kinetic scheme. ')

    
    # Attribute rate uses Python identifier rate
    __rate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'rate'), 'rate', '__httpmorphml_orgchannelmlschema_Transition_rate', pyxb.binding.datatypes.string)
    __rate._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1018, 8)
    __rate._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1018, 8)
    
    rate = property(__rate.value, __rate.set, None, None)

    
    # Attribute scale uses Python identifier scale
    __scale = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'scale'), 'scale', '__httpmorphml_orgchannelmlschema_Transition_scale', pyxb.binding.datatypes.string)
    __scale._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1019, 8)
    __scale._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1019, 8)
    
    scale = property(__scale.value, __scale.set, None, None)

    
    # Attribute midpoint uses Python identifier midpoint
    __midpoint = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'midpoint'), 'midpoint', '__httpmorphml_orgchannelmlschema_Transition_midpoint', pyxb.binding.datatypes.string)
    __midpoint._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1020, 8)
    __midpoint._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1020, 8)
    
    midpoint = property(__midpoint.value, __midpoint.set, None, None)

    
    # Attribute expr uses Python identifier expr
    __expr = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr'), 'expr', '__httpmorphml_orgchannelmlschema_Transition_expr', pyxb.binding.datatypes.string)
    __expr._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1032, 8)
    __expr._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1032, 8)
    
    expr = property(__expr.value, __expr.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_Transition_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1043, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1043, 8)
    
    name = property(__name.value, __name.set, None, u'Short name to use to refer to the transition, e.g. alpha, beta for forward, backward rates in HH gates')

    
    # Attribute expr_form uses Python identifier expr_form
    __expr_form = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr_form'), 'expr_form', '__httpmorphml_orgchannelmlschema_Transition_expr_form', CoreEquationType, required=True)
    __expr_form._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1051, 8)
    __expr_form._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1051, 8)
    
    expr_form = property(__expr_form.value, __expr_form.set, None, u'Form of expression')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __from.name() : __from,
        __to.name() : __to,
        __rate.name() : __rate,
        __scale.name() : __scale,
        __midpoint.name() : __midpoint,
        __expr.name() : __expr,
        __name.name() : __name,
        __expr_form.name() : __expr_form
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Transition', Transition)


# Complex type {http://morphml.org/channelml/schema}TimeCourse with content type EMPTY
class TimeCourse (pyxb.binding.basis.complexTypeDefinition):
    """Time course of the transition between states in a GatingComplex"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'TimeCourse')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1065, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute from uses Python identifier from_
    __from = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'from'), 'from_', '__httpmorphml_orgchannelmlschema_TimeCourse_from', pyxb.binding.datatypes.string, required=True)
    __from._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 996, 8)
    __from._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 996, 8)
    
    from_ = property(__from.value, __from.set, None, u'Source state of the transition in kinetic scheme. ')

    
    # Attribute to uses Python identifier to
    __to = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'to'), 'to', '__httpmorphml_orgchannelmlschema_TimeCourse_to', pyxb.binding.datatypes.string, required=True)
    __to._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1002, 8)
    __to._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1002, 8)
    
    to = property(__to.value, __to.set, None, u'Target state of the transition in kinetic scheme. ')

    
    # Attribute rate uses Python identifier rate
    __rate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'rate'), 'rate', '__httpmorphml_orgchannelmlschema_TimeCourse_rate', pyxb.binding.datatypes.string)
    __rate._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1018, 8)
    __rate._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1018, 8)
    
    rate = property(__rate.value, __rate.set, None, None)

    
    # Attribute scale uses Python identifier scale
    __scale = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'scale'), 'scale', '__httpmorphml_orgchannelmlschema_TimeCourse_scale', pyxb.binding.datatypes.string)
    __scale._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1019, 8)
    __scale._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1019, 8)
    
    scale = property(__scale.value, __scale.set, None, None)

    
    # Attribute midpoint uses Python identifier midpoint
    __midpoint = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'midpoint'), 'midpoint', '__httpmorphml_orgchannelmlschema_TimeCourse_midpoint', pyxb.binding.datatypes.string)
    __midpoint._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1020, 8)
    __midpoint._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1020, 8)
    
    midpoint = property(__midpoint.value, __midpoint.set, None, None)

    
    # Attribute expr uses Python identifier expr
    __expr = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr'), 'expr', '__httpmorphml_orgchannelmlschema_TimeCourse_expr', pyxb.binding.datatypes.string)
    __expr._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1032, 8)
    __expr._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1032, 8)
    
    expr = property(__expr.value, __expr.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_TimeCourse_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1070, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1070, 8)
    
    name = property(__name.value, __name.set, None, u'Short name to use to refer to the time course e.g. tau')

    
    # Attribute expr_form uses Python identifier expr_form
    __expr_form = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr_form'), 'expr_form', '__httpmorphml_orgchannelmlschema_TimeCourse_expr_form', CoreEquationType, required=True)
    __expr_form._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1078, 8)
    __expr_form._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1078, 8)
    
    expr_form = property(__expr_form.value, __expr_form.set, None, u'Form of expression')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __from.name() : __from,
        __to.name() : __to,
        __rate.name() : __rate,
        __scale.name() : __scale,
        __midpoint.name() : __midpoint,
        __expr.name() : __expr,
        __name.name() : __name,
        __expr_form.name() : __expr_form
    })
_Namespace_cml.addCategoryObject('typeBinding', u'TimeCourse', TimeCourse)


# Complex type {http://morphml.org/channelml/schema}SteadyState with content type EMPTY
class SteadyState (pyxb.binding.basis.complexTypeDefinition):
    """Steady state value of the transition between states in a GatingComplex"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'SteadyState')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1091, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute from uses Python identifier from_
    __from = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'from'), 'from_', '__httpmorphml_orgchannelmlschema_SteadyState_from', pyxb.binding.datatypes.string, required=True)
    __from._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 996, 8)
    __from._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 996, 8)
    
    from_ = property(__from.value, __from.set, None, u'Source state of the transition in kinetic scheme. ')

    
    # Attribute to uses Python identifier to
    __to = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'to'), 'to', '__httpmorphml_orgchannelmlschema_SteadyState_to', pyxb.binding.datatypes.string, required=True)
    __to._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1002, 8)
    __to._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1002, 8)
    
    to = property(__to.value, __to.set, None, u'Target state of the transition in kinetic scheme. ')

    
    # Attribute rate uses Python identifier rate
    __rate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'rate'), 'rate', '__httpmorphml_orgchannelmlschema_SteadyState_rate', pyxb.binding.datatypes.string)
    __rate._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1018, 8)
    __rate._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1018, 8)
    
    rate = property(__rate.value, __rate.set, None, None)

    
    # Attribute scale uses Python identifier scale
    __scale = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'scale'), 'scale', '__httpmorphml_orgchannelmlschema_SteadyState_scale', pyxb.binding.datatypes.string)
    __scale._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1019, 8)
    __scale._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1019, 8)
    
    scale = property(__scale.value, __scale.set, None, None)

    
    # Attribute midpoint uses Python identifier midpoint
    __midpoint = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'midpoint'), 'midpoint', '__httpmorphml_orgchannelmlschema_SteadyState_midpoint', pyxb.binding.datatypes.string)
    __midpoint._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1020, 8)
    __midpoint._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1020, 8)
    
    midpoint = property(__midpoint.value, __midpoint.set, None, None)

    
    # Attribute expr uses Python identifier expr
    __expr = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr'), 'expr', '__httpmorphml_orgchannelmlschema_SteadyState_expr', pyxb.binding.datatypes.string)
    __expr._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1032, 8)
    __expr._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1032, 8)
    
    expr = property(__expr.value, __expr.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_SteadyState_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1096, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1096, 8)
    
    name = property(__name.value, __name.set, None, u'Short name to use to refer to the steady state e.g. inf')

    
    # Attribute expr_form uses Python identifier expr_form
    __expr_form = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr_form'), 'expr_form', '__httpmorphml_orgchannelmlschema_SteadyState_expr_form', CoreEquationType, required=True)
    __expr_form._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1104, 8)
    __expr_form._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1104, 8)
    
    expr_form = property(__expr_form.value, __expr_form.set, None, u'Form of expression')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __from.name() : __from,
        __to.name() : __to,
        __rate.name() : __rate,
        __scale.name() : __scale,
        __midpoint.name() : __midpoint,
        __expr.name() : __expr,
        __name.name() : __name,
        __expr_form.name() : __expr_form
    })
_Namespace_cml.addCategoryObject('typeBinding', u'SteadyState', SteadyState)


# Complex type {http://morphml.org/channelml/schema}ConcFactor with content type EMPTY
class ConcFactor (pyxb.binding.basis.complexTypeDefinition):
    """Specification of the time independent scaling factor for a concentration dependent conductance. This factor will not be used n alpha, beta, etc. but the 
            expression in expr will scale the total conductance at each time step."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ConcFactor')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1200, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute ion uses Python identifier ion
    __ion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'ion'), 'ion', '__httpmorphml_orgchannelmlschema_ConcFactor_ion', pyxb.binding.datatypes.string, required=True)
    __ion._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1205, 8)
    __ion._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1205, 8)
    
    ion = property(__ion.value, __ion.set, None, u'Name of the ion')

    
    # Attribute charge uses Python identifier charge
    __charge = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'charge'), 'charge', '__httpmorphml_orgchannelmlschema_ConcFactor_charge', pyxb.binding.datatypes.integer, unicode_default=u'1')
    __charge._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1210, 8)
    __charge._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1210, 8)
    
    charge = property(__charge.value, __charge.set, None, u'Electrical charge of the ion in question. Assumes charge of 1 if not present')

    
    # Attribute variable_name uses Python identifier variable_name
    __variable_name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'variable_name'), 'variable_name', '__httpmorphml_orgchannelmlschema_ConcFactor_variable_name', pyxb.binding.datatypes.string, required=True)
    __variable_name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1215, 8)
    __variable_name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1215, 8)
    
    variable_name = property(__variable_name.value, __variable_name.set, None, u'How the value of conductance will be expressed in the equations')

    
    # Attribute expr uses Python identifier expr
    __expr = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr'), 'expr', '__httpmorphml_orgchannelmlschema_ConcFactor_expr', pyxb.binding.datatypes.string, required=True)
    __expr._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1220, 8)
    __expr._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1220, 8)
    
    expr = property(__expr.value, __expr.set, None, u'Expression for the time independent multiplicative factor for the concentration dependence')

    
    # Attribute min_conc uses Python identifier min_conc
    __min_conc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'min_conc'), 'min_conc', '__httpmorphml_orgchannelmlschema_ConcFactor_min_conc', ConcentrationValue, required=True)
    __min_conc._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1225, 8)
    __min_conc._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1225, 8)
    
    min_conc = property(__min_conc.value, __min_conc.set, None, u'Minimum expected concentration. May be needed by simulators (e.g. for generating tables)')

    
    # Attribute max_conc uses Python identifier max_conc
    __max_conc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_conc'), 'max_conc', '__httpmorphml_orgchannelmlschema_ConcFactor_max_conc', ConcentrationValue, required=True)
    __max_conc._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1230, 8)
    __max_conc._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1230, 8)
    
    max_conc = property(__max_conc.value, __max_conc.set, None, u'Maximum expected concentration. May be needed by simulators (e.g. for generating tables)')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __ion.name() : __ion,
        __charge.name() : __charge,
        __variable_name.name() : __variable_name,
        __expr.name() : __expr,
        __min_conc.name() : __min_conc,
        __max_conc.name() : __max_conc
    })
_Namespace_cml.addCategoryObject('typeBinding', u'ConcFactor', ConcFactor)


# Complex type {http://morphml.org/channelml/schema}ConcDependence with content type EMPTY
class ConcDependence (pyxb.binding.basis.complexTypeDefinition):
    """Specification of the factor to use in the concentration dependence of the rate expressions of a gate"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'ConcDependence')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1238, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgchannelmlschema_ConcDependence_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1242, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1242, 8)
    
    name = property(__name.value, __name.set, None, u'Name of substance, just for reference')

    
    # Attribute ion uses Python identifier ion
    __ion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'ion'), 'ion', '__httpmorphml_orgchannelmlschema_ConcDependence_ion', pyxb.binding.datatypes.string, required=True)
    __ion._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1247, 8)
    __ion._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1247, 8)
    
    ion = property(__ion.value, __ion.set, None, u'Name of the ion')

    
    # Attribute charge uses Python identifier charge
    __charge = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'charge'), 'charge', '__httpmorphml_orgchannelmlschema_ConcDependence_charge', pyxb.binding.datatypes.integer, unicode_default=u'1')
    __charge._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1252, 8)
    __charge._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1252, 8)
    
    charge = property(__charge.value, __charge.set, None, u'Electrical charge of the ion in question. Assumes charge of 1 if not present')

    
    # Attribute variable_name uses Python identifier variable_name
    __variable_name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'variable_name'), 'variable_name', '__httpmorphml_orgchannelmlschema_ConcDependence_variable_name', pyxb.binding.datatypes.string, required=True)
    __variable_name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1257, 8)
    __variable_name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1257, 8)
    
    variable_name = property(__variable_name.value, __variable_name.set, None, u'How the value of conductance will be expressed in the rate equations')

    
    # Attribute min_conc uses Python identifier min_conc
    __min_conc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'min_conc'), 'min_conc', '__httpmorphml_orgchannelmlschema_ConcDependence_min_conc', ConcentrationValue, required=True)
    __min_conc._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1262, 8)
    __min_conc._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1262, 8)
    
    min_conc = property(__min_conc.value, __min_conc.set, None, u'Minimum expected concentration. Quite likely to be needed by simulators (e.g. for generating tables)')

    
    # Attribute max_conc uses Python identifier max_conc
    __max_conc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_conc'), 'max_conc', '__httpmorphml_orgchannelmlschema_ConcDependence_max_conc', ConcentrationValue, required=True)
    __max_conc._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1267, 8)
    __max_conc._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1267, 8)
    
    max_conc = property(__max_conc.value, __max_conc.set, None, u'Maximum expected concentration. Quite likely to be needed by simulators (e.g. for generating tables)')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __name.name() : __name,
        __ion.name() : __ion,
        __charge.name() : __charge,
        __variable_name.name() : __variable_name,
        __min_conc.name() : __min_conc,
        __max_conc.name() : __max_conc
    })
_Namespace_cml.addCategoryObject('typeBinding', u'ConcDependence', ConcDependence)


# Complex type {http://morphml.org/channelml/schema}Deprecated_AkdEquation with content type ELEMENT_ONLY
class Deprecated_AkdEquation (Deprecated_RateConstantEqn):
    """Definition of a type of rate constant equation which takes parameters A, k, d 
            and maps to either exponential, sigmoidal or linoidal."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'Deprecated_AkdEquation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1366, 4)
    _ElementMap = Deprecated_RateConstantEqn._ElementMap.copy()
    _AttributeMap = Deprecated_RateConstantEqn._AttributeMap.copy()
    # Base type is Deprecated_RateConstantEqn
    
    # Element parameter ({http://morphml.org/channelml/schema}parameter) inherited from {http://morphml.org/channelml/schema}Deprecated_RateConstantEqn
    
    # Attribute type is restricted from parent
    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'type'), 'type', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqn_type', Deprecated_CoreEquationType, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1376, 16)
    __type._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1376, 16)
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute expr is restricted from parent
    
    # Attribute expr uses Python identifier expr
    __expr = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'expr'), 'expr', '__httpmorphml_orgchannelmlschema_Deprecated_RateConstantEqn_expr', pyxb.binding.datatypes.string)
    __expr._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1377, 16)
    __expr._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1377, 16)
    
    expr = property(__expr.value, __expr.set, None, u"Note: this expression is has been useful to include when the type is, e.g. linoid, to remind users of the form of the equation.\n                        However, it's use should be discouraged, as it could be assumed that changing this attribute can change the form of the equation (as for generic_equation_hh).\n                        It's better to include the form of the equation as a comment, as in the examples. This attribute may be removed in v2.0")

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __type.name() : __type,
        __expr.name() : __expr
    })
_Namespace_cml.addCategoryObject('typeBinding', u'Deprecated_AkdEquation', Deprecated_AkdEquation)


# Complex type {http://morphml.org/channelml/schema}DecayingPoolModel with content type ELEMENT_ONLY
class DecayingPoolModel (pyxb.binding.basis.complexTypeDefinition):
    """Element for parameters in a decaying pool model of ion concentration (e.g. calcium pool)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'DecayingPoolModel')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1469, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}resting_conc uses Python identifier resting_conc
    __resting_conc = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'resting_conc'), 'resting_conc', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_httpmorphml_orgchannelmlschemaresting_conc', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1474, 12), )

    
    resting_conc = property(__resting_conc.value, __resting_conc.set, None, u'Resting concentration of ion. NOTE: In v2.0 this element will be removed. Attribute resting_conc will be used instead.')

    
    # Element {http://morphml.org/channelml/schema}decay_constant uses Python identifier decay_constant
    __decay_constant = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'decay_constant'), 'decay_constant', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_httpmorphml_orgchannelmlschemadecay_constant', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1480, 16), )

    
    decay_constant = property(__decay_constant.value, __decay_constant.set, None, u'Exponential decay time of pool. NOTE: In v2.0 this element will be removed. Attribute decay_constant will be used instead.')

    
    # Element {http://morphml.org/channelml/schema}inv_decay_constant uses Python identifier inv_decay_constant
    __inv_decay_constant = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'inv_decay_constant'), 'inv_decay_constant', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_httpmorphml_orgchannelmlschemainv_decay_constant', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1485, 16), )

    
    inv_decay_constant = property(__inv_decay_constant.value, __inv_decay_constant.set, None, u'Reciprocal of exponential decay time constant of pool')

    
    # Element {http://morphml.org/channelml/schema}ceiling uses Python identifier ceiling
    __ceiling = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'ceiling'), 'ceiling', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_httpmorphml_orgchannelmlschemaceiling', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1491, 12), )

    
    ceiling = property(__ceiling.value, __ceiling.set, None, u'The maximum concentration which the ion pool should be allowed get to. NOTE: In v2.0 this element will be removed. Attribute ceiling will be used instead.')

    
    # Element {http://morphml.org/channelml/schema}pool_volume_info uses Python identifier pool_volume_info
    __pool_volume_info = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'pool_volume_info'), 'pool_volume_info', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_httpmorphml_orgchannelmlschemapool_volume_info', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1497, 16), )

    
    pool_volume_info = property(__pool_volume_info.value, __pool_volume_info.set, None, None)

    
    # Element {http://morphml.org/channelml/schema}fixed_pool_info uses Python identifier fixed_pool_info
    __fixed_pool_info = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'fixed_pool_info'), 'fixed_pool_info', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_httpmorphml_orgchannelmlschemafixed_pool_info', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1498, 16), )

    
    fixed_pool_info = property(__fixed_pool_info.value, __fixed_pool_info.set, None, None)

    
    # Attribute resting_conc uses Python identifier resting_conc_
    __resting_conc_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'resting_conc'), 'resting_conc_', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_resting_conc', ConcentrationValue)
    __resting_conc_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1502, 8)
    __resting_conc_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1502, 8)
    
    resting_conc_ = property(__resting_conc_.value, __resting_conc_.set, None, u'Resting concentration of ion. NOTE: In v2.0 the option for a resting_conc element will be removed. Attribute resting_conc will be required instead.')

    
    # Attribute decay_constant uses Python identifier decay_constant_
    __decay_constant_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'decay_constant'), 'decay_constant_', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_decay_constant', TimeConstantValue)
    __decay_constant_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1508, 8)
    __decay_constant_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1508, 8)
    
    decay_constant_ = property(__decay_constant_.value, __decay_constant_.set, None, u'Exponential decay time of pool. Either decay_constant or inv_decay_constant must be included. NOTE: In v2.0 the option for \n                a decay_constant/inv_decay_constant element will be removed. Attribute decay_constant/inv_decay_constant will be used instead.')

    
    # Attribute inv_decay_constant uses Python identifier inv_decay_constant_
    __inv_decay_constant_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'inv_decay_constant'), 'inv_decay_constant_', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_inv_decay_constant', InvTimeConstantValue)
    __inv_decay_constant_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1515, 8)
    __inv_decay_constant_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1515, 8)
    
    inv_decay_constant_ = property(__inv_decay_constant_.value, __inv_decay_constant_.set, None, u'Reciprocal of exponential decay time of pool. Either decay_constant or inv_decay_constant must be included. NOTE: In v2.0 the option for \n                a decay_constant/inv_decay_constant element will be removed. Attribute decay_constant/inv_decay_constant will be used instead.')

    
    # Attribute ceiling uses Python identifier ceiling_
    __ceiling_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'ceiling'), 'ceiling_', '__httpmorphml_orgchannelmlschema_DecayingPoolModel_ceiling', ConcentrationValue)
    __ceiling_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1522, 8)
    __ceiling_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1522, 8)
    
    ceiling_ = property(__ceiling_.value, __ceiling_.set, None, u'The maximum concentration which the ion pool should be allowed get to. NOTE: In v2.0 the option for \n                a ceiling element will be removed. Attribute ceiling will be used instead.')

    _ElementMap.update({
        __resting_conc.name() : __resting_conc,
        __decay_constant.name() : __decay_constant,
        __inv_decay_constant.name() : __inv_decay_constant,
        __ceiling.name() : __ceiling,
        __pool_volume_info.name() : __pool_volume_info,
        __fixed_pool_info.name() : __fixed_pool_info
    })
    _AttributeMap.update({
        __resting_conc_.name() : __resting_conc_,
        __decay_constant_.name() : __decay_constant_,
        __inv_decay_constant_.name() : __inv_decay_constant_,
        __ceiling_.name() : __ceiling_
    })
_Namespace_cml.addCategoryObject('typeBinding', u'DecayingPoolModel', DecayingPoolModel)


# Complex type {http://morphml.org/channelml/schema}PoolVolumeInfo with content type ELEMENT_ONLY
class PoolVolumeInfo (pyxb.binding.basis.complexTypeDefinition):
    """Information on the volume of the ion pool"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'PoolVolumeInfo')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1533, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/channelml/schema}shell_thickness uses Python identifier shell_thickness
    __shell_thickness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'shell_thickness'), 'shell_thickness', '__httpmorphml_orgchannelmlschema_PoolVolumeInfo_httpmorphml_orgchannelmlschemashell_thickness', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1539, 12), )

    
    shell_thickness = property(__shell_thickness.value, __shell_thickness.set, None, u'The volume of the pool is calculated from the thickness of the shell inside\n                    the membrane. This will have to be multiplied by the surface area of the relevant compartment. NOTE: In v2.0 the option for \n                    a shell_thickness element will be removed. Attribute shell_thickness will be used instead.')

    
    # Attribute shell_thickness uses Python identifier shell_thickness_
    __shell_thickness_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'shell_thickness'), 'shell_thickness_', '__httpmorphml_orgchannelmlschema_PoolVolumeInfo_shell_thickness', LengthValue)
    __shell_thickness_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1548, 8)
    __shell_thickness_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1548, 8)
    
    shell_thickness_ = property(__shell_thickness_.value, __shell_thickness_.set, None, u'The volume of the pool is calculated from the thickness of the shell inside\n                    the membrane. This will have to be multiplied by the surface area of the relevant compartment. NOTE: In v2.0 the option for \n                a shell_thickness element will be removed. Attribute shell_thickness will be used instead.')

    _ElementMap.update({
        __shell_thickness.name() : __shell_thickness
    })
    _AttributeMap.update({
        __shell_thickness_.name() : __shell_thickness_
    })
_Namespace_cml.addCategoryObject('typeBinding', u'PoolVolumeInfo', PoolVolumeInfo)


# Complex type {http://morphml.org/metadata/schema}Manifold with content type ELEMENT_ONLY
class Manifold (Points):
    """A surface."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Manifold')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 124, 4)
    _ElementMap = Points._ElementMap.copy()
    _AttributeMap = Points._AttributeMap.copy()
    # Base type is Points
    
    # Element point ({http://morphml.org/metadata/schema}point) inherited from {http://morphml.org/metadata/schema}Points
    
    # Attribute name inherited from {http://morphml.org/metadata/schema}Points
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Manifold', Manifold)


# Complex type {http://morphml.org/metadata/schema}Polygon with content type ELEMENT_ONLY
class Polygon (Points):
    """A closed structure represented by a list of points where the first point connects with the last point."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Polygon')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 137, 4)
    _ElementMap = Points._ElementMap.copy()
    _AttributeMap = Points._AttributeMap.copy()
    # Base type is Points
    
    # Element point ({http://morphml.org/metadata/schema}point) inherited from {http://morphml.org/metadata/schema}Points
    
    # Attribute name inherited from {http://morphml.org/metadata/schema}Points
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Polygon', Polygon)


# Complex type {http://morphml.org/metadata/schema}Status with content type ELEMENT_ONLY
class Status (pyxb.binding.basis.complexTypeDefinition):
    """Status element giving the stability state of files and some extra comments."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_meta, u'Status')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 562, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}comment uses Python identifier comment
    __comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), 'comment', '__httpmorphml_orgmetadataschema_Status_httpmorphml_orgmetadataschemacomment', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 569, 12), )

    
    comment = property(__comment.value, __comment.set, None, u'A comment on the current status. Not necessarily signalling a problem.')

    
    # Element {http://morphml.org/metadata/schema}issue uses Python identifier issue
    __issue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'issue'), 'issue', '__httpmorphml_orgmetadataschema_Status_httpmorphml_orgmetadataschemaissue', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 574, 12), )

    
    issue = property(__issue.value, __issue.set, None, u'An issue which need addressing')

    
    # Element {http://morphml.org/metadata/schema}contributor uses Python identifier contributor
    __contributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'contributor'), 'contributor', '__httpmorphml_orgmetadataschema_Status_httpmorphml_orgmetadataschemacontributor', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 579, 12), )

    
    contributor = property(__contributor.value, __contributor.set, None, u'Who added the comments?')

    
    # Attribute value uses Python identifier value_
    __value = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value'), 'value_', '__httpmorphml_orgmetadataschema_Status_value', StatusValue)
    __value._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 585, 8)
    __value._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 585, 8)
    
    value_ = property(__value.value, __value.set, None, u'Currently an enum value of status/in progress/etc.')

    _ElementMap.update({
        __comment.name() : __comment,
        __issue.name() : __issue,
        __contributor.name() : __contributor
    })
    _AttributeMap.update({
        __value.name() : __value
    })
_Namespace_meta.addCategoryObject('typeBinding', u'Status', Status)


# Complex type {http://morphml.org/morphml/schema}Morphology with content type ELEMENT_ONLY
class Morphology (pyxb.binding.basis.complexTypeDefinition):
    """The main element which details the neuronal morphology. Cells, various histological features, and
            properties associated with the data can be contained in this element"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Morphology')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 29, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}cells uses Python identifier cells
    __cells = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'cells'), 'cells', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmorphmlschemacells', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 37, 12), )

    
    cells = property(__cells.value, __cells.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}features uses Python identifier features
    __features = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'features'), 'features', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmorphmlschemafeatures', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 39, 12), )

    
    features = property(__features.value, __features.set, None, u'Collection of all extracellular histological features.')

    
    # Element {http://morphml.org/morphml/schema}propertyDetails uses Python identifier propertyDetails
    __propertyDetails = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'propertyDetails'), 'propertyDetails', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmorphmlschemapropertyDetails', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 63, 12), )

    
    propertyDetails = property(__propertyDetails.value, __propertyDetails.set, None, u'Collection of all PropertyDetails for this instance.')

    
    # Element {http://morphml.org/morphml/schema}groupDetails uses Python identifier groupDetails
    __groupDetails = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'groupDetails'), 'groupDetails', '__httpmorphml_orgmorphmlschema_Morphology_httpmorphml_orgmorphmlschemagroupDetails', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 78, 12), )

    
    groupDetails = property(__groupDetails.value, __groupDetails.set, None, u'Collection of all GroupDetails for this instance.')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmorphmlschema_Morphology_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 94, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 94, 8)
    
    name = property(__name.value, __name.set, None, u'An optional name which can be given to the morphology')

    
    # Attribute lengthUnits uses Python identifier lengthUnits
    __lengthUnits = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'lengthUnits'), 'lengthUnits', '__httpmorphml_orgmorphmlschema_Morphology_lengthUnits', LengthUnits)
    __lengthUnits._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 100, 8)
    __lengthUnits._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 100, 8)
    
    lengthUnits = property(__lengthUnits.value, __lengthUnits.set, None, u'Unit of all length measurements. Usually has the value <b>micrometer</b>. Note: length_units will be the preferred form in v2.0')

    
    # Attribute length_units uses Python identifier length_units
    __length_units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'length_units'), 'length_units', '__httpmorphml_orgmorphmlschema_Morphology_length_units', LengthUnits)
    __length_units._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 106, 8)
    __length_units._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 106, 8)
    
    length_units = property(__length_units.value, __length_units.set, None, u'Unit of all length measurements. Usually has the value <b>micrometer</b>. Note: length_units will be the preferred form in v2.0')

    
    # Attribute volumeUnits uses Python identifier volumeUnits
    __volumeUnits = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'volumeUnits'), 'volumeUnits', '__httpmorphml_orgmorphmlschema_Morphology_volumeUnits', VolumeUnits, unicode_default=u'cubic_millimeter')
    __volumeUnits._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 112, 8)
    __volumeUnits._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 112, 8)
    
    volumeUnits = property(__volumeUnits.value, __volumeUnits.set, None, u'Unit of all volume measurements.')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __cells.name() : __cells,
        __features.name() : __features,
        __propertyDetails.name() : __propertyDetails,
        __groupDetails.name() : __groupDetails
    })
    _AttributeMap.update({
        __name.name() : __name,
        __lengthUnits.name() : __lengthUnits,
        __length_units.name() : __length_units,
        __volumeUnits.name() : __volumeUnits
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Morphology', Morphology)


# Complex type {http://morphml.org/morphml/schema}Segment with content type ELEMENT_ONLY
class Segment (pyxb.binding.basis.complexTypeDefinition):
    """Defines the smallest unit within a possibly branching structure, such as a segment of a dendrite or axon. The parent attribute is used to define connectivity. A segment would be mapped to a compartment in a compartmental modelling application such as GENESIS"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Segment')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 276, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/morphml/schema}proximal uses Python identifier proximal
    __proximal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal'), 'proximal', '__httpmorphml_orgmorphmlschema_Segment_httpmorphml_orgmorphmlschemaproximal', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 281, 12), )

    
    proximal = property(__proximal.value, __proximal.set, None, u'The start point (and diameter) of the segment. If absent, it is assumed that the distal point of the parent is the start point of this segment.')

    
    # Element {http://morphml.org/morphml/schema}distal uses Python identifier distal
    __distal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal'), 'distal', '__httpmorphml_orgmorphmlschema_Segment_httpmorphml_orgmorphmlschemadistal', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 287, 12), )

    
    distal = property(__distal.value, __distal.set, None, u'The end point (and diameter) of the segment. Note if the 3D location of the distal point is the same as the proximal point, the segment is assumed to be spherical.')

    
    # Element {http://morphml.org/morphml/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_Segment_httpmorphml_orgmorphmlschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 293, 12), )

    
    properties = property(__properties.value, __properties.set, None, u'Some optional properties associated with the segment.')

    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgmorphmlschema_Segment_id', SegmentIdInCell, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 300, 8)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 300, 8)
    
    id = property(__id.value, __id.set, None, u'The ID of the segment, which should be unique within the cell.')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmorphmlschema_Segment_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 306, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 306, 8)
    
    name = property(__name.value, __name.set, None, u'As many simulators use a string to identify the compartments, etc. a unique name can be given to the segment.')

    
    # Attribute parent uses Python identifier parent
    __parent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'parent'), 'parent', '__httpmorphml_orgmorphmlschema_Segment_parent', SegmentIdInCell)
    __parent._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 312, 8)
    __parent._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 312, 8)
    
    parent = property(__parent.value, __parent.set, None, u'Used to indicate logical connectivity between segments. Note that there is no requirement that the end point of this parent segment is equal to the start point of this segment.')

    
    # Attribute cable uses Python identifier cable
    __cable = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cable'), 'cable', '__httpmorphml_orgmorphmlschema_Segment_cable', pyxb.binding.datatypes.nonNegativeInteger)
    __cable._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 318, 8)
    __cable._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 318, 8)
    
    cable = property(__cable.value, __cable.set, None, u'The cable ID of which this segment is part. Numerous segments will make up one cable, and it is assumed these are connected electrically.')

    _ElementMap.update({
        __proximal.name() : __proximal,
        __distal.name() : __distal,
        __properties.name() : __properties
    })
    _AttributeMap.update({
        __id.name() : __id,
        __name.name() : __name,
        __parent.name() : __parent,
        __cable.name() : __cable
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Segment', Segment)


# Complex type {http://morphml.org/morphml/schema}Cable with content type ELEMENT_ONLY
class Cable (pyxb.binding.basis.complexTypeDefinition):
    """Definition of a cable. A cable is a non-branching group of connected segments. A cable would be mapped to a section in a cable modelling based simulator such as NEURON"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Cable')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 327, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgmorphmlschema_Cable_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgmorphmlschema_Cable_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgmorphmlschema_Cable_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgmorphmlschema_Cable_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgmorphmlschema_Cable_id', pyxb.binding.datatypes.nonNegativeInteger, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 334, 8)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 334, 8)
    
    id = property(__id.value, __id.set, None, u'ID of the cable, unique within this cell')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgmorphmlschema_Cable_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 339, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 339, 8)
    
    name = property(__name.value, __name.set, None, u'As many simulators use a string to identify the sections, etc. a unique name can be given to the segment.')

    
    # Attribute parent uses Python identifier parent
    __parent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'parent'), 'parent', '__httpmorphml_orgmorphmlschema_Cable_parent', pyxb.binding.datatypes.nonNegativeInteger)
    __parent._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 344, 8)
    __parent._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 344, 8)
    
    parent = property(__parent.value, __parent.set, None, u'A cable ID. A way to connect cables logically.')

    
    # Attribute fractAlongParent uses Python identifier fractAlongParent
    __fractAlongParent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fractAlongParent'), 'fractAlongParent', '__httpmorphml_orgmorphmlschema_Cable_fractAlongParent', ZeroToOne)
    __fractAlongParent._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 349, 8)
    __fractAlongParent._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 349, 8)
    
    fractAlongParent = property(__fractAlongParent.value, __fractAlongParent.set, None, u"Approximate location of this section's proximal point along the parent cable. NOTE: this attribute will be removed in v2.0!! Use fract_along_parent instead.\n            Changed for consistency with ChannelML and NetworkML naming conventions.")

    
    # Attribute fract_along_parent uses Python identifier fract_along_parent
    __fract_along_parent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fract_along_parent'), 'fract_along_parent', '__httpmorphml_orgmorphmlschema_Cable_fract_along_parent', ZeroToOne)
    __fract_along_parent._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 355, 8)
    __fract_along_parent._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 355, 8)
    
    fract_along_parent = property(__fract_along_parent.value, __fract_along_parent.set, None, u'Connection location of this section\'s proximal point along the parent cable. \n                Normally this could be determined by the 3D points, but this option is needed as many reconstructed neurons have dendrites "floating in space", possibly due to drift\n                of the slice. In this case the fract_along_parent determines electrical connectivity, and it is up to the loading application/its user to decide to ignore the discrepancy, \n                move the dendrite or fill in an extra section.\n                NOTE: this attribute will be required in v2.0!! Don\'t use fractAlongParent anymore.\n            Changed for consistency with ChannelML and NetworkML naming conventions.')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __id.name() : __id,
        __name.name() : __name,
        __parent.name() : __parent,
        __fractAlongParent.name() : __fractAlongParent,
        __fract_along_parent.name() : __fract_along_parent
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Cable', Cable)


# Complex type {http://morphml.org/morphml/schema}Spine with content type ELEMENT_ONLY
class Spine (pyxb.binding.basis.complexTypeDefinition):
    """A spine with location, shape, and direction."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Spine')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 475, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/morphml/schema}proximal uses Python identifier proximal
    __proximal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal'), 'proximal', '__httpmorphml_orgmorphmlschema_Spine_httpmorphml_orgmorphmlschemaproximal', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 480, 12), )

    
    proximal = property(__proximal.value, __proximal.set, None, None)

    
    # Element {http://morphml.org/morphml/schema}distal uses Python identifier distal
    __distal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal'), 'distal', '__httpmorphml_orgmorphmlschema_Spine_httpmorphml_orgmorphmlschemadistal', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 481, 12), )

    
    distal = property(__distal.value, __distal.set, None, None)

    
    # Attribute parent uses Python identifier parent
    __parent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'parent'), 'parent', '__httpmorphml_orgmorphmlschema_Spine_parent', SegmentIdInCell)
    __parent._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 483, 8)
    __parent._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 483, 8)
    
    parent = property(__parent.value, __parent.set, None, u'The segment with which this spine is associated.')

    
    # Attribute length uses Python identifier length
    __length = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'length'), 'length', '__httpmorphml_orgmorphmlschema_Spine_length', pyxb.binding.datatypes.double)
    __length._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 488, 8)
    __length._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 488, 8)
    
    length = property(__length.value, __length.set, None, None)

    
    # Attribute volume uses Python identifier volume
    __volume = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'volume'), 'volume', '__httpmorphml_orgmorphmlschema_Spine_volume', pyxb.binding.datatypes.double)
    __volume._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 489, 8)
    __volume._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 489, 8)
    
    volume = property(__volume.value, __volume.set, None, None)

    
    # Attribute shape uses Python identifier shape
    __shape = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'shape'), 'shape', '__httpmorphml_orgmorphmlschema_Spine_shape', SpineShape)
    __shape._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 490, 8)
    __shape._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 490, 8)
    
    shape = property(__shape.value, __shape.set, None, None)

    _ElementMap.update({
        __proximal.name() : __proximal,
        __distal.name() : __distal
    })
    _AttributeMap.update({
        __parent.name() : __parent,
        __length.name() : __length,
        __volume.name() : __volume,
        __shape.name() : __shape
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Spine', Spine)


# Complex type {http://morphml.org/morphml/schema}FreePoints with content type ELEMENT_ONLY
class FreePoints (Points):
    """A set of varicosities or synaptic connections."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'FreePoints')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 495, 4)
    _ElementMap = Points._ElementMap.copy()
    _AttributeMap = Points._AttributeMap.copy()
    # Base type is Points
    
    # Element point ({http://morphml.org/metadata/schema}point) inherited from {http://morphml.org/metadata/schema}Points
    
    # Attribute name inherited from {http://morphml.org/metadata/schema}Points
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_Namespace_mml.addCategoryObject('typeBinding', u'FreePoints', FreePoints)


# Complex type {http://morphml.org/morphml/schema}Path with content type ELEMENT_ONLY
class Path (Points):
    """Possibly branching histological structures."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_mml, u'Path')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 506, 4)
    _ElementMap = Points._ElementMap.copy()
    _AttributeMap = Points._AttributeMap.copy()
    # Base type is Points
    
    # Element point ({http://morphml.org/metadata/schema}point) inherited from {http://morphml.org/metadata/schema}Points
    
    # Attribute name inherited from {http://morphml.org/metadata/schema}Points
    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgmorphmlschema_Path_id', pyxb.binding.datatypes.nonNegativeInteger, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 512, 16)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 512, 16)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute parent uses Python identifier parent
    __parent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'parent'), 'parent', '__httpmorphml_orgmorphmlschema_Path_parent', pyxb.binding.datatypes.nonNegativeInteger)
    __parent._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 513, 16)
    __parent._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 513, 16)
    
    parent = property(__parent.value, __parent.set, None, u'A path id. A way to connect this path to another.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __id.name() : __id,
        __parent.name() : __parent
    })
_Namespace_mml.addCategoryObject('typeBinding', u'Path', Path)


# Complex type {http://morphml.org/networkml/schema}NetworkML with content type ELEMENT_ONLY
class NetworkML (pyxb.binding.basis.complexTypeDefinition):
    """The main elements which make up a NetworkML compliant document. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'NetworkML')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 52, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_NetworkML_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_NetworkML_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_NetworkML_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_NetworkML_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}populations uses Python identifier populations
    __populations = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'populations'), 'populations', '__httpmorphml_orgnetworkmlschema_NetworkML_httpmorphml_orgnetworkmlschemapopulations', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 95, 17), )

    
    populations = property(__populations.value, __populations.set, None, u"The least that's needed in a network is a population of cells...")

    
    # Element {http://morphml.org/networkml/schema}projections uses Python identifier projections
    __projections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'projections'), 'projections', '__httpmorphml_orgnetworkmlschema_NetworkML_httpmorphml_orgnetworkmlschemaprojections', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16), )

    
    projections = property(__projections.value, __projections.set, None, u'In theory there can be no projections, if the file is intended only to specify positions')

    
    # Element {http://morphml.org/networkml/schema}inputs uses Python identifier inputs
    __inputs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'inputs'), 'inputs', '__httpmorphml_orgnetworkmlschema_NetworkML_httpmorphml_orgnetworkmlschemainputs', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16), )

    
    inputs = property(__inputs.value, __inputs.set, None, u'No inputs need be specified')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgnetworkmlschema_NetworkML_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 62, 12)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 62, 12)
    
    name = property(__name.value, __name.set, None, None)

    
    # Attribute lengthUnits uses Python identifier lengthUnits
    __lengthUnits = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'lengthUnits'), 'lengthUnits', '__httpmorphml_orgnetworkmlschema_NetworkML_lengthUnits', LengthUnits)
    __lengthUnits._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 65, 8)
    __lengthUnits._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 65, 8)
    
    lengthUnits = property(__lengthUnits.value, __lengthUnits.set, None, u'Unit of all length measurements. Usually has the value <b>micrometer</b>. Note: length_units will be the preferred form in v2.0')

    
    # Attribute length_units uses Python identifier length_units
    __length_units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'length_units'), 'length_units', '__httpmorphml_orgnetworkmlschema_NetworkML_length_units', LengthUnits)
    __length_units._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 71, 8)
    __length_units._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 71, 8)
    
    length_units = property(__length_units.value, __length_units.set, None, u'Unit of all length measurements. Usually has the value <b>micrometer</b>. Note: length_units will be the preferred form in v2.0')

    
    # Attribute volumeUnits uses Python identifier volumeUnits
    __volumeUnits = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'volumeUnits'), 'volumeUnits', '__httpmorphml_orgnetworkmlschema_NetworkML_volumeUnits', VolumeUnits, unicode_default=u'cubic_millimeter')
    __volumeUnits._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 77, 12)
    __volumeUnits._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 77, 12)
    
    volumeUnits = property(__volumeUnits.value, __volumeUnits.set, None, u'Unit of all volume measurements.')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __populations.name() : __populations,
        __projections.name() : __projections,
        __inputs.name() : __inputs
    })
    _AttributeMap.update({
        __name.name() : __name,
        __lengthUnits.name() : __lengthUnits,
        __length_units.name() : __length_units,
        __volumeUnits.name() : __volumeUnits
    })
_Namespace_net.addCategoryObject('typeBinding', u'NetworkML', NetworkML)


# Complex type {http://morphml.org/networkml/schema}Projections with content type ELEMENT_ONLY
class Projections (pyxb.binding.basis.complexTypeDefinition):
    """The list of projections from one cell population to another"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Projections')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 129, 9)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Projections_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Projections_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Projections_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Projections_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}projection uses Python identifier projection
    __projection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'projection'), 'projection', '__httpmorphml_orgnetworkmlschema_Projections_httpmorphml_orgnetworkmlschemaprojection', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 135, 16), )

    
    projection = property(__projection.value, __projection.set, None, None)

    
    # Attribute units uses Python identifier units
    __units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'units'), 'units', '__httpmorphml_orgnetworkmlschema_Projections_units', Units, required=True)
    __units._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 138, 12)
    __units._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 138, 12)
    
    units = property(__units.value, __units.set, None, u'Unit system of all quantities in the projection descriptions, e.g. synaptic time constants')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __projection.name() : __projection
    })
    _AttributeMap.update({
        __units.name() : __units
    })
_Namespace_net.addCategoryObject('typeBinding', u'Projections', Projections)


# Complex type {http://morphml.org/networkml/schema}Inputs with content type ELEMENT_ONLY
class Inputs (pyxb.binding.basis.complexTypeDefinition):
    """The list of electrical inputs into the cells. This should be extended to allow voltage clamp inputs..."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Inputs')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 148, 9)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Inputs_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Inputs_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Inputs_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Inputs_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}input uses Python identifier input
    __input = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'input'), 'input', '__httpmorphml_orgnetworkmlschema_Inputs_httpmorphml_orgnetworkmlschemainput', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 154, 16), )

    
    input = property(__input.value, __input.set, None, None)

    
    # Attribute units uses Python identifier units
    __units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'units'), 'units', '__httpmorphml_orgnetworkmlschema_Inputs_units', Units, required=True)
    __units._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 157, 12)
    __units._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 157, 12)
    
    units = property(__units.value, __units.set, None, u'Unit system of all quantities in the input description, e.g. input current amplitudes')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __input.name() : __input
    })
    _AttributeMap.update({
        __units.name() : __units
    })
_Namespace_net.addCategoryObject('typeBinding', u'Inputs', Inputs)


# Complex type {http://morphml.org/networkml/schema}PulseInput with content type EMPTY
class PulseInput (pyxb.binding.basis.complexTypeDefinition):
    """A single input pulse. Note: this should be changed to allow easier specifications of
                                  pulse trains, input protocols, etc."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'PulseInput')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 191, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute delay uses Python identifier delay
    __delay = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'delay'), 'delay', '__httpmorphml_orgnetworkmlschema_PulseInput_delay', TimeValue, required=True)
    __delay._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 197, 16)
    __delay._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 197, 16)
    
    delay = property(__delay.value, __delay.set, None, None)

    
    # Attribute duration uses Python identifier duration
    __duration = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'duration'), 'duration', '__httpmorphml_orgnetworkmlschema_PulseInput_duration', TimeValue, required=True)
    __duration._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 198, 16)
    __duration._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 198, 16)
    
    duration = property(__duration.value, __duration.set, None, None)

    
    # Attribute amplitude uses Python identifier amplitude
    __amplitude = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'amplitude'), 'amplitude', '__httpmorphml_orgnetworkmlschema_PulseInput_amplitude', CurrentValue, required=True)
    __amplitude._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 199, 16)
    __amplitude._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 199, 16)
    
    amplitude = property(__amplitude.value, __amplitude.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __delay.name() : __delay,
        __duration.name() : __duration,
        __amplitude.name() : __amplitude
    })
_Namespace_net.addCategoryObject('typeBinding', u'PulseInput', PulseInput)


# Complex type {http://morphml.org/networkml/schema}RandomStim with content type EMPTY
class RandomStim (pyxb.binding.basis.complexTypeDefinition):
    """A random stimulation at a specific frequency. Note: can be interpreted differently by different simulators!!"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'RandomStim')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 203, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute frequency uses Python identifier frequency
    __frequency = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frequency'), 'frequency', '__httpmorphml_orgnetworkmlschema_RandomStim_frequency', FrequencyValue, required=True)
    __frequency._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 208, 16)
    __frequency._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 208, 16)
    
    frequency = property(__frequency.value, __frequency.set, None, None)

    
    # Attribute synaptic_mechanism uses Python identifier synaptic_mechanism
    __synaptic_mechanism = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'synaptic_mechanism'), 'synaptic_mechanism', '__httpmorphml_orgnetworkmlschema_RandomStim_synaptic_mechanism', pyxb.binding.datatypes.string, required=True)
    __synaptic_mechanism._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 209, 16)
    __synaptic_mechanism._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 209, 16)
    
    synaptic_mechanism = property(__synaptic_mechanism.value, __synaptic_mechanism.set, None, u"The name of a synaptic mechanism which will provides the conductance change.\n                        This will be fired once every 'spike' at the given frequency")

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __frequency.name() : __frequency,
        __synaptic_mechanism.name() : __synaptic_mechanism
    })
_Namespace_net.addCategoryObject('typeBinding', u'RandomStim', RandomStim)


# Complex type {http://morphml.org/networkml/schema}RandomStimInstance with content type EMPTY
class RandomStimInstance (pyxb.binding.basis.complexTypeDefinition):
    """Instance/site specific random stimulation at a specific frequency. Note: can be interpreted differently by different simulators!!"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'RandomStimInstance')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 218, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute frequency uses Python identifier frequency
    __frequency = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frequency'), 'frequency', '__httpmorphml_orgnetworkmlschema_RandomStimInstance_frequency', FrequencyValue, required=True)
    __frequency._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 223, 16)
    __frequency._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 223, 16)
    
    frequency = property(__frequency.value, __frequency.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __frequency.name() : __frequency
    })
_Namespace_net.addCategoryObject('typeBinding', u'RandomStimInstance', RandomStimInstance)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_18 (pyxb.binding.basis.complexTypeDefinition):
    """Apply input to a certain percentage of cells in a group"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 283, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute percentage uses Python identifier percentage
    __percentage = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'percentage'), 'percentage', '__httpmorphml_orgnetworkmlschema_CTD_ANON_3_percentage', Percentage)
    __percentage._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 284, 24)
    __percentage._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 284, 24)
    
    percentage = property(__percentage.value, __percentage.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __percentage.name() : __percentage
    })



# Complex type {http://morphml.org/networkml/schema}InputSite with content type ELEMENT_ONLY
class InputSite (pyxb.binding.basis.complexTypeDefinition):
    """Specifies a location on a cell where input is received"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'InputSite')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 315, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/networkml/schema}pulse_input_instance uses Python identifier pulse_input_instance
    __pulse_input_instance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'pulse_input_instance'), 'pulse_input_instance', '__httpmorphml_orgnetworkmlschema_InputSite_httpmorphml_orgnetworkmlschemapulse_input_instance', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 325, 20), )

    
    pulse_input_instance = property(__pulse_input_instance.value, __pulse_input_instance.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}random_stim_instance uses Python identifier random_stim_instance
    __random_stim_instance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'random_stim_instance'), 'random_stim_instance', '__httpmorphml_orgnetworkmlschema_InputSite_httpmorphml_orgnetworkmlschemarandom_stim_instance', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 326, 20), )

    
    random_stim_instance = property(__random_stim_instance.value, __random_stim_instance.set, None, None)

    
    # Attribute cell_id uses Python identifier cell_id
    __cell_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cell_id'), 'cell_id', '__httpmorphml_orgnetworkmlschema_InputSite_cell_id', CellIdInNetwork, required=True)
    __cell_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 329, 12)
    __cell_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 329, 12)
    
    cell_id = property(__cell_id.value, __cell_id.set, None, None)

    
    # Attribute segment_id uses Python identifier segment_id
    __segment_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'segment_id'), 'segment_id', '__httpmorphml_orgnetworkmlschema_InputSite_segment_id', SegmentIdInCell, unicode_default=u'0')
    __segment_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 330, 12)
    __segment_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 330, 12)
    
    segment_id = property(__segment_id.value, __segment_id.set, None, None)

    
    # Attribute fraction_along uses Python identifier fraction_along
    __fraction_along = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fraction_along'), 'fraction_along', '__httpmorphml_orgnetworkmlschema_InputSite_fraction_along', ZeroToOne, unicode_default=u'0.5')
    __fraction_along._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 331, 12)
    __fraction_along._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 331, 12)
    
    fraction_along = property(__fraction_along.value, __fraction_along.set, None, None)

    _ElementMap.update({
        __pulse_input_instance.name() : __pulse_input_instance,
        __random_stim_instance.name() : __random_stim_instance
    })
    _AttributeMap.update({
        __cell_id.name() : __cell_id,
        __segment_id.name() : __segment_id,
        __fraction_along.name() : __fraction_along
    })
_Namespace_net.addCategoryObject('typeBinding', u'InputSite', InputSite)


# Complex type {http://morphml.org/networkml/schema}SynapseInternalProperties with content type ELEMENT_ONLY
class SynapseInternalProperties (pyxb.binding.basis.complexTypeDefinition):
    """Variables specifying a single synapse or default values for a set of connections"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'SynapseInternalProperties')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 528, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Attribute internal_delay uses Python identifier internal_delay
    __internal_delay = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'internal_delay'), 'internal_delay', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_internal_delay', SynapticDelayValue, unicode_default=u'0')
    __internal_delay._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 537, 12)
    __internal_delay._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 537, 12)
    
    internal_delay = property(__internal_delay.value, __internal_delay.set, None, u'Delay due to diffusion across the synaptic cleft. If only one delay value is known, this can be used')

    
    # Attribute pre_delay uses Python identifier pre_delay
    __pre_delay = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'pre_delay'), 'pre_delay', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_pre_delay', SynapticDelayValue, unicode_default=u'0')
    __pre_delay._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 542, 12)
    __pre_delay._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 542, 12)
    
    pre_delay = property(__pre_delay.value, __pre_delay.set, None, u'Delay due to presynaptic mechanism')

    
    # Attribute post_delay uses Python identifier post_delay
    __post_delay = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'post_delay'), 'post_delay', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_post_delay', SynapticDelayValue, unicode_default=u'0')
    __post_delay._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 547, 12)
    __post_delay._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 547, 12)
    
    post_delay = property(__post_delay.value, __post_delay.set, None, u'Delay due to postsynaptic mechanism')

    
    # Attribute prop_delay uses Python identifier prop_delay
    __prop_delay = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'prop_delay'), 'prop_delay', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_prop_delay', SynapticDelayValue, unicode_default=u'0')
    __prop_delay._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 552, 12)
    __prop_delay._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 552, 12)
    
    prop_delay = property(__prop_delay.value, __prop_delay.set, None, u'Delay due to simulated AP propagation along an axon')

    
    # Attribute weight uses Python identifier weight
    __weight = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'weight'), 'weight', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_weight', NonNegativeDouble, unicode_default=u'1')
    __weight._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 557, 12)
    __weight._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 557, 12)
    
    weight = property(__weight.value, __weight.set, None, u'Multiplicative weighting factor for the synapse')

    
    # Attribute threshold uses Python identifier threshold
    __threshold = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'threshold'), 'threshold', '__httpmorphml_orgnetworkmlschema_SynapseInternalProperties_threshold', VoltageValue, unicode_default=u'0')
    __threshold._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 562, 12)
    __threshold._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 562, 12)
    
    threshold = property(__threshold.value, __threshold.set, None, u'Presynaptic membrane potential level above which the synapse fires')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group
    })
    _AttributeMap.update({
        __internal_delay.name() : __internal_delay,
        __pre_delay.name() : __pre_delay,
        __post_delay.name() : __post_delay,
        __prop_delay.name() : __prop_delay,
        __weight.name() : __weight,
        __threshold.name() : __threshold
    })
_Namespace_net.addCategoryObject('typeBinding', u'SynapseInternalProperties', SynapseInternalProperties)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_19 (pyxb.binding.basis.complexTypeDefinition):
    """For each pre - post pair, there is a fixed probability of connection"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 588, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute probability uses Python identifier probability
    __probability = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'probability'), 'probability', '__httpmorphml_orgnetworkmlschema_CTD_ANON_4_probability', ZeroToOne)
    __probability._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 589, 24)
    __probability._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 589, 24)
    
    probability = property(__probability.value, __probability.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __probability.name() : __probability
    })



# Complex type {http://morphml.org/networkml/schema}PerCellConnection with content type EMPTY
class PerCellConnection (pyxb.binding.basis.complexTypeDefinition):
    """Connection built iteratively from each pre (or post) cell based on a number of parameters"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'PerCellConnection')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 603, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute direction uses Python identifier direction
    __direction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'direction'), 'direction', '__httpmorphml_orgnetworkmlschema_PerCellConnection_direction', STD_ANON, unicode_default=u'PreToPost')
    __direction._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 608, 16)
    __direction._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 608, 16)
    
    direction = property(__direction.value, __direction.set, None, u'Whether the settings below (e.g. number per source cell) refer to PreToPost or PostToPre connections.\n                        Note more info could be known about numbers of connections on post synaptic cells, so this possibility should be allowed.')

    
    # Attribute num_per_source uses Python identifier num_per_source
    __num_per_source = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'num_per_source'), 'num_per_source', '__httpmorphml_orgnetworkmlschema_PerCellConnection_num_per_source', PositiveDouble, required=True)
    __num_per_source._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 621, 16)
    __num_per_source._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 621, 16)
    
    num_per_source = property(__num_per_source.value, __num_per_source.set, None, None)

    
    # Attribute max_per_target uses Python identifier max_per_target
    __max_per_target = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_per_target'), 'max_per_target', '__httpmorphml_orgnetworkmlschema_PerCellConnection_max_per_target', pyxb.binding.datatypes.positiveInteger)
    __max_per_target._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 622, 16)
    __max_per_target._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 622, 16)
    
    max_per_target = property(__max_per_target.value, __max_per_target.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __direction.name() : __direction,
        __num_per_source.name() : __num_per_source,
        __max_per_target.name() : __max_per_target
    })
_Namespace_net.addCategoryObject('typeBinding', u'PerCellConnection', PerCellConnection)


# Complex type {http://morphml.org/networkml/schema}Connection with content type ELEMENT_ONLY
class Connection (pyxb.binding.basis.complexTypeDefinition):
    """A single synaptic connection"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'Connection')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 677, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_Connection_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_Connection_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_Connection_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_Connection_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}pre uses Python identifier pre
    __pre = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'pre'), 'pre', '__httpmorphml_orgnetworkmlschema_Connection_httpmorphml_orgnetworkmlschemapre', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 685, 16), )

    
    pre = property(__pre.value, __pre.set, None, u'NOTE: Attributes pre_cell_id etc. for WILL BE PREFERRED FORMAT IN v2.0')

    
    # Element {http://morphml.org/networkml/schema}post uses Python identifier post
    __post = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'post'), 'post', '__httpmorphml_orgnetworkmlschema_Connection_httpmorphml_orgnetworkmlschemapost', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 690, 16), )

    
    post = property(__post.value, __post.set, None, u'NOTE: Attributes post_cell_id etc. for WILL BE PREFERRED FORMAT IN v2.0')

    
    # Element {http://morphml.org/networkml/schema}properties uses Python identifier properties_
    __properties_ = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'properties'), 'properties_', '__httpmorphml_orgnetworkmlschema_Connection_httpmorphml_orgnetworkmlschemaproperties', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 695, 16), )

    
    properties_ = property(__properties_.value, __properties_.set, None, None)

    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'id'), 'id', '__httpmorphml_orgnetworkmlschema_Connection_id', pyxb.binding.datatypes.integer, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 700, 16)
    __id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 700, 16)
    
    id = property(__id.value, __id.set, None, u'The unique ID of the single synaptic connection.')

    
    # Attribute pre_cell_id uses Python identifier pre_cell_id
    __pre_cell_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'pre_cell_id'), 'pre_cell_id', '__httpmorphml_orgnetworkmlschema_Connection_pre_cell_id', pyxb.binding.datatypes.integer)
    __pre_cell_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 706, 16)
    __pre_cell_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 706, 16)
    
    pre_cell_id = property(__pre_cell_id.value, __pre_cell_id.set, None, u'The ID of the presynaptic cell. Must be listed in populations, so that too must list instances.\n                        Optional now, but attributes pre_cell_id, etc. WILL BE PREFERRED FORMAT IN v2.0')

    
    # Attribute pre_segment_id uses Python identifier pre_segment_id
    __pre_segment_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'pre_segment_id'), 'pre_segment_id', '__httpmorphml_orgnetworkmlschema_Connection_pre_segment_id', pyxb.binding.datatypes.integer, unicode_default=u'0')
    __pre_segment_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 712, 16)
    __pre_segment_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 712, 16)
    
    pre_segment_id = property(__pre_segment_id.value, __pre_segment_id.set, None, u'The segment on the presynaptic cell where the synapse is located.\n                        Attributes pre_cell_id, etc. WILL BE PREFERRED FORMAT IN v2.0')

    
    # Attribute pre_fraction_along uses Python identifier pre_fraction_along
    __pre_fraction_along = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'pre_fraction_along'), 'pre_fraction_along', '__httpmorphml_orgnetworkmlschema_Connection_pre_fraction_along', ZeroToOne, unicode_default=u'0.5')
    __pre_fraction_along._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 718, 16)
    __pre_fraction_along._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 718, 16)
    
    pre_fraction_along = property(__pre_fraction_along.value, __pre_fraction_along.set, None, u'The fraction along the length of the specified segment on the presynaptic cell where the synapse is located.\n                        Attributes pre_cell_id, etc. WILL BE PREFERRED FORMAT IN v2.0')

    
    # Attribute post_cell_id uses Python identifier post_cell_id
    __post_cell_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'post_cell_id'), 'post_cell_id', '__httpmorphml_orgnetworkmlschema_Connection_post_cell_id', pyxb.binding.datatypes.integer)
    __post_cell_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 725, 16)
    __post_cell_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 725, 16)
    
    post_cell_id = property(__post_cell_id.value, __post_cell_id.set, None, u'The ID of the postsynaptic cell. Must be listed in populations, so that too must list instances.\n                        Optional now, but attributes pre_cell_id, etc. WILL BE PREFERRED FORMAT IN v2.0')

    
    # Attribute post_segment_id uses Python identifier post_segment_id
    __post_segment_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'post_segment_id'), 'post_segment_id', '__httpmorphml_orgnetworkmlschema_Connection_post_segment_id', pyxb.binding.datatypes.integer, unicode_default=u'0')
    __post_segment_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 731, 16)
    __post_segment_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 731, 16)
    
    post_segment_id = property(__post_segment_id.value, __post_segment_id.set, None, u'The segment on the postsynaptic cell where the synapse is located.\n                        Attributes pre_cell_id, etc. WILL BE PREFERRED FORMAT IN v2.0')

    
    # Attribute post_fraction_along uses Python identifier post_fraction_along
    __post_fraction_along = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'post_fraction_along'), 'post_fraction_along', '__httpmorphml_orgnetworkmlschema_Connection_post_fraction_along', ZeroToOne, unicode_default=u'0.5')
    __post_fraction_along._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 737, 16)
    __post_fraction_along._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 737, 16)
    
    post_fraction_along = property(__post_fraction_along.value, __post_fraction_along.set, None, u'The fraction along the length of the specified segment on the postsynaptic cell where the synapse is located.\n                        Attributes pre_cell_id, etc. WILL BE PREFERRED FORMAT IN v2.0')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __pre.name() : __pre,
        __post.name() : __post,
        __properties_.name() : __properties_
    })
    _AttributeMap.update({
        __id.name() : __id,
        __pre_cell_id.name() : __pre_cell_id,
        __pre_segment_id.name() : __pre_segment_id,
        __pre_fraction_along.name() : __pre_fraction_along,
        __post_cell_id.name() : __post_cell_id,
        __post_segment_id.name() : __post_segment_id,
        __post_fraction_along.name() : __post_fraction_along
    })
_Namespace_net.addCategoryObject('typeBinding', u'Connection', Connection)


# Complex type {http://morphml.org/networkml/schema}SynapticLocation with content type EMPTY
class SynapticLocation (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://morphml.org/networkml/schema}SynapticLocation with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'SynapticLocation')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 747, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute cell_id uses Python identifier cell_id
    __cell_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cell_id'), 'cell_id', '__httpmorphml_orgnetworkmlschema_SynapticLocation_cell_id', pyxb.binding.datatypes.integer, required=True)
    __cell_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 749, 12)
    __cell_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 749, 12)
    
    cell_id = property(__cell_id.value, __cell_id.set, None, u'The ID of the cell. Must be listed in populations, so that too must list instances')

    
    # Attribute segment_id uses Python identifier segment_id
    __segment_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'segment_id'), 'segment_id', '__httpmorphml_orgnetworkmlschema_SynapticLocation_segment_id', pyxb.binding.datatypes.integer, unicode_default=u'0')
    __segment_id._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 754, 12)
    __segment_id._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 754, 12)
    
    segment_id = property(__segment_id.value, __segment_id.set, None, u'The segment where the synapse is located.')

    
    # Attribute fraction_along uses Python identifier fraction_along
    __fraction_along = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'fraction_along'), 'fraction_along', '__httpmorphml_orgnetworkmlschema_SynapticLocation_fraction_along', ZeroToOne, unicode_default=u'0.5')
    __fraction_along._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 759, 12)
    __fraction_along._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 759, 12)
    
    fraction_along = property(__fraction_along.value, __fraction_along.set, None, u'The fraction along the length of the specified segment where the synapse is located.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __cell_id.name() : __cell_id,
        __segment_id.name() : __segment_id,
        __fraction_along.name() : __fraction_along
    })
_Namespace_net.addCategoryObject('typeBinding', u'SynapticLocation', SynapticLocation)


# Complex type {http://morphml.org/networkml/schema}PotentialSynLoc with content type ELEMENT_ONLY
class PotentialSynLoc (pyxb.binding.basis.complexTypeDefinition):
    """Subset of sections on cell where synaptic connection of a particular type is allowed.
                Note: from v1.7.1 the preferred way to specify a potential synaptic location is with a potential_syn_loc element under connectivity under cell, as
            opposed to the potentialSynapticLocation under biophysics under cell. The former will be the only option from v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'PotentialSynLoc')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 876, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgnetworkmlschema_PotentialSynLoc_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgnetworkmlschema_PotentialSynLoc_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgnetworkmlschema_PotentialSynLoc_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgnetworkmlschema_PotentialSynLoc_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}group uses Python identifier group_
    __group_ = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'group'), 'group_', '__httpmorphml_orgnetworkmlschema_PotentialSynLoc_httpmorphml_orgnetworkmlschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 886, 20), )

    
    group_ = property(__group_.value, __group_.set, None, u'List of groups of sections allowing the synapse')

    
    # Attribute synapse_type uses Python identifier synapse_type
    __synapse_type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'synapse_type'), 'synapse_type', '__httpmorphml_orgnetworkmlschema_PotentialSynLoc_synapse_type', pyxb.binding.datatypes.string, required=True)
    __synapse_type._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 894, 12)
    __synapse_type._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 894, 12)
    
    synapse_type = property(__synapse_type.value, __synapse_type.set, None, u'Which of the synaptic mechanisms can be present')

    
    # Attribute synapse_direction uses Python identifier synapse_direction
    __synapse_direction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'synapse_direction'), 'synapse_direction', '__httpmorphml_orgnetworkmlschema_PotentialSynLoc_synapse_direction', SynapseDirection, unicode_default=u'preAndOrPost')
    __synapse_direction._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 899, 12)
    __synapse_direction._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 899, 12)
    
    synapse_direction = property(__synapse_direction.value, __synapse_direction.set, None, u'Whether this synapse location allows a presynaptic connection, a postsynaptic\n                        connection or either')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __group_.name() : __group_
    })
    _AttributeMap.update({
        __synapse_type.name() : __synapse_type,
        __synapse_direction.name() : __synapse_direction
    })
_Namespace_net.addCategoryObject('typeBinding', u'PotentialSynLoc', PotentialSynLoc)


# Complex type {http://morphml.org/neuroml/schema}NeuroMLLevel3 with content type ELEMENT_ONLY
class NeuroMLLevel3 (pyxb.binding.basis.complexTypeDefinition):
    """Description of neuronal models, including biophysics and channel mechanisms, and network connections (NeuroML Level 3)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace, u'NeuroMLLevel3')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 54, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://morphml.org/metadata/schema}notes uses Python identifier notes
    __notes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), 'notes', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemanotes', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12), )

    
    notes = property(__notes.value, __notes.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}properties uses Python identifier properties
    __properties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), 'properties', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemaproperties', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12), )

    
    properties = property(__properties.value, __properties.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}annotation uses Python identifier annotation
    __annotation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), 'annotation', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemaannotation', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12), )

    
    annotation = property(__annotation.value, __annotation.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}group uses Python identifier group
    __group = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), 'group', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemagroup', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12), )

    
    group = property(__group.value, __group.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}authorList uses Python identifier authorList
    __authorList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), 'authorList', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemaauthorList', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12), )

    
    authorList = property(__authorList.value, __authorList.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}publication uses Python identifier publication
    __publication = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), 'publication', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemapublication', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12), )

    
    publication = property(__publication.value, __publication.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuronDBref uses Python identifier neuronDBref
    __neuronDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), 'neuronDBref', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemaneuronDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12), )

    
    neuronDBref = property(__neuronDBref.value, __neuronDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}modelDBref uses Python identifier modelDBref
    __modelDBref = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), 'modelDBref', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemamodelDBref', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12), )

    
    modelDBref = property(__modelDBref.value, __modelDBref.set, None, None)

    
    # Element {http://morphml.org/metadata/schema}neuroMorphoRef uses Python identifier neuroMorphoRef
    __neuroMorphoRef = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), 'neuroMorphoRef', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgmetadataschemaneuroMorphoRef', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12), )

    
    neuroMorphoRef = property(__neuroMorphoRef.value, __neuroMorphoRef.set, None, None)

    
    # Element {http://morphml.org/networkml/schema}populations uses Python identifier populations
    __populations = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'populations'), 'populations', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgnetworkmlschemapopulations', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 95, 17), )

    
    populations = property(__populations.value, __populations.set, None, u"The least that's needed in a network is a population of cells...")

    
    # Element {http://morphml.org/networkml/schema}projections uses Python identifier projections
    __projections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'projections'), 'projections', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgnetworkmlschemaprojections', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16), )

    
    projections = property(__projections.value, __projections.set, None, u'In theory there can be no projections, if the file is intended only to specify positions')

    
    # Element {http://morphml.org/networkml/schema}inputs uses Python identifier inputs
    __inputs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'inputs'), 'inputs', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgnetworkmlschemainputs', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16), )

    
    inputs = property(__inputs.value, __inputs.set, None, u'No inputs need be specified')

    
    # Element {http://morphml.org/neuroml/schema}cells uses Python identifier cells
    __cells = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace, u'cells'), 'cells', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgneuromlschemacells', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 63, 12), )

    
    cells = property(__cells.value, __cells.set, None, None)

    
    # Element {http://morphml.org/neuroml/schema}channels uses Python identifier channels
    __channels = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace, u'channels'), 'channels', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_httpmorphml_orgneuromlschemachannels', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 65, 12), )

    
    channels = property(__channels.value, __channels.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'name'), 'name', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_name', pyxb.binding.datatypes.string)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 71, 8)
    __name._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 71, 8)
    
    name = property(__name.value, __name.set, None, None)

    
    # Attribute lengthUnits uses Python identifier lengthUnits
    __lengthUnits = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'lengthUnits'), 'lengthUnits', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_lengthUnits', LengthUnits)
    __lengthUnits._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 74, 8)
    __lengthUnits._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 74, 8)
    
    lengthUnits = property(__lengthUnits.value, __lengthUnits.set, None, u'Unit of all length measurements. Usually has the value <b>micrometer</b>. Note: length_units will be the preferred form in v2.0')

    
    # Attribute length_units uses Python identifier length_units
    __length_units = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'length_units'), 'length_units', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_length_units', LengthUnits)
    __length_units._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 80, 8)
    __length_units._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 80, 8)
    
    length_units = property(__length_units.value, __length_units.set, None, u'Unit of all length measurements. Usually has the value <b>micrometer</b>. Note: length_units will be the preferred form in v2.0')

    
    # Attribute volumeUnits uses Python identifier volumeUnits
    __volumeUnits = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'volumeUnits'), 'volumeUnits', '__httpmorphml_orgneuromlschema_NeuroMLLevel3_volumeUnits', VolumeUnits, unicode_default=u'cubic_millimeter')
    __volumeUnits._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 86, 8)
    __volumeUnits._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 86, 8)
    
    volumeUnits = property(__volumeUnits.value, __volumeUnits.set, None, u'Unit of all volume measurements.')

    _ElementMap.update({
        __notes.name() : __notes,
        __properties.name() : __properties,
        __annotation.name() : __annotation,
        __group.name() : __group,
        __authorList.name() : __authorList,
        __publication.name() : __publication,
        __neuronDBref.name() : __neuronDBref,
        __modelDBref.name() : __modelDBref,
        __neuroMorphoRef.name() : __neuroMorphoRef,
        __populations.name() : __populations,
        __projections.name() : __projections,
        __inputs.name() : __inputs,
        __cells.name() : __cells,
        __channels.name() : __channels
    })
    _AttributeMap.update({
        __name.name() : __name,
        __lengthUnits.name() : __lengthUnits,
        __length_units.name() : __length_units,
        __volumeUnits.name() : __volumeUnits
    })
_Namespace.addCategoryObject('typeBinding', u'NeuroMLLevel3', NeuroMLLevel3)


# Complex type {http://morphml.org/neuroml/schema}Level3Cell with content type ELEMENT_ONLY
class Level3Cell (Cell):
    """Cell with extensions for biophysics, and network functionality"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace, u'Level3Cell')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 110, 4)
    _ElementMap = Cell._ElementMap.copy()
    _AttributeMap = Cell._AttributeMap.copy()
    # Base type is Cell
    
    # Element notes ({http://morphml.org/metadata/schema}notes) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element properties ({http://morphml.org/metadata/schema}properties) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element annotation ({http://morphml.org/metadata/schema}annotation) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element group ({http://morphml.org/metadata/schema}group) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element authorList ({http://morphml.org/metadata/schema}authorList) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element publication ({http://morphml.org/metadata/schema}publication) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element neuronDBref ({http://morphml.org/metadata/schema}neuronDBref) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element modelDBref ({http://morphml.org/metadata/schema}modelDBref) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element neuroMorphoRef ({http://morphml.org/metadata/schema}neuroMorphoRef) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element status ({http://morphml.org/morphml/schema}status) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element segments ({http://morphml.org/morphml/schema}segments) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element cables ({http://morphml.org/morphml/schema}cables) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element cellBody ({http://morphml.org/morphml/schema}cellBody) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element spines ({http://morphml.org/morphml/schema}spines) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element freePoints ({http://morphml.org/morphml/schema}freePoints) inherited from {http://morphml.org/morphml/schema}Cell
    
    # Element {http://morphml.org/neuroml/schema}biophysics uses Python identifier biophysics
    __biophysics = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace, u'biophysics'), 'biophysics', '__httpmorphml_orgneuromlschema_Level3Cell_httpmorphml_orgneuromlschemabiophysics', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 117, 24), )

    
    biophysics = property(__biophysics.value, __biophysics.set, None, None)

    
    # Element {http://morphml.org/neuroml/schema}connectivity uses Python identifier connectivity
    __connectivity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace, u'connectivity'), 'connectivity', '__httpmorphml_orgneuromlschema_Level3Cell_httpmorphml_orgneuromlschemaconnectivity', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 119, 24), )

    
    connectivity = property(__connectivity.value, __connectivity.set, None, u'Note: from v1.7.1 the preferred way to specify a potential synaptic location \n                                is with a potential_syn_loc element under connectivity under cell, as opposed to the potentialSynapticLocation \n                                under biophysics under cell. The former will be the only option from v2.0')

    
    # Attribute name inherited from {http://morphml.org/morphml/schema}Cell
    _ElementMap.update({
        __biophysics.name() : __biophysics,
        __connectivity.name() : __connectivity
    })
    _AttributeMap.update({
        
    })
_Namespace.addCategoryObject('typeBinding', u'Level3Cell', Level3Cell)


# Complex type {http://morphml.org/channelml/schema}BlockingSynapse with content type ELEMENT_ONLY
class BlockingSynapse (DoubleExponentialSynapse):
    """A synaptic mechanism whose conductance can be blocked by the presence of a specific species (ion/molecule). Based on the
            mechanism for blocking of an NMDA receptor by Mg as outlined in Gabbiani et al, 1994, Maex DeSchutter 1998"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'BlockingSynapse')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 320, 4)
    _ElementMap = DoubleExponentialSynapse._ElementMap.copy()
    _AttributeMap = DoubleExponentialSynapse._AttributeMap.copy()
    # Base type is DoubleExponentialSynapse
    
    # Element {http://morphml.org/channelml/schema}block uses Python identifier block
    __block = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'block'), 'block', '__httpmorphml_orgchannelmlschema_BlockingSynapse_httpmorphml_orgchannelmlschemablock', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 328, 16), )

    
    block = property(__block.value, __block.set, None, None)

    
    # Element notes ({http://morphml.org/metadata/schema}notes) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element properties ({http://morphml.org/metadata/schema}properties) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element annotation ({http://morphml.org/metadata/schema}annotation) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element group ({http://morphml.org/metadata/schema}group) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute max_conductance inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute rise_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute decay_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute reversal_potential inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    _ElementMap.update({
        __block.name() : __block
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'BlockingSynapse', BlockingSynapse)


# Complex type {http://morphml.org/channelml/schema}MultiDecaySynapse with content type ELEMENT_ONLY
class MultiDecaySynapse (DoubleExponentialSynapse):
    """A more complex synaptic mechanism featuring up to 4 exponential components (1 rise and 3 decay).
            Currently there is only an implementation of this in a NEURON mod file. Attributed added can be gmax_2, tau_decay_2, gmax_3 and tau_decay_3.
            The overall conductance is effectively a linear sum of 3 independent conductances, all with the same rise time and different decays.
            Note that the gmaxes are specific for each conductance and scaling is calculated for each individually, so the maximum total conductance (gmax + gmax_2 + gmax_3) 
            will only be reached when tau_decay = tau_decay_2 = tau_decay_3, otherwise peaks will not overlap.  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'MultiDecaySynapse')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 373, 4)
    _ElementMap = DoubleExponentialSynapse._ElementMap.copy()
    _AttributeMap = DoubleExponentialSynapse._AttributeMap.copy()
    # Base type is DoubleExponentialSynapse
    
    # Element notes ({http://morphml.org/metadata/schema}notes) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element properties ({http://morphml.org/metadata/schema}properties) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element annotation ({http://morphml.org/metadata/schema}annotation) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element group ({http://morphml.org/metadata/schema}group) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute max_conductance inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute rise_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute decay_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute reversal_potential inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute max_conductance_2 uses Python identifier max_conductance_2
    __max_conductance_2 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_conductance_2'), 'max_conductance_2', '__httpmorphml_orgchannelmlschema_MultiDecaySynapse_max_conductance_2', ConductanceValue)
    __max_conductance_2._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 408, 8)
    __max_conductance_2._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 408, 8)
    
    max_conductance_2 = property(__max_conductance_2.value, __max_conductance_2.set, None, None)

    
    # Attribute decay_time_2 uses Python identifier decay_time_2
    __decay_time_2 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'decay_time_2'), 'decay_time_2', '__httpmorphml_orgchannelmlschema_MultiDecaySynapse_decay_time_2', TimeConstantValue)
    __decay_time_2._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 409, 8)
    __decay_time_2._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 409, 8)
    
    decay_time_2 = property(__decay_time_2.value, __decay_time_2.set, None, None)

    
    # Attribute max_conductance_3 uses Python identifier max_conductance_3
    __max_conductance_3 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'max_conductance_3'), 'max_conductance_3', '__httpmorphml_orgchannelmlschema_MultiDecaySynapse_max_conductance_3', ConductanceValue)
    __max_conductance_3._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 417, 8)
    __max_conductance_3._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 417, 8)
    
    max_conductance_3 = property(__max_conductance_3.value, __max_conductance_3.set, None, None)

    
    # Attribute decay_time_3 uses Python identifier decay_time_3
    __decay_time_3 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'decay_time_3'), 'decay_time_3', '__httpmorphml_orgchannelmlschema_MultiDecaySynapse_decay_time_3', TimeConstantValue)
    __decay_time_3._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 418, 8)
    __decay_time_3._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 418, 8)
    
    decay_time_3 = property(__decay_time_3.value, __decay_time_3.set, None, None)

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __max_conductance_2.name() : __max_conductance_2,
        __decay_time_2.name() : __decay_time_2,
        __max_conductance_3.name() : __max_conductance_3,
        __decay_time_3.name() : __decay_time_3
    })
_Namespace_cml.addCategoryObject('typeBinding', u'MultiDecaySynapse', MultiDecaySynapse)


# Complex type {http://morphml.org/networkml/schema}GlobalSynapticProperties with content type ELEMENT_ONLY
class GlobalSynapticProperties (SynapseInternalProperties):
    """Information on synapse type and default values for weight, delay, threshold, etc."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'GlobalSynapticProperties')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 470, 8)
    _ElementMap = SynapseInternalProperties._ElementMap.copy()
    _AttributeMap = SynapseInternalProperties._AttributeMap.copy()
    # Base type is SynapseInternalProperties
    
    # Element notes ({http://morphml.org/metadata/schema}notes) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Element properties ({http://morphml.org/metadata/schema}properties) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Element annotation ({http://morphml.org/metadata/schema}annotation) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Element group ({http://morphml.org/metadata/schema}group) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Element {http://morphml.org/networkml/schema}synapse_type uses Python identifier synapse_type
    __synapse_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type'), 'synapse_type', '__httpmorphml_orgnetworkmlschema_GlobalSynapticProperties_httpmorphml_orgnetworkmlschemasynapse_type', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 479, 20), )

    
    synapse_type = property(__synapse_type.value, __synapse_type.set, None, u'For compatability to pre v1.7.1. Will be removed in v2.0.')

    
    # Element {http://morphml.org/networkml/schema}default_values uses Python identifier default_values
    __default_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'default_values'), 'default_values', '__httpmorphml_orgnetworkmlschema_GlobalSynapticProperties_httpmorphml_orgnetworkmlschemadefault_values', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 484, 20), )

    
    default_values = property(__default_values.value, __default_values.set, None, u'For compatability to pre v1.7.1. Will be removed in v2.0.')

    
    # Attribute synapse_type uses Python identifier synapse_type_
    __synapse_type_ = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'synapse_type'), 'synapse_type_', '__httpmorphml_orgnetworkmlschema_GlobalSynapticProperties_synapse_type', pyxb.binding.datatypes.string)
    __synapse_type_._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 491, 20)
    __synapse_type_._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 491, 20)
    
    synapse_type_ = property(__synapse_type_.value, __synapse_type_.set, None, u'Including synapse_type as attribute in synapse_props will be required in v2.0')

    
    # Attribute internal_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute pre_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute post_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute prop_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute weight inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute threshold inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    _ElementMap.update({
        __synapse_type.name() : __synapse_type,
        __default_values.name() : __default_values
    })
    _AttributeMap.update({
        __synapse_type_.name() : __synapse_type_
    })
_Namespace_net.addCategoryObject('typeBinding', u'GlobalSynapticProperties', GlobalSynapticProperties)


# Complex type {http://morphml.org/networkml/schema}LocalSynapticProperties with content type ELEMENT_ONLY
class LocalSynapticProperties (SynapseInternalProperties):
    """Variables specifying a single synapse"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_net, u'LocalSynapticProperties')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 505, 8)
    _ElementMap = SynapseInternalProperties._ElementMap.copy()
    _AttributeMap = SynapseInternalProperties._AttributeMap.copy()
    # Base type is SynapseInternalProperties
    
    # Element notes ({http://morphml.org/metadata/schema}notes) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Element properties ({http://morphml.org/metadata/schema}properties) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Element annotation ({http://morphml.org/metadata/schema}annotation) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Element group ({http://morphml.org/metadata/schema}group) inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute synapse_type uses Python identifier synapse_type
    __synapse_type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'synapse_type'), 'synapse_type', '__httpmorphml_orgnetworkmlschema_LocalSynapticProperties_synapse_type', pyxb.binding.datatypes.string)
    __synapse_type._DeclarationLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 513, 20)
    __synapse_type._UseLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 513, 20)
    
    synapse_type = property(__synapse_type.value, __synapse_type.set, None, u"Optional for a single synaptic connection. Only needed in the case where multiple synapses are \n                            present at one connection and there are non default values for each synapse's weights, etc. This field gives the \n                            name of the synapse type referred to.")

    
    # Attribute internal_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute pre_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute post_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute prop_delay inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute weight inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    
    # Attribute threshold inherited from {http://morphml.org/networkml/schema}SynapseInternalProperties
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __synapse_type.name() : __synapse_type
    })
_Namespace_net.addCategoryObject('typeBinding', u'LocalSynapticProperties', LocalSynapticProperties)


# Complex type {http://morphml.org/neuroml/schema}Level3Biophysics with content type ELEMENT_ONLY
class Level3Biophysics (Biophysics):
    """Biophysics of Level3 cell, including specification for allowable synaptic locations. 
                    Note: from v1.7.1 the preferred way to specify a potential synaptic location is with a potential_syn_loc element under connectivity under cell, as
            opposed to the potentialSynapticLocation under biophysics under cell. The former will be the only option from v2.0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace, u'Level3Biophysics')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 135, 4)
    _ElementMap = Biophysics._ElementMap.copy()
    _AttributeMap = Biophysics._AttributeMap.copy()
    # Base type is Biophysics
    
    # Element mechanism ({http://morphml.org/biophysics/schema}mechanism) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element specificCapacitance ({http://morphml.org/biophysics/schema}specificCapacitance) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element spec_capacitance ({http://morphml.org/biophysics/schema}spec_capacitance) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element specificAxialResistance ({http://morphml.org/biophysics/schema}specificAxialResistance) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element spec_axial_resistance ({http://morphml.org/biophysics/schema}spec_axial_resistance) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element initialMembPotential ({http://morphml.org/biophysics/schema}initialMembPotential) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element init_memb_potential ({http://morphml.org/biophysics/schema}init_memb_potential) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element ionProperties ({http://morphml.org/biophysics/schema}ionProperties) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element ion_props ({http://morphml.org/biophysics/schema}ion_props) inherited from {http://morphml.org/biophysics/schema}Biophysics
    
    # Element {http://morphml.org/networkml/schema}potentialSynapticLocation uses Python identifier potentialSynapticLocation
    __potentialSynapticLocation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_net, u'potentialSynapticLocation'), 'potentialSynapticLocation', '__httpmorphml_orgneuromlschema_Level3Biophysics_httpmorphml_orgnetworkmlschemapotentialSynapticLocation', True, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 971, 16), )

    
    potentialSynapticLocation = property(__potentialSynapticLocation.value, __potentialSynapticLocation.set, None, None)

    
    # Attribute units inherited from {http://morphml.org/biophysics/schema}Biophysics
    _ElementMap.update({
        __potentialSynapticLocation.name() : __potentialSynapticLocation
    })
    _AttributeMap.update({
        
    })
_Namespace.addCategoryObject('typeBinding', u'Level3Biophysics', Level3Biophysics)


# Complex type {http://morphml.org/channelml/schema}FacDepSynapse with content type ELEMENT_ONLY
class FacDepSynapse (MultiDecaySynapse):
    """A synaptic type with facilitating and depressing amplitude. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'FacDepSynapse')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 423, 4)
    _ElementMap = MultiDecaySynapse._ElementMap.copy()
    _AttributeMap = MultiDecaySynapse._AttributeMap.copy()
    # Base type is MultiDecaySynapse
    
    # Element {http://morphml.org/channelml/schema}plasticity uses Python identifier plasticity
    __plasticity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'plasticity'), 'plasticity', '__httpmorphml_orgchannelmlschema_FacDepSynapse_httpmorphml_orgchannelmlschemaplasticity', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 433, 16), )

    
    plasticity = property(__plasticity.value, __plasticity.set, None, None)

    
    # Element notes ({http://morphml.org/metadata/schema}notes) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element properties ({http://morphml.org/metadata/schema}properties) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element annotation ({http://morphml.org/metadata/schema}annotation) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element group ({http://morphml.org/metadata/schema}group) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute max_conductance inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute rise_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute decay_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute reversal_potential inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute max_conductance_2 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    
    # Attribute decay_time_2 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    
    # Attribute max_conductance_3 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    
    # Attribute decay_time_3 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    _ElementMap.update({
        __plasticity.name() : __plasticity
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'FacDepSynapse', FacDepSynapse)


# Complex type {http://morphml.org/channelml/schema}StdpSynapse with content type ELEMENT_ONLY
class StdpSynapse (MultiDecaySynapse):
    """A synaptic mechanism implementing basic Spike Timing Dependent Plasticity based on Song and Abbott, 2001"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(_Namespace_cml, u'StdpSynapse')
    _XSDLocation = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 440, 4)
    _ElementMap = MultiDecaySynapse._ElementMap.copy()
    _AttributeMap = MultiDecaySynapse._AttributeMap.copy()
    # Base type is MultiDecaySynapse
    
    # Element {http://morphml.org/channelml/schema}spike_time_dep uses Python identifier spike_time_dep
    __spike_time_dep = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(_Namespace_cml, u'spike_time_dep'), 'spike_time_dep', '__httpmorphml_orgchannelmlschema_StdpSynapse_httpmorphml_orgchannelmlschemaspike_time_dep', False, pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 450, 16), )

    
    spike_time_dep = property(__spike_time_dep.value, __spike_time_dep.set, None, None)

    
    # Element notes ({http://morphml.org/metadata/schema}notes) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element properties ({http://morphml.org/metadata/schema}properties) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element annotation ({http://morphml.org/metadata/schema}annotation) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Element group ({http://morphml.org/metadata/schema}group) inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute max_conductance inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute rise_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute decay_time inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute reversal_potential inherited from {http://morphml.org/channelml/schema}DoubleExponentialSynapse
    
    # Attribute max_conductance_2 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    
    # Attribute decay_time_2 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    
    # Attribute max_conductance_3 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    
    # Attribute decay_time_3 inherited from {http://morphml.org/channelml/schema}MultiDecaySynapse
    _ElementMap.update({
        __spike_time_dep.name() : __spike_time_dep
    })
    _AttributeMap.update({
        
    })
_Namespace_cml.addCategoryObject('typeBinding', u'StdpSynapse', StdpSynapse)


biophysics = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'biophysics'), Biophysics, documentation=u'The root element. All other complex/simple elements will be children of this.', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 39, 4))
_Namespace_bio.addCategoryObject('elementBinding', biophysics.name().localName(), biophysics)

channelml = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'channelml'), ChannelML, documentation=u'The root element of any ChannelML file. Note this element will only be present in a standalone ChannelML file.\n            For files covering many levels, neuroml will be the root element', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 52, 4))
_Namespace_cml.addCategoryObject('elementBinding', channelml.name().localName(), channelml)

morphml = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'morphml'), Morphology, documentation=u'The root element, and so will start any MorphML (NeuroML Level 1) compliant document.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 544, 4))
_Namespace_mml.addCategoryObject('elementBinding', morphml.name().localName(), morphml)

networkml = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'networkml'), NetworkML, documentation=u'The root element. \n                    Note: this element will only be present in a standalone NetworkML file (i.e. no cells or channels defined in the file).\n                    For files covering many levels, neuroml will be the root element', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 44, 8))
_Namespace_net.addCategoryObject('elementBinding', networkml.name().localName(), networkml)

neuroml = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace, u'neuroml'), NeuroMLLevel3, documentation=u'The root NeuroML Level 3 element.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 48, 4))
_Namespace.addCategoryObject('elementBinding', neuroml.name().localName(), neuroml)



SpecCapacitance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), UnnamedParameter, scope=SpecCapacitance, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 142, 12)))

SpecCapacitance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), VariableParameter, scope=SpecCapacitance, documentation=u'Note variable_parameter will be the preferred form in v2.0', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 143, 12)))

SpecCapacitance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter'), VariableParameter, scope=SpecCapacitance, documentation=u'Note variable_parameter will be the preferred form in v2.0', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 148, 12)))

def _BuildAutomaton ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 142, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 143, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 148, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SpecCapacitance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 142, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SpecCapacitance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 143, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SpecCapacitance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 148, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SpecCapacitance._Automaton = _BuildAutomaton()




SpecAxialResistance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), UnnamedParameter, scope=SpecAxialResistance, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 165, 12)))

SpecAxialResistance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), VariableParameter, scope=SpecAxialResistance, documentation=u'Note variable_parameter will be the preferred form in v2.0', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 166, 12)))

SpecAxialResistance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter'), VariableParameter, scope=SpecAxialResistance, documentation=u'Note variable_parameter will be the preferred form in v2.0', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 171, 12)))

def _BuildAutomaton_ ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 165, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 166, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 171, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SpecAxialResistance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 165, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SpecAxialResistance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 166, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SpecAxialResistance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 171, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SpecAxialResistance._Automaton = _BuildAutomaton_()




InitialMembPotential._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), UnnamedParameter, scope=InitialMembPotential, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 189, 12)))

InitialMembPotential._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), VariableParameter, scope=InitialMembPotential, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 190, 12)))

def _BuildAutomaton_2 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 189, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 190, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(InitialMembPotential._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 189, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(InitialMembPotential._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 190, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
InitialMembPotential._Automaton = _BuildAutomaton_2()




IonProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), NamedParameter, scope=IonProperties, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 201, 12)))

def _BuildAutomaton_3 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 201, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(IonProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 201, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
IonProperties._Automaton = _BuildAutomaton_3()




NamedParameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), pyxb.binding.datatypes.string, scope=NamedParameter, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 214, 11)))

def _BuildAutomaton_4 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NamedParameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'group')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 214, 11))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
NamedParameter._Automaton = _BuildAutomaton_4()




VariableParameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), pyxb.binding.datatypes.string, scope=VariableParameter, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 229, 28)))

VariableParameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'inhomogeneous_value'), InhomogeneousValue, scope=VariableParameter, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 230, 28)))

def _BuildAutomaton_5 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VariableParameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'group')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 229, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VariableParameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'inhomogeneous_value')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 230, 28))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VariableParameter._Automaton = _BuildAutomaton_5()




VariableNamedParameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), pyxb.binding.datatypes.string, scope=VariableNamedParameter, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 240, 28)))

VariableNamedParameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'inhomogeneous_value'), InhomogeneousValue, scope=VariableNamedParameter, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 241, 28)))

def _BuildAutomaton_6 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VariableNamedParameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'group')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 240, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VariableNamedParameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'inhomogeneous_value')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 241, 28))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VariableNamedParameter._Automaton = _BuildAutomaton_6()




UnnamedParameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'group'), pyxb.binding.datatypes.string, scope=UnnamedParameter, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 295, 12)))

def _BuildAutomaton_7 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UnnamedParameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'group')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 295, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
UnnamedParameter._Automaton = _BuildAutomaton_7()




Parameters._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameter'), Parameter, scope=Parameters, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 108, 12)))

def _BuildAutomaton_8 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Parameters._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameter')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 108, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Parameters._Automaton = _BuildAutomaton_8()




SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'status'), Status, scope=SynapseType, documentation=u'Status of the synapse specification: stable, in progress, etc.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 210, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'electrical_syn'), ElectricalSynapse, scope=SynapseType, documentation=u'Electrical synaptic coupling as at a gap junction', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 228, 16)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'doub_exp_syn'), DoubleExponentialSynapse, scope=SynapseType, documentation=u'Synaptic conductance with rise time and decay time', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 233, 16)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'blocking_syn'), BlockingSynapse, scope=SynapseType, documentation=u'For example NMDA receptor synapses', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 238, 16)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'multi_decay_syn'), MultiDecaySynapse, scope=SynapseType, documentation=u'An extension incorporating multiple decay time courses', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 244, 16)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'fac_dep_syn'), FacDepSynapse, scope=SynapseType, documentation=u'A facilitating and depressing synaptic mechanism', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 250, 16)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'stdp_syn'), StdpSynapse, scope=SynapseType, documentation=u'A synaptic mechanism implementing basic Spike Timing Dependent Plasticity based on Song and Abbott, 2001', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 256, 16)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), Authors, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), Publication, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), NeuronDBReference, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), ModelDBReference, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12)))

SynapseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), NeuroMorphoRef, scope=SynapseType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12)))

def _BuildAutomaton_9 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 210, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    counters.add(cc_9)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'status')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 210, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'electrical_syn')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 228, 16))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'doub_exp_syn')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 233, 16))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'blocking_syn')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 238, 16))
    st_12 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'multi_decay_syn')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 244, 16))
    st_13 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'fac_dep_syn')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 250, 16))
    st_14 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SynapseType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'stdp_syn')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 256, 16))
    st_15 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    st_10._set_transitionSet(transitions)
    transitions = []
    st_11._set_transitionSet(transitions)
    transitions = []
    st_12._set_transitionSet(transitions)
    transitions = []
    st_13._set_transitionSet(transitions)
    transitions = []
    st_14._set_transitionSet(transitions)
    transitions = []
    st_15._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SynapseType._Automaton = _BuildAutomaton_9()




Deprecated_Ohmic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'conductance'), CTD_ANON_16, scope=Deprecated_Ohmic, documentation=u'Description of the conductance including maximum conductance density and possible (voltage and/or concentration dependent) gating mechanisms', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 644, 12)))

def _BuildAutomaton_10 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_10
    del _BuildAutomaton_10
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_Ohmic._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'conductance')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 644, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_Ohmic._Automaton = _BuildAutomaton_10()




ImplementationPrefs._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'comment'), pyxb.binding.datatypes.string, scope=ImplementationPrefs, documentation=u'Comment element to give explination for the implementation preferences. Having a dedicated element as opposed to a <-- comment --> allows the comment to be repeated in the script file impl. ', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 692, 12)))

ImplementationPrefs._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'table_settings'), CTD_ANON, scope=ImplementationPrefs, documentation=u'Preferences for the table of values for the rate equations, e.g. used in the TABLE statement in NMODL, or in tabchannel GENESIS objects', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 697, 12)))

def _BuildAutomaton_11 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_11
    del _BuildAutomaton_11
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 692, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 697, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ImplementationPrefs._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'comment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 692, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ImplementationPrefs._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'table_settings')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 697, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ImplementationPrefs._Automaton = _BuildAutomaton_11()




RateAdjustments._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'q10_settings'), Q10Settings, scope=RateAdjustments, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 731, 12)))

RateAdjustments._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'offset'), Offset, scope=RateAdjustments, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 733, 12)))

def _BuildAutomaton_12 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_12
    del _BuildAutomaton_12
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 731, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 733, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(RateAdjustments._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'q10_settings')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 731, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RateAdjustments._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'offset')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 733, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
RateAdjustments._Automaton = _BuildAutomaton_12()




GatingComplex._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'closed_state'), ClosedState, scope=GatingComplex, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 869, 12)))

GatingComplex._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'open_state'), OpenState, scope=GatingComplex, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 870, 12)))

GatingComplex._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation'), Initialisation, scope=GatingComplex, documentation=u'For debugging/testing only! Use with caution!!', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 873, 12)))

GatingComplex._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition'), Transition, scope=GatingComplex, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 879, 12)))

GatingComplex._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'time_course'), TimeCourse, scope=GatingComplex, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 880, 12)))

GatingComplex._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'steady_state'), SteadyState, scope=GatingComplex, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 881, 12)))

def _BuildAutomaton_13 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_13
    del _BuildAutomaton_13
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 873, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 879, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 880, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 881, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(GatingComplex._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'closed_state')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 869, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(GatingComplex._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'open_state')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 870, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(GatingComplex._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 873, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(GatingComplex._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 879, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(GatingComplex._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'time_course')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 880, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(GatingComplex._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'steady_state')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 881, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
GatingComplex._Automaton = _BuildAutomaton_13()




Gate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'state'), CTD_ANON_17, scope=Gate, documentation=u'Internal state of the gate, specifying a name, and possibly a fractional contribution. \n                    HHGate or KSGate elements will specify the rate equations, etc. for the gate, referencing this state name.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 944, 12)))

def _BuildAutomaton_14 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_14
    del _BuildAutomaton_14
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=1, max=2L, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 944, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Gate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'state')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 944, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Gate._Automaton = _BuildAutomaton_14()




Deprecated_HHGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition'), Deprecated_Transition, scope=Deprecated_HHGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 969, 12)))

def _BuildAutomaton_15 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_15
    del _BuildAutomaton_15
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_HHGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 969, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_HHGate._Automaton = _BuildAutomaton_15()




Deprecated_KSGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'state'), Deprecated_KSState, scope=Deprecated_KSGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 980, 12)))

Deprecated_KSGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition'), Deprecated_Transition, scope=Deprecated_KSGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 981, 12)))

def _BuildAutomaton_16 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_16
    del _BuildAutomaton_16
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_KSGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'state')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 980, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_KSGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'transition')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 981, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_KSGate._Automaton = _BuildAutomaton_16()




Deprecated_Transition._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'voltage_gate'), Deprecated_VoltageGate, scope=Deprecated_Transition, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1124, 12)))

Deprecated_Transition._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'voltage_conc_gate'), Deprecated_VoltageConcGate, scope=Deprecated_Transition, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1125, 12)))

def _BuildAutomaton_17 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_17
    del _BuildAutomaton_17
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_Transition._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'voltage_gate')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1124, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_Transition._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'voltage_conc_gate')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1125, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_Transition._Automaton = _BuildAutomaton_17()




Deprecated_VoltageGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation'), Initialisation, scope=Deprecated_VoltageGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1163, 12)))

Deprecated_VoltageGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'tau'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1170, 12)))

Deprecated_VoltageGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'inf'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1171, 12)))

Deprecated_VoltageGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'alpha'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1280, 12)))

Deprecated_VoltageGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'beta'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1281, 12)))

Deprecated_VoltageGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'gamma'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1292, 12)))

Deprecated_VoltageGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'zeta'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12)))

def _BuildAutomaton_18 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_18
    del _BuildAutomaton_18
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1163, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1166, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1167, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1170, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1171, 12))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1163, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'alpha')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1280, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'beta')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1281, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'gamma')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1292, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'zeta')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'tau')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1170, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'inf')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1171, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True),
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False),
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False),
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Deprecated_VoltageGate._Automaton = _BuildAutomaton_18()




Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation'), Initialisation, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1184, 12)))

Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_dependence'), ConcDependence, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1186, 12)))

Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'tau'), Deprecated_RateConstVoltConcDep, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1193, 12)))

Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'inf'), Deprecated_RateConstVoltConcDep, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1194, 12)))

Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'gamma'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1292, 12)))

Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'zeta'), Deprecated_RateConstantEqnChoice, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12)))

Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'alpha'), Deprecated_RateConstVoltConcDep, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1303, 12)))

Deprecated_VoltageConcGate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'beta'), Deprecated_RateConstVoltConcDep, scope=Deprecated_VoltageConcGate, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1304, 12)))

def _BuildAutomaton_19 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_19
    del _BuildAutomaton_19
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1184, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1189, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1190, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1193, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1194, 12))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'initialisation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1184, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_dependence')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1186, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'alpha')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1303, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'beta')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1304, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'gamma')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1292, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'zeta')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1293, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'tau')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1193, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_VoltageConcGate._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'inf')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1194, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True),
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False),
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False),
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_VoltageConcGate._Automaton = _BuildAutomaton_19()




Deprecated_RateConstantEqnChoice._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameterised_hh'), Deprecated_AkdEquation, scope=Deprecated_RateConstantEqnChoice, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1319, 16)))

Deprecated_RateConstantEqnChoice._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic_equation_hh'), Deprecated_GenericEquation, scope=Deprecated_RateConstantEqnChoice, documentation=u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1320, 16)))

Deprecated_RateConstantEqnChoice._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic'), Deprecated_GenericEquation, scope=Deprecated_RateConstantEqnChoice, documentation=u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1323, 16)))

Deprecated_RateConstantEqnChoice._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Deprecated_RateConstantEqnChoice, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Deprecated_RateConstantEqnChoice._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Deprecated_RateConstantEqnChoice, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Deprecated_RateConstantEqnChoice._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Deprecated_RateConstantEqnChoice, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Deprecated_RateConstantEqnChoice._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Deprecated_RateConstantEqnChoice, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_20 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_20
    del _BuildAutomaton_20
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqnChoice._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqnChoice._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqnChoice._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqnChoice._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqnChoice._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameterised_hh')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1319, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqnChoice._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic_equation_hh')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1320, 16))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqnChoice._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1323, 16))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_RateConstantEqnChoice._Automaton = _BuildAutomaton_20()




Deprecated_RateConstVoltConcDep._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic_equation_hh'), Deprecated_GenericEquation, scope=Deprecated_RateConstVoltConcDep, documentation=u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1339, 12)))

Deprecated_RateConstVoltConcDep._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic'), Deprecated_GenericEquation, scope=Deprecated_RateConstVoltConcDep, documentation=u'Note: use generic as opposed to generic_equation_hh. The latter will be removed in v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1342, 12)))

def _BuildAutomaton_21 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_21
    del _BuildAutomaton_21
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstVoltConcDep._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic_equation_hh')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1339, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstVoltConcDep._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'generic')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1342, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_RateConstVoltConcDep._Automaton = _BuildAutomaton_21()




Deprecated_RateConstantEqn._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameter'), Deprecated_Parameter, scope=Deprecated_RateConstantEqn, documentation=u'A parameter which is used in the equation', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1355, 12)))

def _BuildAutomaton_22 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_22
    del _BuildAutomaton_22
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1355, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_RateConstantEqn._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameter')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1355, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Deprecated_RateConstantEqn._Automaton = _BuildAutomaton_22()




IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'status'), Status, scope=IonConcentration, documentation=u'Status of the ion conc mech specification: stable, in progress, etc.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1417, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion_species'), IonSpecies, scope=IonConcentration, documentation=u'Which ion is involved in mechanism.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1431, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'decaying_pool_model'), DecayingPoolModel, scope=IonConcentration, documentation=u'At present there is only one choice of a model for this process,\n                        more can be added later..', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1439, 16)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), Authors, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), Publication, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), NeuronDBReference, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), ModelDBReference, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12)))

IonConcentration._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), NeuroMorphoRef, scope=IonConcentration, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12)))

def _BuildAutomaton_23 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_23
    del _BuildAutomaton_23
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1417, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    counters.add(cc_9)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'status')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1417, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion_species')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1431, 12))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(IonConcentration._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'decaying_pool_model')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1439, 16))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
IonConcentration._Automaton = _BuildAutomaton_23()




FixedPoolInfo._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'phi'), pyxb.binding.datatypes.double, scope=FixedPoolInfo, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1569, 12)))

def _BuildAutomaton_24 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_24
    del _BuildAutomaton_24
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(FixedPoolInfo._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'phi')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1569, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
FixedPoolInfo._Automaton = _BuildAutomaton_24()




Deprecated_Parameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Deprecated_Parameter, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Deprecated_Parameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Deprecated_Parameter, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Deprecated_Parameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Deprecated_Parameter, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Deprecated_Parameter._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Deprecated_Parameter, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_25 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_25
    del _BuildAutomaton_25
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Parameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Parameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Parameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Parameter._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Deprecated_Parameter._Automaton = _BuildAutomaton_25()




Points._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'point'), Point, scope=Points, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 62, 12)))

def _BuildAutomaton_26 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_26
    del _BuildAutomaton_26
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Points._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'point')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 62, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Points._Automaton = _BuildAutomaton_26()




Sphere._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'center'), Point, scope=Sphere, documentation=u'Diameter of sphere is obtained from center Point.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 74, 12)))

def _BuildAutomaton_27 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_27
    del _BuildAutomaton_27
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Sphere._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'center')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 74, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Sphere._Automaton = _BuildAutomaton_27()




RectangularBox._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'corner'), Point, scope=RectangularBox, documentation=u'Location of vertex with lowest x, y, z coords.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 90, 12)))

RectangularBox._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'size'), CTD_ANON_, scope=RectangularBox, documentation=u'Size of box. Note if width, height or depth is zero, implies a lower dimension box, e.g. 2D plane.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 95, 12)))

def _BuildAutomaton_28 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_28
    del _BuildAutomaton_28
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RectangularBox._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'corner')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 90, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RectangularBox._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'size')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 95, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RectangularBox._Automaton = _BuildAutomaton_28()




Polyhedron._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'polygons'), CTD_ANON_2, scope=Polyhedron, documentation=u'Collection of polygons defining the polyhedron.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 153, 12)))

def _BuildAutomaton_29 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_29
    del _BuildAutomaton_29
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Polyhedron._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'polygons')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 153, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Polyhedron._Automaton = _BuildAutomaton_29()




CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'polygon'), Polygon, scope=CTD_ANON_2, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 159, 24)))

def _BuildAutomaton_30 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_30
    del _BuildAutomaton_30
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'polygon')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 159, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_2._Automaton = _BuildAutomaton_30()




def _BuildAutomaton_31 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_31
    del _BuildAutomaton_31
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 174, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.WildcardUse(pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_skip, namespace_constraint=pyxb.binding.content.Wildcard.NC_any), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 174, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Annotation._Automaton = _BuildAutomaton_31()




Property._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'tag'), pyxb.binding.datatypes.string, scope=Property, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 249, 12)))

Property._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'value'), pyxb.binding.datatypes.string, scope=Property, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 250, 12)))

def _BuildAutomaton_33 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_33
    del _BuildAutomaton_33
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Property._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'tag')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 249, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_34 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_34
    del _BuildAutomaton_34
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Property._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'value')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 250, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_32 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_32
    del _BuildAutomaton_32
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 248, 8))
    counters.add(cc_0)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_33())
    sub_automata.append(_BuildAutomaton_34())
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 248, 8)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Property._Automaton = _BuildAutomaton_32()




Properties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'property'), Property, scope=Properties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 263, 12)))

def _BuildAutomaton_35 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_35
    del _BuildAutomaton_35
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 263, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Properties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'property')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 263, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Properties._Automaton = _BuildAutomaton_35()




PropertyDetail._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'description'), pyxb.binding.datatypes.string, scope=PropertyDetail, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 274, 12)))

PropertyDetail._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'type'), pyxb.binding.datatypes.anyType, scope=PropertyDetail, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 275, 12)))

def _BuildAutomaton_37 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_37
    del _BuildAutomaton_37
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PropertyDetail._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'description')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 274, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_38 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_38
    del _BuildAutomaton_38
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PropertyDetail._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'type')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 275, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_36 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_36
    del _BuildAutomaton_36
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_37())
    sub_automata.append(_BuildAutomaton_38())
    final_update = set()
    symbol = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 273, 8)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PropertyDetail._Automaton = _BuildAutomaton_36()




GroupDetail._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'description'), pyxb.binding.datatypes.string, scope=GroupDetail, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 287, 12)))

GroupDetail._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=GroupDetail, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 288, 12)))

def _BuildAutomaton_39 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_39
    del _BuildAutomaton_39
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 288, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(GroupDetail._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'description')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 287, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(GroupDetail._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 288, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
GroupDetail._Automaton = _BuildAutomaton_39()




NeuroMorphoRef._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'morphologyRef'), pyxb.binding.datatypes.string, scope=NeuroMorphoRef, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 414, 12)))

NeuroMorphoRef._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri'), pyxb.binding.datatypes.string, scope=NeuroMorphoRef, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 415, 12)))

NeuroMorphoRef._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), pyxb.binding.datatypes.string, scope=NeuroMorphoRef, documentation=u'Comment on how this morphology relates to the current model', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 416, 12)))

def _BuildAutomaton_41 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_41
    del _BuildAutomaton_41
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NeuroMorphoRef._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'morphologyRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 414, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_42 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_42
    del _BuildAutomaton_42
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NeuroMorphoRef._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 415, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_43 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_43
    del _BuildAutomaton_43
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 416, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMorphoRef._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 416, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)

def _BuildAutomaton_40 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_40
    del _BuildAutomaton_40
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 416, 12))
    counters.add(cc_0)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_41())
    sub_automata.append(_BuildAutomaton_42())
    sub_automata.append(_BuildAutomaton_43())
    final_update = set()
    symbol = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 413, 8)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
NeuroMorphoRef._Automaton = _BuildAutomaton_40()




NeuronDBReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelName'), pyxb.binding.datatypes.string, scope=NeuronDBReference, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 433, 12)))

NeuronDBReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri'), pyxb.binding.datatypes.string, scope=NeuronDBReference, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 434, 12)))

NeuronDBReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), pyxb.binding.datatypes.string, scope=NeuronDBReference, documentation=u'Comment on how this neuron relates to the current model', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 435, 12)))

def _BuildAutomaton_45 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_45
    del _BuildAutomaton_45
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NeuronDBReference._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelName')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 433, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_46 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_46
    del _BuildAutomaton_46
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NeuronDBReference._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 434, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_47 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_47
    del _BuildAutomaton_47
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 435, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(NeuronDBReference._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 435, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)

def _BuildAutomaton_44 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_44
    del _BuildAutomaton_44
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 435, 12))
    counters.add(cc_0)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_45())
    sub_automata.append(_BuildAutomaton_46())
    sub_automata.append(_BuildAutomaton_47())
    final_update = set()
    symbol = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 432, 8)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
NeuronDBReference._Automaton = _BuildAutomaton_44()




ModelDBReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelName'), pyxb.binding.datatypes.string, scope=ModelDBReference, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 452, 12)))

ModelDBReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri'), pyxb.binding.datatypes.string, scope=ModelDBReference, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 453, 12)))

ModelDBReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), pyxb.binding.datatypes.string, scope=ModelDBReference, documentation=u'Comment on how this model relates to the current model in NeuroML', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 454, 12)))

def _BuildAutomaton_49 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_49
    del _BuildAutomaton_49
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ModelDBReference._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelName')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 452, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_50 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_50
    del _BuildAutomaton_50
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ModelDBReference._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'uri')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 453, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_51 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_51
    del _BuildAutomaton_51
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 454, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ModelDBReference._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 454, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)

def _BuildAutomaton_48 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_48
    del _BuildAutomaton_48
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 454, 12))
    counters.add(cc_0)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_49())
    sub_automata.append(_BuildAutomaton_50())
    sub_automata.append(_BuildAutomaton_51())
    final_update = set()
    symbol = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 451, 8)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ModelDBReference._Automaton = _BuildAutomaton_48()




Publication._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'fullTitle'), pyxb.binding.datatypes.string, scope=Publication, documentation=u'A reasonably complete reference to the paper, etc. including journal, authors, issue, year. \n                    Mainly for quick recognition of the paper. The PubMed ref should contain the unique ID.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 472, 12)))

Publication._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'pubmedRef'), pyxb.binding.datatypes.string, scope=Publication, documentation=u'URL of paper in PubMed (starting with http://www.ncbi.nlm.nih.gov)', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 478, 12)))

Publication._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), pyxb.binding.datatypes.string, scope=Publication, documentation=u'Comment on how this publication relates to the current model', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 483, 12)))

def _BuildAutomaton_53 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_53
    del _BuildAutomaton_53
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Publication._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'fullTitle')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 472, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_54 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_54
    del _BuildAutomaton_54
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Publication._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'pubmedRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 478, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)

def _BuildAutomaton_55 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_55
    del _BuildAutomaton_55
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 483, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Publication._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 483, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)

def _BuildAutomaton_52 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_52
    del _BuildAutomaton_52
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 483, 12))
    counters.add(cc_0)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_53())
    sub_automata.append(_BuildAutomaton_54())
    sub_automata.append(_BuildAutomaton_55())
    final_update = set()
    symbol = pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 471, 8)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Publication._Automaton = _BuildAutomaton_52()




Authors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelAuthor'), Person, scope=Authors, documentation=u'Author of the original model', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 499, 12)))

Authors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelTranslator'), Person, scope=Authors, documentation=u'Person who translated the model to NeuroML', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 504, 12)))

def _BuildAutomaton_56 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_56
    del _BuildAutomaton_56
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 499, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 504, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Authors._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelAuthor')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 499, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Authors._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelTranslator')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 504, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Authors._Automaton = _BuildAutomaton_56()




Person._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'name'), pyxb.binding.datatypes.string, scope=Person, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 518, 12)))

Person._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'institution'), pyxb.binding.datatypes.string, scope=Person, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 520, 12)))

Person._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'email'), pyxb.binding.datatypes.string, scope=Person, documentation=u"Useful to have. Note: something like '- at -' replacing the @ might be wise, in case a HTML version of the file goes online.", location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 522, 12)))

Person._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), pyxb.binding.datatypes.string, scope=Person, documentation=u'Optional comment on their specific contribution', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 527, 12)))

def _BuildAutomaton_57 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_57
    del _BuildAutomaton_57
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 520, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 522, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 527, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Person._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'name')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 518, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Person._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'institution')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 520, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Person._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'email')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 522, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Person._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 527, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Person._Automaton = _BuildAutomaton_57()




CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'feature'), Feature, scope=CTD_ANON_3, documentation=u'A single feature of note.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 46, 24)))

def _BuildAutomaton_58 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_58
    del _BuildAutomaton_58
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'feature')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 46, 24))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_3._Automaton = _BuildAutomaton_58()




CTD_ANON_4._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'propertyDetail'), PropertyDetail, scope=CTD_ANON_4, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 69, 24)))

def _BuildAutomaton_59 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_59
    del _BuildAutomaton_59
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_4._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'propertyDetail')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 69, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_4._Automaton = _BuildAutomaton_59()




CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'groupDetail'), GroupDetail, scope=CTD_ANON_5, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 84, 24)))

def _BuildAutomaton_60 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_60
    del _BuildAutomaton_60
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'groupDetail')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 84, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_5._Automaton = _BuildAutomaton_60()




Cells._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'cell'), Cell, scope=Cells, documentation=u'A single cell.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 126, 16)))

def _BuildAutomaton_61 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_61
    del _BuildAutomaton_61
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Cells._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cell')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 126, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Cells._Automaton = _BuildAutomaton_61()




Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), Authors, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), Publication, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), NeuronDBReference, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), ModelDBReference, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), NeuroMorphoRef, scope=Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'status'), Status, scope=Cell, documentation=u'Status of the cell model: stable, in progress, etc.\n                    Further test comments explaining the current status should be added.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 142, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'segments'), CTD_ANON_6, scope=Cell, documentation=u'A segment defines the smallest unit within a possibly branching structure, such as a dendrite or axon. The first segment should represent the soma, if needed for downstream applications.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 154, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'cables'), CTD_ANON_7, scope=Cell, documentation=u'The collection of cables. Each cable will be associated with a number of connected segments.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 189, 24)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'cellBody'), CTD_ANON_8, scope=Cell, documentation=u'Used for anatomical representation of the soma. Use a Segment with equivalent properties to retain connectivity of branches to the soma for downstream applications (e.g. neuronal simulators).', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 224, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'spines'), CTD_ANON_9, scope=Cell, documentation=u'The collection of spines.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 241, 12)))

Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'freePoints'), FreePoints, scope=Cell, documentation=u'The collection of varicosities or synaptic connections.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 260, 12)))

def _BuildAutomaton_62 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_62
    del _BuildAutomaton_62
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 142, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 189, 24))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 224, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 241, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 260, 12))
    counters.add(cc_13)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'status')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 142, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'segments')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 154, 12))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cables')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 189, 24))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cellBody')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 224, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'spines')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 241, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'freePoints')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 260, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_13, True) ]))
    st_14._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Cell._Automaton = _BuildAutomaton_62()




CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=CTD_ANON_6, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=CTD_ANON_6, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=CTD_ANON_6, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=CTD_ANON_6, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'segment'), Segment, scope=CTD_ANON_6, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 163, 24)))

def _BuildAutomaton_63 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_63
    del _BuildAutomaton_63
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'segment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 163, 24))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_6._Automaton = _BuildAutomaton_63()




CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=CTD_ANON_7, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=CTD_ANON_7, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=CTD_ANON_7, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=CTD_ANON_7, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'cable'), Cable, scope=CTD_ANON_7, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 197, 24)))

CTD_ANON_7._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'cablegroup'), CableGroup, scope=CTD_ANON_7, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 198, 24)))

def _BuildAutomaton_64 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_64
    del _BuildAutomaton_64
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 198, 24))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cable')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 197, 24))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cablegroup')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 198, 24))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_7._Automaton = _BuildAutomaton_64()




CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=CTD_ANON_8, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=CTD_ANON_8, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=CTD_ANON_8, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=CTD_ANON_8, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'polygon'), Polygon, scope=CTD_ANON_8, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 232, 28)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'polyhedron'), Polyhedron, scope=CTD_ANON_8, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 233, 28)))

CTD_ANON_8._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'sphere'), Sphere, scope=CTD_ANON_8, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 234, 28)))

def _BuildAutomaton_65 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_65
    del _BuildAutomaton_65
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'polygon')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 232, 28))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'polyhedron')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 233, 28))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'sphere')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 234, 28))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_8._Automaton = _BuildAutomaton_65()




CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=CTD_ANON_9, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=CTD_ANON_9, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=CTD_ANON_9, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=CTD_ANON_9, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'spine'), Spine, scope=CTD_ANON_9, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 248, 24)))

def _BuildAutomaton_66 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_66
    del _BuildAutomaton_66
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'spine')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 248, 24))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_9._Automaton = _BuildAutomaton_66()




CableGroup._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'cable'), CTD_ANON_10, scope=CableGroup, documentation=u'The id of a single cable in the group', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 375, 12)))

CableGroup._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'inhomogeneous_param'), InhomogeneousParam, scope=CableGroup, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 386, 12)))

def _BuildAutomaton_67 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_67
    del _BuildAutomaton_67
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 386, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CableGroup._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cable')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 375, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CableGroup._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'inhomogeneous_param')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 386, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CableGroup._Automaton = _BuildAutomaton_67()




InhomogeneousParam._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'metric'), Metric, scope=InhomogeneousParam, documentation=u'The metric used to determine the variable', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 414, 12)))

InhomogeneousParam._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal'), CTD_ANON_11, scope=InhomogeneousParam, documentation=u'Information on the value of the variable at the proximal point. If this element is absent,\n                    the value of the variable is determined simply from the metric, e.g. absolute path length', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 420, 12)))

InhomogeneousParam._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal'), CTD_ANON_12, scope=InhomogeneousParam, documentation=u'Information on the value of the variable at the distal point. If this element is absent, the\n                    value of the variable is determined simply from the metric, e.g. path length', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 434, 12)))

def _BuildAutomaton_68 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_68
    del _BuildAutomaton_68
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 420, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 434, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(InhomogeneousParam._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'metric')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 414, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(InhomogeneousParam._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 420, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(InhomogeneousParam._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 434, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
InhomogeneousParam._Automaton = _BuildAutomaton_68()




Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'path'), Path, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 530, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'freePoints'), FreePoints, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 531, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'manifold'), Manifold, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 532, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'polygon'), Polygon, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 533, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'polyhedron'), Polyhedron, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 534, 12)))

Feature._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'sphere'), Sphere, scope=Feature, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 535, 12)))

def _BuildAutomaton_69 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_69
    del _BuildAutomaton_69
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 530, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 531, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 532, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 533, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 534, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 535, 12))
    counters.add(cc_9)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'path')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 530, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'freePoints')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 531, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'manifold')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 532, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'polygon')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 533, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'polyhedron')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 534, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(Feature._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'sphere')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 535, 12))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Feature._Automaton = _BuildAutomaton_69()




Populations._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Populations, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Populations._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Populations, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Populations._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Populations, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Populations._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Populations, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Populations._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'population'), Population, scope=Populations, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 124, 16)))

def _BuildAutomaton_70 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_70
    del _BuildAutomaton_70
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Populations._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Populations._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Populations._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Populations._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Populations._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'population')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 124, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Populations._Automaton = _BuildAutomaton_70()




Input._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Input, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Input._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Input, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Input._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Input, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Input._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Input, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Input._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'pulse_input'), PulseInput, scope=Input, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 178, 20)))

Input._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'random_stim'), RandomStim, scope=Input, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 179, 20)))

Input._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'target'), InputTarget, scope=Input, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 182, 18)))

def _BuildAutomaton_71 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_71
    del _BuildAutomaton_71
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Input._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Input._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Input._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Input._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Input._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'pulse_input')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 178, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Input._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'random_stim')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 179, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Input._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'target')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 182, 18))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Input._Automaton = _BuildAutomaton_71()




InputTarget._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=InputTarget, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

InputTarget._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=InputTarget, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

InputTarget._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=InputTarget, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

InputTarget._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=InputTarget, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

InputTarget._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'sites'), InputSites, scope=InputTarget, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 241, 20)))

InputTarget._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'site_pattern'), InputSitePattern, scope=InputTarget, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 242, 20)))

def _BuildAutomaton_72 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_72
    del _BuildAutomaton_72
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputTarget._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputTarget._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputTarget._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputTarget._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(InputTarget._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'sites')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 241, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(InputTarget._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'site_pattern')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 242, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
InputTarget._Automaton = _BuildAutomaton_72()




InputSitePattern._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'all_cells'), CTD_ANON_13, scope=InputSitePattern, documentation=u'Apply input on all cells in group', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 273, 16)))

InputSitePattern._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'percentage_cells'), CTD_ANON_18, scope=InputSitePattern, documentation=u'Apply input to a certain percentage of cells in a group', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 279, 16)))

def _BuildAutomaton_73 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_73
    del _BuildAutomaton_73
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(InputSitePattern._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'all_cells')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 273, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(InputSitePattern._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'percentage_cells')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 279, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
InputSitePattern._Automaton = _BuildAutomaton_73()




InputSites._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=InputSites, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

InputSites._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=InputSites, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

InputSites._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=InputSites, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

InputSites._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=InputSites, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

InputSites._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'site'), InputSite, scope=InputSites, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 302, 16)))

def _BuildAutomaton_74 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_74
    del _BuildAutomaton_74
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputSites._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputSites._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputSites._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InputSites._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(InputSites._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'site')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 302, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
InputSites._Automaton = _BuildAutomaton_74()




Population._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Population, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Population._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Population, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Population._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Population, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Population._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Population, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Population._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'cell_type'), pyxb.binding.datatypes.string, scope=Population, documentation=u'The cell type for this population. NOTE: an attribute value for cell_type WILL BE PREFERRED FORMAT IN v2.0. The option for this element will be removed!', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 344, 16)))

Population._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'instances'), Instances, scope=Population, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 354, 20)))

Population._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'pop_location'), PopulationLocation, scope=Population, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 355, 20)))

def _BuildAutomaton_75 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_75
    del _BuildAutomaton_75
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 344, 16))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Population._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Population._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Population._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Population._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Population._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'cell_type')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 344, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Population._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'instances')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 354, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Population._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'pop_location')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 355, 20))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Population._Automaton = _BuildAutomaton_75()




Instances._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Instances, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Instances._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Instances, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Instances._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Instances, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Instances._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Instances, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Instances._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'instance'), CellInstance, scope=Instances, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 382, 16)))

def _BuildAutomaton_76 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_76
    del _BuildAutomaton_76
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Instances._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Instances._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Instances._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Instances._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Instances._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'instance')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 382, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Instances._Automaton = _BuildAutomaton_76()




Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Projection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Projection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Projection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Projection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'source'), pyxb.binding.datatypes.string, scope=Projection, documentation=u'Cell population where synaptic connection begins. NOTE: attribute values for source and target WILL BE THE PREFERRED FORMAT IN v2.0. The option for this element will be removed!', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 405, 16)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'target'), pyxb.binding.datatypes.string, scope=Projection, documentation=u'Cell population where synaptic connection terminates. NOTE: attribute values for source and target WILL BE THE PREFERRED FORMAT IN v2.0. The option for this element will be removed!', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 410, 16)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_props'), GlobalSynapticProperties, scope=Projection, documentation=u'Properties of a synapse associated with this connection.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 416, 16)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'connections'), Connections, scope=Projection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 427, 20)))

Projection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'connectivity_pattern'), ConnectivityPattern, scope=Projection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 428, 20)))

def _BuildAutomaton_77 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_77
    del _BuildAutomaton_77
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 405, 16))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 410, 16))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'source')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 405, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'target')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 410, 16))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_props')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 416, 16))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'connections')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 427, 20))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Projection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'connectivity_pattern')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 428, 20))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    st_7._set_transitionSet(transitions)
    transitions = []
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Projection._Automaton = _BuildAutomaton_77()




SynapseProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=SynapseProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

SynapseProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=SynapseProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

SynapseProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=SynapseProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

SynapseProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=SynapseProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

SynapseProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type'), pyxb.binding.datatypes.string, scope=SynapseProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 462, 16)))

SynapseProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'default_values'), SynapseInternalProperties, scope=SynapseProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 463, 16)))

def _BuildAutomaton_78 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_78
    del _BuildAutomaton_78
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SynapseProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 462, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SynapseProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'default_values')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 463, 16))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SynapseProperties._Automaton = _BuildAutomaton_78()




ConnectivityPattern._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'all_to_all'), CTD_ANON_14, scope=ConnectivityPattern, documentation=u'Connect every pre cell to every post cell', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 578, 16)))

ConnectivityPattern._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'fixed_probability'), CTD_ANON_19, scope=ConnectivityPattern, documentation=u'For each pre - post pair, there is a fixed probability of connection', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 584, 16)))

ConnectivityPattern._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'per_cell_connection'), PerCellConnection, scope=ConnectivityPattern, documentation=u'Connection built iteratively from each pre (or post) cell based on a number of parameters', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 592, 16)))

def _BuildAutomaton_79 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_79
    del _BuildAutomaton_79
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ConnectivityPattern._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'all_to_all')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 578, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ConnectivityPattern._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'fixed_probability')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 584, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ConnectivityPattern._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'per_cell_connection')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 592, 16))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ConnectivityPattern._Automaton = _BuildAutomaton_79()




Connections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Connections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Connections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Connections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Connections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Connections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Connections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Connections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Connections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'connection'), Connection, scope=Connections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 636, 16)))

def _BuildAutomaton_80 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_80
    del _BuildAutomaton_80
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Connections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Connections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Connections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Connections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Connections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'connection')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 636, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Connections._Automaton = _BuildAutomaton_80()




CellInstance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=CellInstance, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

CellInstance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=CellInstance, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

CellInstance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=CellInstance, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

CellInstance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=CellInstance, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

CellInstance._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'location'), Point3D, scope=CellInstance, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 657, 16)))

def _BuildAutomaton_81 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_81
    del _BuildAutomaton_81
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CellInstance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CellInstance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CellInstance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CellInstance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CellInstance._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'location')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 657, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CellInstance._Automaton = _BuildAutomaton_81()




PopulationLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=PopulationLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

PopulationLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=PopulationLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

PopulationLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=PopulationLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

PopulationLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=PopulationLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

PopulationLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'random_arrangement'), RandomArrangement, scope=PopulationLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 780, 20)))

PopulationLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'grid_arrangement'), GridArrangement, scope=PopulationLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 781, 20)))

def _BuildAutomaton_82 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_82
    del _BuildAutomaton_82
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PopulationLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PopulationLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PopulationLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PopulationLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PopulationLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'random_arrangement')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 780, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PopulationLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'grid_arrangement')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 781, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PopulationLocation._Automaton = _BuildAutomaton_82()




RandomArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=RandomArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

RandomArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=RandomArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

RandomArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=RandomArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

RandomArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=RandomArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

RandomArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'population_size'), pyxb.binding.datatypes.nonNegativeInteger, scope=RandomArrangement, documentation=u'Number of cells to place randomly in the specified 3D location', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 798, 16)))

RandomArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'spherical_location'), Sphere, scope=RandomArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 804, 20)))

RandomArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'rectangular_location'), RectangularBox, scope=RandomArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 805, 20)))

def _BuildAutomaton_83 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_83
    del _BuildAutomaton_83
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RandomArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RandomArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RandomArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RandomArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RandomArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'population_size')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 798, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RandomArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'spherical_location')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 804, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RandomArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'rectangular_location')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 805, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RandomArrangement._Automaton = _BuildAutomaton_83()




GridArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=GridArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

GridArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=GridArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

GridArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=GridArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

GridArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=GridArrangement, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

GridArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'non_spatial_grid'), NonSpatialGrid, scope=GridArrangement, documentation=u'Specifying this means the precise spatial location of the cells is irrelvant', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 822, 20)))

GridArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'rectangular_location'), RectangularBox, scope=GridArrangement, documentation=u'3D box in which the cells are regularly packed. Note if one or two of dimensions of the box is zero it can be a 2D or 1D grid (respectively).', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 842, 16)))

GridArrangement._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'spacing'), CTD_ANON_15, scope=GridArrangement, documentation=u'Separation of the cells in each dimension', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 849, 16)))

def _BuildAutomaton_84 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_84
    del _BuildAutomaton_84
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(GridArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(GridArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(GridArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(GridArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(GridArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'rectangular_location')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 842, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(GridArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'spacing')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 849, 16))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(GridArrangement._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'non_spatial_grid')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 822, 20))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
GridArrangement._Automaton = _BuildAutomaton_84()




Level3Connectivity._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'potential_syn_loc'), PotentialSynLoc, scope=Level3Connectivity, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 870, 16)))

def _BuildAutomaton_85 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_85
    del _BuildAutomaton_85
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 870, 16))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Level3Connectivity._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'potential_syn_loc')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 870, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Level3Connectivity._Automaton = _BuildAutomaton_85()




PotentialSynapticLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=PotentialSynapticLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

PotentialSynapticLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=PotentialSynapticLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

PotentialSynapticLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=PotentialSynapticLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

PotentialSynapticLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=PotentialSynapticLocation, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

PotentialSynapticLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type'), pyxb.binding.datatypes.string, scope=PotentialSynapticLocation, documentation=u'Which of the synaptic mechanisms can be present', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 918, 20)))

PotentialSynapticLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_direction'), SynapseDirection, scope=PotentialSynapticLocation, documentation=u'Whether this synapse location allows a presynaptic connection, a postsynaptic\n                                connection or either', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 923, 20)))

PotentialSynapticLocation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'group'), pyxb.binding.datatypes.string, scope=PotentialSynapticLocation, documentation=u'List of groups of sections allowing the synapse', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 929, 20)))

def _BuildAutomaton_86 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_86
    del _BuildAutomaton_86
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 923, 20))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynapticLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynapticLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynapticLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynapticLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynapticLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 918, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynapticLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_direction')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 923, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PotentialSynapticLocation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 929, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PotentialSynapticLocation._Automaton = _BuildAutomaton_86()




Level3Cells._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace, u'cell'), Level3Cell, scope=Level3Cells, documentation=u'A single cell specified in MorphML extended to include channel density info.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 101, 16)))

def _BuildAutomaton_87 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_87
    del _BuildAutomaton_87
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Level3Cells._UseForTag(pyxb.namespace.ExpandedName(_Namespace, u'cell')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 101, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Level3Cells._Automaton = _BuildAutomaton_87()




Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'mechanism'), Mechanism, scope=Biophysics, documentation=u'Definition of placement of a single electrophysiological mechanism (e.g. channel mechanism)\n                        on a group of cables of a cell. Note there should be at least one of these to specify the passive membrane conductance.\n                        Note: elements spec_capacitance, spec_axial_resistance, ion_props etc. should be used in preference to specificCapacitance etc!', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 50, 12)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificCapacitance'), SpecCapacitance, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 58, 16)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_capacitance'), SpecCapacitance, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 59, 16)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificAxialResistance'), SpecAxialResistance, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 62, 16)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_axial_resistance'), SpecAxialResistance, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 63, 16)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'initialMembPotential'), InitialMembPotential, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 66, 16)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'init_memb_potential'), InitialMembPotential, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 67, 16)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'ionProperties'), IonProperties, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 70, 16)))

Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'ion_props'), IonProperties, scope=Biophysics, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 71, 16)))

def _BuildAutomaton_88 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_88
    del _BuildAutomaton_88
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 66, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 67, 16))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 70, 16))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 71, 16))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'mechanism')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 50, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificCapacitance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 58, 16))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_capacitance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 59, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificAxialResistance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 62, 16))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_axial_resistance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 63, 16))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'initialMembPotential')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 66, 16))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'init_memb_potential')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 67, 16))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'ionProperties')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 70, 16))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'ion_props')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 71, 16))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Biophysics._Automaton = _BuildAutomaton_88()




Mechanism._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter'), NamedParameter, scope=Mechanism, location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 93, 12)))

Mechanism._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter'), VariableNamedParameter, scope=Mechanism, documentation=u'Note variable_parameter will be the preferred form in v2.0', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 94, 12)))

Mechanism._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter'), VariableNamedParameter, scope=Mechanism, documentation=u'Note variable_parameter will be the preferred form in v2.0', location=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 99, 12)))

def _BuildAutomaton_89 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_89
    del _BuildAutomaton_89
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 93, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 94, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 99, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Mechanism._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 93, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Mechanism._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'variableParameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 94, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Mechanism._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'variable_parameter')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 99, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Mechanism._Automaton = _BuildAutomaton_89()




ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion'), Deprecated_Ion, scope=ChannelML, documentation=u'One or more ions which play some role in the mechanism, e.g. transmitted by the channel, alters the rate, etc. Note: deprecated since v1.7.3', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 68, 12)))

ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'channel_type'), ChannelType, scope=ChannelML, documentation=u'Specification of a voltage or ligand gated membrane conductance mechanism', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 73, 12)))

ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'synapse_type'), SynapseType, scope=ChannelML, documentation=u'Specification of a synaptic conductance, triggered by a presynaptic event', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 78, 12)))

ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion_concentration'), IonConcentration, scope=ChannelML, documentation=u'Specification of how an ion concentration alters with time, e.g. calcium dynamics. This may influence other\n                   channels (e.g. Ca dependent K channels), and other mechanisms may have a contribution to the concentration of the ion specified here\n                   (e.g. a channel transmitting calcium).', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 83, 12)))

ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=ChannelML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=ChannelML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=ChannelML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

ChannelML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=ChannelML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_90 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_90
    del _BuildAutomaton_90
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 68, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 73, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 78, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 83, 12))
    counters.add(cc_7)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 68, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'channel_type')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 73, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'synapse_type')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 78, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(ChannelML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'ion_concentration')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 83, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ChannelML._Automaton = _BuildAutomaton_90()




ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'status'), Status, scope=ChannelType, documentation=u'Status of the channel specification: stable, in progress, etc.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 138, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameters'), Parameters, scope=ChannelType, documentation=u'Fixed value parameters which can be used in generic expressions', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 153, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'current_voltage_relation'), CurrentVoltageRelation, scope=ChannelType, documentation=u'The specification of how the current flow etc. into the cell relates to the membrane potential \n                    difference (e.g. Ohmic relationship)', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 161, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'hh_gate'), Deprecated_HHGate, scope=ChannelType, documentation=u'Channel specification based on the Hodgkin Huxley formalism. Deprecated! Will be removed in v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 169, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'ks_gate'), Deprecated_KSGate, scope=ChannelType, documentation=u'Channel specification based on a kinetic scheme formalism. Deprecated! Will be removed in v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 175, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'impl_prefs'), ImplementationPrefs, scope=ChannelType, documentation=u'Optional recommended values, e.g. for size of tables, when creating an implementation of the \n                    channel mechanism on a specific simulator', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 181, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), Authors, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), Publication, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), NeuronDBReference, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), ModelDBReference, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12)))

ChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), NeuroMorphoRef, scope=ChannelType, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12)))

def _BuildAutomaton_91 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_91
    del _BuildAutomaton_91
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 138, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 153, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 169, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 175, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 181, 12))
    counters.add(cc_13)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'status')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 138, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameters')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 153, 12))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'current_voltage_relation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 161, 12))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'hh_gate')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 169, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'ks_gate')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 175, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(ChannelType._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'impl_prefs')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 181, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_13, True) ]))
    st_14._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ChannelType._Automaton = _BuildAutomaton_91()




ElectricalSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=ElectricalSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

ElectricalSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=ElectricalSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

ElectricalSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=ElectricalSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

ElectricalSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=ElectricalSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_92 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_92
    del _BuildAutomaton_92
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ElectricalSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ElectricalSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ElectricalSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ElectricalSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ElectricalSynapse._Automaton = _BuildAutomaton_92()




DoubleExponentialSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=DoubleExponentialSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

DoubleExponentialSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=DoubleExponentialSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

DoubleExponentialSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=DoubleExponentialSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

DoubleExponentialSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=DoubleExponentialSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_93 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_93
    del _BuildAutomaton_93
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(DoubleExponentialSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(DoubleExponentialSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(DoubleExponentialSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(DoubleExponentialSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
DoubleExponentialSynapse._Automaton = _BuildAutomaton_93()




CurrentVoltageRelation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'ohmic'), Deprecated_Ohmic, scope=CurrentVoltageRelation, documentation=u'Deprecated since v1.7.3. Use attribute cond_law and gate elements below this element instead. ', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 491, 12)))

CurrentVoltageRelation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'integrate_and_fire'), IntegrateAndFire, scope=CurrentVoltageRelation, documentation=u'Note: use attribute cond_law="integrate_and_fire" and no other attributes here when using this. \n                    Signifies a current which will cause the cell to behave like an integrate and fire neuron', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 497, 12)))

CurrentVoltageRelation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_dependence'), ConcDependence, scope=CurrentVoltageRelation, documentation=u'Preferred location of conc_dependence since v1.7.3. ', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 504, 12)))

CurrentVoltageRelation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_factor'), ConcFactor, scope=CurrentVoltageRelation, documentation=u'Preferred location of conc_factor since v1.7.3. ', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 510, 12)))

CurrentVoltageRelation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'q10_settings'), Q10Settings, scope=CurrentVoltageRelation, documentation=u'Preferred location of Q10 information since v1.7.3. ', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 516, 12)))

CurrentVoltageRelation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'offset'), Offset, scope=CurrentVoltageRelation, documentation=u'Preferred location of offset information since v1.7.3. ', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 522, 12)))

CurrentVoltageRelation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'gate'), GatingComplex, scope=CurrentVoltageRelation, documentation=u'Preferred way of expressing gating complexes since v1.7.3. ', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 528, 12)))

def _BuildAutomaton_94 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_94
    del _BuildAutomaton_94
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 491, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 497, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 504, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 510, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 516, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 522, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 528, 12))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentVoltageRelation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'ohmic')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 491, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CurrentVoltageRelation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'integrate_and_fire')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 497, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CurrentVoltageRelation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_dependence')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 504, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CurrentVoltageRelation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_factor')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 510, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CurrentVoltageRelation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'q10_settings')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 516, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CurrentVoltageRelation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'offset')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 522, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CurrentVoltageRelation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'gate')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 528, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentVoltageRelation._Automaton = _BuildAutomaton_94()




CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'rate_adjustments'), RateAdjustments, scope=CTD_ANON_16, documentation=u'Adjustments, e.g. temperature dependence, to apply to the gating mechanisms', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 651, 24)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_factor'), ConcFactor, scope=CTD_ANON_16, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 656, 24)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'gate'), Gate, scope=CTD_ANON_16, documentation=u'Voltage/concentration dependent gate', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 658, 24)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=CTD_ANON_16, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=CTD_ANON_16, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=CTD_ANON_16, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=CTD_ANON_16, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_95 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_95
    del _BuildAutomaton_95
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 651, 24))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 656, 24))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 658, 24))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'rate_adjustments')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 651, 24))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'conc_factor')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 656, 24))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'gate')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 658, 24))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_16._Automaton = _BuildAutomaton_95()




Deprecated_Ion._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Deprecated_Ion, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Deprecated_Ion._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Deprecated_Ion, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Deprecated_Ion._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Deprecated_Ion, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Deprecated_Ion._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Deprecated_Ion, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_96 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_96
    del _BuildAutomaton_96
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Ion._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Ion._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Ion._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_Ion._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Deprecated_Ion._Automaton = _BuildAutomaton_96()




def _BuildAutomaton_97 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_97
    del _BuildAutomaton_97
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=3L, max=3L, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1374, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Deprecated_AkdEquation._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'parameter')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1374, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Deprecated_AkdEquation._Automaton = _BuildAutomaton_97()




DecayingPoolModel._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'resting_conc'), ConcentrationValue, scope=DecayingPoolModel, documentation=u'Resting concentration of ion. NOTE: In v2.0 this element will be removed. Attribute resting_conc will be used instead.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1474, 12)))

DecayingPoolModel._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'decay_constant'), TimeConstantValue, scope=DecayingPoolModel, documentation=u'Exponential decay time of pool. NOTE: In v2.0 this element will be removed. Attribute decay_constant will be used instead.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1480, 16)))

DecayingPoolModel._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'inv_decay_constant'), InvTimeConstantValue, scope=DecayingPoolModel, documentation=u'Reciprocal of exponential decay time constant of pool', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1485, 16)))

DecayingPoolModel._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'ceiling'), ConcentrationValue, scope=DecayingPoolModel, documentation=u'The maximum concentration which the ion pool should be allowed get to. NOTE: In v2.0 this element will be removed. Attribute ceiling will be used instead.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1491, 12)))

DecayingPoolModel._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'pool_volume_info'), PoolVolumeInfo, scope=DecayingPoolModel, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1497, 16)))

DecayingPoolModel._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'fixed_pool_info'), FixedPoolInfo, scope=DecayingPoolModel, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1498, 16)))

def _BuildAutomaton_98 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_98
    del _BuildAutomaton_98
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1474, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1480, 16))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1491, 12))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(DecayingPoolModel._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'resting_conc')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1474, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(DecayingPoolModel._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'decay_constant')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1480, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(DecayingPoolModel._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'inv_decay_constant')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1485, 16))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(DecayingPoolModel._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'ceiling')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1491, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DecayingPoolModel._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'pool_volume_info')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1497, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DecayingPoolModel._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'fixed_pool_info')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1498, 16))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
DecayingPoolModel._Automaton = _BuildAutomaton_98()




PoolVolumeInfo._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'shell_thickness'), LengthValue, scope=PoolVolumeInfo, documentation=u'The volume of the pool is calculated from the thickness of the shell inside\n                    the membrane. This will have to be multiplied by the surface area of the relevant compartment. NOTE: In v2.0 the option for \n                    a shell_thickness element will be removed. Attribute shell_thickness will be used instead.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1539, 12)))

def _BuildAutomaton_99 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_99
    del _BuildAutomaton_99
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1539, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(PoolVolumeInfo._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'shell_thickness')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 1539, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
PoolVolumeInfo._Automaton = _BuildAutomaton_99()




def _BuildAutomaton_100 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_100
    del _BuildAutomaton_100
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Manifold._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'point')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 62, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Manifold._Automaton = _BuildAutomaton_100()




def _BuildAutomaton_101 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_101
    del _BuildAutomaton_101
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Polygon._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'point')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 62, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Polygon._Automaton = _BuildAutomaton_101()




Status._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment'), pyxb.binding.datatypes.string, scope=Status, documentation=u'A comment on the current status. Not necessarily signalling a problem.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 569, 12)))

Status._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'issue'), pyxb.binding.datatypes.string, scope=Status, documentation=u'An issue which need addressing', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 574, 12)))

Status._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'contributor'), Person, scope=Status, documentation=u'Who added the comments?', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 579, 12)))

def _BuildAutomaton_102 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_102
    del _BuildAutomaton_102
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 569, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 574, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 579, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Status._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'comment')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 569, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Status._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'issue')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 574, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Status._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'contributor')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 579, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Status._Automaton = _BuildAutomaton_102()




Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Morphology, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Morphology, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Morphology, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Morphology, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'cells'), Cells, scope=Morphology, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 37, 12)))

Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'features'), CTD_ANON_3, scope=Morphology, documentation=u'Collection of all extracellular histological features.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 39, 12)))

Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'propertyDetails'), CTD_ANON_4, scope=Morphology, documentation=u'Collection of all PropertyDetails for this instance.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 63, 12)))

Morphology._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'groupDetails'), CTD_ANON_5, scope=Morphology, documentation=u'Collection of all GroupDetails for this instance.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 78, 12)))

def _BuildAutomaton_103 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_103
    del _BuildAutomaton_103
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 39, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 63, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 78, 12))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cells')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 37, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'features')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 39, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'propertyDetails')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 63, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(Morphology._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'groupDetails')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 78, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Morphology._Automaton = _BuildAutomaton_103()




Segment._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal'), Point, scope=Segment, documentation=u'The start point (and diameter) of the segment. If absent, it is assumed that the distal point of the parent is the start point of this segment.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 281, 12)))

Segment._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal'), Point, scope=Segment, documentation=u'The end point (and diameter) of the segment. Note if the 3D location of the distal point is the same as the proximal point, the segment is assumed to be spherical.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 287, 12)))

Segment._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'properties'), Properties, scope=Segment, documentation=u'Some optional properties associated with the segment.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 293, 12)))

def _BuildAutomaton_104 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_104
    del _BuildAutomaton_104
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 281, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 293, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Segment._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 281, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Segment._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 287, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Segment._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 293, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Segment._Automaton = _BuildAutomaton_104()




Cable._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Cable, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Cable._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Cable, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Cable._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Cable, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Cable._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Cable, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_105 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_105
    del _BuildAutomaton_105
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Cable._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Cable._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Cable._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Cable._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Cable._Automaton = _BuildAutomaton_105()




Spine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal'), Point, scope=Spine, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 480, 12)))

Spine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal'), Point, scope=Spine, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 481, 12)))

def _BuildAutomaton_106 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_106
    del _BuildAutomaton_106
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 481, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Spine._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'proximal')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 480, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Spine._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'distal')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 481, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Spine._Automaton = _BuildAutomaton_106()




def _BuildAutomaton_107 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_107
    del _BuildAutomaton_107
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(FreePoints._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'point')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 62, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
FreePoints._Automaton = _BuildAutomaton_107()




def _BuildAutomaton_108 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_108
    del _BuildAutomaton_108
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Path._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'point')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 62, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Path._Automaton = _BuildAutomaton_108()




NetworkML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=NetworkML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

NetworkML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=NetworkML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

NetworkML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=NetworkML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

NetworkML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=NetworkML, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

NetworkML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'populations'), Populations, scope=NetworkML, documentation=u"The least that's needed in a network is a population of cells...", location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 95, 17)))

NetworkML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'projections'), Projections, scope=NetworkML, documentation=u'In theory there can be no projections, if the file is intended only to specify positions', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16)))

NetworkML._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'inputs'), Inputs, scope=NetworkML, documentation=u'No inputs need be specified', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16)))

def _BuildAutomaton_109 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_109
    del _BuildAutomaton_109
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(NetworkML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(NetworkML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(NetworkML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(NetworkML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NetworkML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'populations')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 95, 17))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(NetworkML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'projections')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(NetworkML._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'inputs')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
NetworkML._Automaton = _BuildAutomaton_109()




Projections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Projections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Projections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Projections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Projections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Projections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Projections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Projections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Projections._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'projection'), Projection, scope=Projections, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 135, 16)))

def _BuildAutomaton_110 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_110
    del _BuildAutomaton_110
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Projections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Projections._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'projection')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 135, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Projections._Automaton = _BuildAutomaton_110()




Inputs._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Inputs, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Inputs._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Inputs, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Inputs._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Inputs, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Inputs._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Inputs, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Inputs._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'input'), Input, scope=Inputs, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 154, 16)))

def _BuildAutomaton_111 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_111
    del _BuildAutomaton_111
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Inputs._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Inputs._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Inputs._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Inputs._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Inputs._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'input')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 154, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Inputs._Automaton = _BuildAutomaton_111()




InputSite._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'pulse_input_instance'), PulseInput, scope=InputSite, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 325, 20)))

InputSite._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'random_stim_instance'), RandomStimInstance, scope=InputSite, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 326, 20)))

def _BuildAutomaton_112 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_112
    del _BuildAutomaton_112
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 325, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 326, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(InputSite._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'pulse_input_instance')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 325, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(InputSite._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'random_stim_instance')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 326, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
InputSite._Automaton = _BuildAutomaton_112()




SynapseInternalProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=SynapseInternalProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

SynapseInternalProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=SynapseInternalProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

SynapseInternalProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=SynapseInternalProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

SynapseInternalProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=SynapseInternalProperties, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

def _BuildAutomaton_113 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_113
    del _BuildAutomaton_113
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SynapseInternalProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SynapseInternalProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SynapseInternalProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SynapseInternalProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SynapseInternalProperties._Automaton = _BuildAutomaton_113()




Connection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=Connection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

Connection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=Connection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

Connection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=Connection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

Connection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=Connection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

Connection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'pre'), SynapticLocation, scope=Connection, documentation=u'NOTE: Attributes pre_cell_id etc. for WILL BE PREFERRED FORMAT IN v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 685, 16)))

Connection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'post'), SynapticLocation, scope=Connection, documentation=u'NOTE: Attributes post_cell_id etc. for WILL BE PREFERRED FORMAT IN v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 690, 16)))

Connection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'properties'), LocalSynapticProperties, scope=Connection, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 695, 16)))

def _BuildAutomaton_114 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_114
    del _BuildAutomaton_114
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 685, 16))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 690, 16))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 695, 16))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Connection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Connection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Connection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Connection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Connection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'pre')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 685, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Connection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'post')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 690, 16))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(Connection._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 695, 16))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Connection._Automaton = _BuildAutomaton_114()




PotentialSynLoc._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=PotentialSynLoc, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

PotentialSynLoc._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=PotentialSynLoc, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

PotentialSynLoc._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=PotentialSynLoc, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

PotentialSynLoc._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=PotentialSynLoc, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

PotentialSynLoc._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'group'), pyxb.binding.datatypes.string, scope=PotentialSynLoc, documentation=u'List of groups of sections allowing the synapse', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 886, 20)))

def _BuildAutomaton_115 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_115
    del _BuildAutomaton_115
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynLoc._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynLoc._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynLoc._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PotentialSynLoc._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PotentialSynLoc._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 886, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PotentialSynLoc._Automaton = _BuildAutomaton_115()




NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes'), Notes, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties'), Properties, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation'), Annotation, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'group'), Group, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList'), Authors, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication'), Publication, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref'), NeuronDBReference, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref'), ModelDBReference, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef'), NeuroMorphoRef, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'populations'), Populations, scope=NeuroMLLevel3, documentation=u"The least that's needed in a network is a population of cells...", location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 95, 17)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'projections'), Projections, scope=NeuroMLLevel3, documentation=u'In theory there can be no projections, if the file is intended only to specify positions', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'inputs'), Inputs, scope=NeuroMLLevel3, documentation=u'No inputs need be specified', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace, u'cells'), Level3Cells, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 63, 12)))

NeuroMLLevel3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace, u'channels'), ChannelML, scope=NeuroMLLevel3, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 65, 12)))

def _BuildAutomaton_116 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_116
    del _BuildAutomaton_116
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 63, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 65, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 67, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16))
    counters.add(cc_13)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace, u'cells')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 63, 12))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace, u'channels')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 65, 12))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'populations')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 95, 17))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'projections')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 101, 16))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(NeuroMLLevel3._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'inputs')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 107, 16))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_11, True),
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_11, True),
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_13, True) ]))
    st_13._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
NeuroMLLevel3._Automaton = _BuildAutomaton_116()




Level3Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace, u'biophysics'), Level3Biophysics, scope=Level3Cell, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 117, 24)))

Level3Cell._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace, u'connectivity'), Level3Connectivity, scope=Level3Cell, documentation=u'Note: from v1.7.1 the preferred way to specify a potential synaptic location \n                                is with a potential_syn_loc element under connectivity under cell, as opposed to the potentialSynapticLocation \n                                under biophysics under cell. The former will be the only option from v2.0', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 119, 24)))

def _BuildAutomaton_117 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_117
    del _BuildAutomaton_117
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 142, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 189, 24))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 224, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 241, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 260, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 117, 24))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 119, 24))
    counters.add(cc_15)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'status')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 142, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'authorList')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 397, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'publication')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 398, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuronDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 399, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'modelDBref')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 400, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'neuroMorphoRef')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 401, 12))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'segments')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 154, 12))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cables')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 189, 24))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'cellBody')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 224, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'spines')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 241, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace_mml, u'freePoints')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/MorphML_v1.8.1.xsd', 260, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_14, False))
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace, u'biophysics')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 117, 24))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_15, False))
    symbol = pyxb.binding.content.ElementUse(Level3Cell._UseForTag(pyxb.namespace.ExpandedName(_Namespace, u'connectivity')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 119, 24))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_15, True) ]))
    st_16._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Level3Cell._Automaton = _BuildAutomaton_117()




BlockingSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'block'), Block, scope=BlockingSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 328, 16)))

def _BuildAutomaton_118 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_118
    del _BuildAutomaton_118
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(BlockingSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(BlockingSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(BlockingSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(BlockingSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(BlockingSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'block')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 328, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
BlockingSynapse._Automaton = _BuildAutomaton_118()




def _BuildAutomaton_119 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_119
    del _BuildAutomaton_119
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MultiDecaySynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MultiDecaySynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MultiDecaySynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MultiDecaySynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MultiDecaySynapse._Automaton = _BuildAutomaton_119()




GlobalSynapticProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type'), pyxb.binding.datatypes.string, scope=GlobalSynapticProperties, documentation=u'For compatability to pre v1.7.1. Will be removed in v2.0.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 479, 20)))

GlobalSynapticProperties._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'default_values'), SynapseInternalProperties, scope=GlobalSynapticProperties, documentation=u'For compatability to pre v1.7.1. Will be removed in v2.0.', location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 484, 20)))

def _BuildAutomaton_120 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_120
    del _BuildAutomaton_120
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 479, 20))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 484, 20))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(GlobalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(GlobalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(GlobalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(GlobalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(GlobalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'synapse_type')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 479, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(GlobalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'default_values')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 484, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
GlobalSynapticProperties._Automaton = _BuildAutomaton_120()




def _BuildAutomaton_121 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_121
    del _BuildAutomaton_121
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(LocalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(LocalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(LocalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(LocalSynapticProperties._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
LocalSynapticProperties._Automaton = _BuildAutomaton_121()




Level3Biophysics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_net, u'potentialSynapticLocation'), PotentialSynapticLocation, scope=Level3Biophysics, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 971, 16)))

def _BuildAutomaton_122 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_122
    del _BuildAutomaton_122
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 66, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 67, 16))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 70, 16))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 71, 16))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NeuroML_Level3_v1.8.1.xsd', 144, 24))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 971, 16))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'mechanism')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 50, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificCapacitance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 58, 16))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_capacitance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 59, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'specificAxialResistance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 62, 16))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'spec_axial_resistance')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 63, 16))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'initialMembPotential')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 66, 16))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'init_memb_potential')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 67, 16))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'ionProperties')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 70, 16))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_bio, u'ion_props')), pyxb.utils.utility.Location(u'http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/Biophysics_v1.8.1.xsd', 71, 16))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Level3Biophysics._UseForTag(pyxb.namespace.ExpandedName(_Namespace_net, u'potentialSynapticLocation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level3/NetworkML_v1.8.1.xsd', 971, 16))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, True),
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Level3Biophysics._Automaton = _BuildAutomaton_122()




FacDepSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'plasticity'), FacDep, scope=FacDepSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 433, 16)))

def _BuildAutomaton_123 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_123
    del _BuildAutomaton_123
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(FacDepSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(FacDepSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(FacDepSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(FacDepSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(FacDepSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'plasticity')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 433, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
FacDepSynapse._Automaton = _BuildAutomaton_123()




StdpSynapse._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(_Namespace_cml, u'spike_time_dep'), StdpDep, scope=StdpSynapse, location=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 450, 16)))

def _BuildAutomaton_124 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_124
    del _BuildAutomaton_124
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StdpSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'notes')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StdpSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'properties')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 300, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StdpSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'annotation')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 301, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StdpSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_meta, u'group')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level1/Metadata_v1.8.1.xsd', 302, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(StdpSynapse._UseForTag(pyxb.namespace.ExpandedName(_Namespace_cml, u'spike_time_dep')), pyxb.utils.utility.Location('http://www.neuroml.org/NeuroMLValidator/NeuroMLFiles/Schemata/v1.8.1/Level2/ChannelML_v1.8.1.xsd', 450, 16))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
StdpSynapse._Automaton = _BuildAutomaton_124()

